{"posts":[{"title":"JavaScript Generator","content":"从 Iterator 讲起 与 Python 的 Iterable 类似，ES6 添加的 Iterator 支持也是通过获取 Iterable 对象的迭代器，然后通过next进行类似于惰性求值的工作。 下面是 Python Iterable 的示例： rangeIter = iter(range(3)) next(rangeIter) # 0 next(rangeIter) # 1 next(rangeIter) # 2 next(rangeIter) # throw StopIteration 然后是 JavaScript Iterable 示例： rangeIter = [1, 2, 3][Symbol.Iterator] rangeIter.next() // { value: 1, done: false } rangeIter.next() // { value: 2, done: false } rangeIter.next() // { value: 3, done: false } rangeIter.next() // { value: undefined, done: true } Generator 语法说明 Generator 函数是 ES6 标准中提供的异步编程解决方案，语法与 Python 类似： function* gen() { yield 1; yield 2; return 'end'; } Generator 函数的调用方法与普通函数一样，也是在函数名后面加上一对圆括号。不同的是，调用 Generator 函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象，即 Iterator 对象。 下一步，必须调用遍历器对象的next方法，使得指针移向下一个状态。 yield表达式本身没有返回值，或者说总是返回undefined。next方法可以带一个参数，该参数就会被当作上一个yield表达式的返回值。 Generator 函数返回的遍历器对象，都有一个throw方法，可以在函数体外抛出错误，然后在 Generator 函数体内捕获。 var g = function* () { try { yield; } catch (e) { console.log('内部捕获', e); } }; var i = g(); i.next(); try { i.throw('a'); i.throw('b'); } catch (e) { console.log('外部捕获', e); } ","link":"https://wzhzzmzzy.github.io/post/2019-7-2-JS-Generator"},{"title":"JavaScript 笔记（三）：一些细枝末节","content":"语法细节 变量作用域 全局变量自然拥有全局作用域，不过在 JavaScript 任何一个运行环境：NodeJS、浏览器，似乎其实都不存在一个全局环境。浏览器下最大的作用域是&lt;script&gt;，NodeJS的作用域也顶多是在一个文件模块内部。 函数体内部，局部var变量的优先级高于同名的全局var变量。 var scope = &quot;global&quot;; function checkscope() { var scope = &quot;local&quot;; return scope; } checkscope(); 函数作用域与声明提前 下面这个函数中，在不同的位置定义了变量i，j，k，但是这三个变量都可以在整个函数范围内访问到。 function test(o) { var i = 0; if (typeof o == &quot;object&quot;) { var j = 0; for (var k = 0; k &lt; 10; ++k) { console.log(k); } console.log(k); } console.log(j); } 这个函数其实与下面的写法是等价的： function test(o) { var i = 0, j, k; if (typeof o == &quot;object&quot;) { j = 0; for (k = 0; k &lt; 10; ++k) { console.log(k); } console.log(k); } console.log(j); } 下面这段代码也可能有一些歧义，我们可以联合上面提到的声明提前与变量作用域这两点来理解他： var scope = &quot;global&quot;; function f() { console.log(scope); var scope = &quot;local&quot;; console.log(scope); } 可能你会觉得函数第一行的输出是global，但是其实是undefined。所以，多用let。 作用域链 JS 是基于作用域链的，每一段 JS 代码都有一个与之相关的作用域链。 什么是作用域链呢？我们可以这样理解，作用域链就是一个链表，链表的每一个节点上记录了一个作用域，这个作用域有自己的变量。比如对于全局环境而言，链表只有一个节点，就是全局环境；对于非嵌套的函数而言，全局环境之上还有一个函数作用域，其中记录了形参和局部变量；嵌套函数自然还有自己的函数作用域。 当使用变量时，会自上而下查找作用域链，一旦找到了，就会直接返回，这就解释了为什么全局变量会被局部变量覆盖，也导致了后面要讲到的闭包现象。 继承 大家都知道 JS 有个神秘的 prototype，有时候觉得无法理解。下面是一个示例inherit函数： function inherit(p) { if (p === null) throw TypeError(); if (Object.create) return Object.create(p); var t = typeof p; if (t !== &quot;object&quot; &amp;&amp; t !== &quot;function&quot;) throw TypeError(); function f() {}; f.prototype = p; return new f(); } 取值和赋值都会对原型链进行查找，以此来判断如何对对象的属性进行修改。对于对象来说，原型是只读的，也就是大家无法对对象的原型进行修改，除非通过defineProperty。 命名空间 在过去的 ES5 时代，大家可以通过函数来实现命名空间。也就是，通过立即执行函数来执行一些命名空间的初始化操作，生成一些封装好的工具。 var myModule = (function { var test = &quot;test&quot;; return function() {console.log(test)}; }()); 闭包 所谓闭包，就是当我们使用嵌套函数时，可以用它来保存函数内的局部变量。这是因为作用域链的原因。对于函数中声明的嵌套函数，其作用域链肯定是外部函数高于全局变量的，所以外部函数的变量环境在嵌套函数中会获得保留。 只用文字描述一定有些抽象，有一个简单的例子： var scope = &quot;global scope&quot;; function checkscope() { var scope = &quot;local scope&quot;; function f() { return scope; } return f; } checkscope()(); // local scope 有什么用呢？可以使用闭包来灵活地生成一些有着完全封闭的私有变量的函数，避免恶意改动。 异步、同步加载 &lt;script&gt;标签可以有defer和async属性，一般来说，这些属性只在和src属性联合使用时才有效，但是有些浏览器还支持延迟的内联脚本。 async和defer都是告诉浏览器，可以在下载脚本的同时继续解析和渲染文档，defer属性让浏览器延迟脚本的执行直到文档载入和解析完成，async让浏览器可以尽快执行脚本，而不用在下载脚本的同事阻塞文档解析。 顺便，如果同时具有这两个属性，那么浏览器会使用async，而不是defer。 当然，在不支持async的浏览器里，可以动态创建&lt;script&gt;元素并插入到文档当中： function loadsync(url) { var head = document.getElementsByTagName(&quot;head&quot;)[0]; var s = document.createElement(&quot;script&quot;); s.src = url; head.appendChild(s); } 浏览器相关 事件驱动 JavaScript 是事件驱动的。一般而言，我们更多时候是在监听事件、绑定处理函数，而不是做一些时刻处在运行状态的脚本，那样低效且难以维护。 通常，我们推荐使用addEventListener而不是直接对DOM元素的onxxx属性赋值来进行事件的监听，因为这样可以添加多个监听函数，而不是只能绑定一个。 这里有一个小小的使用setTimeout的点子，也就是使用setTimeout来人为添加异步队列。因为setTimeout不会立即执行函数，而是在定时结束之后将函数放入任务队列，所以我们可以： function onLoad(f) { if (onLoad.loaded) window.setTimeout(f, 0); // 通过 setTimeout 将 f 放入之后的队列 else if (window.addEventListener) window.addEventListener(&quot;load&quot;, f, false); else if (window.attachEvent) window.attachEvent(&quot;onload&quot;, f); } onLoad.loaded = false; onLoad(function() { onLoad.loaded = true; }); 浏览器时间线 创建 Document 对象，并且开始解析 Web 页面，解析 HTML 元素和文本内容后添加 Element 对象和 Text 节点到文档中。这个阶段document.readyState === &quot;loadging&quot;。 当遇到没有async和defer的&lt;script&gt;元素时，会将这些元素添加到文档中，然后执行脚本。并且在脚本执行的同时，脚本会同步执行，并且在脚本下载和执行的同时，解析器会暂停。 当解析器遇到了设置了async属性的&lt;script&gt;元素，会开始下载脚本，然后尽快运行，并继续解析文档。脚本会在它下载完成之后尽快执行，但是解析器没有停下来等他下载。异步脚本禁止使用document.write()方法。 当文档完成解析之后，document.readyState === &quot;interactive&quot;。 所有有defer属性的脚本，会按照他们在文档里出现的顺序执行，异步脚本可能也会在这个时间执行。延迟脚本能访问完整的文档树，但是禁止使用document.write()。 Document 对象触发DOMContentLoaded事件，标志着程序执行从同步转换到了异步事件驱动阶段。 这时，文档已经完全解析，但是浏览器可能还在等待其他内容载入。所有内容完成载入，所有异步脚本也执行完成，document.readyState属性改变为&quot;complete&quot;，浏览器触发window对象上的load事件。 到这时，才会进入下一个异步任务队列。 这是理想的时间线，但是在不同浏览器中有差异。所有浏览器都支持load事件，它才是决定文档载入并且可以操作的最通用的技术。 跨站脚本（Cross-site scripting） 所谓 XSS 攻击也就是直接将用户输入添加到 HTML 文档中。可以使用脚本注入直接在站点内执行其他脚本，来获取用户。这是非常危险的攻击。例如： &lt;script&gt; var name = decodeURIComponent(window.location.search.substring(1)) || &quot;&quot;; document.write(&quot;Hello &quot; + name); &lt;/script&gt; 这样就可以在站点上执行远端脚本，从而进行一些入侵。 window 对象 window对象有着很多浏览器的 API。 浏览器和屏幕信息 通过window的navigator和screen两个对象可以获取到相关的信息。 打开和关闭窗口 window.open载入指定的 URL 到新的或已经存在的窗口中，并且返回代表那个窗口的window对象。 open的第一个参数是 URL，第二个参数时新打开的窗口的名字。如果是一个已经存在的窗口的名字，那么就会直接使用已经存在的窗口。否则，会打开新的窗口。需要注意的是，脚本无法通过猜测窗口的名字来操控窗口中的 Web 应用。一般来说，只有文档是来自同源的，或者确实是由同一个脚本打开的才会生效。 windows.open是广告商用来弹窗的手段，所以一般来说如果不是用户点击导致的弹窗，会被浏览器所屏蔽。 window.close可以关闭一个窗口。 IndexedDB 可以认为 IndexedDB是一个浏览器环境下内置的 NoSQL。IndexedDB限制只有同源的网站可以相互访问内容，不同源的就不可以。每个源可以有任意数目的数据库，但是名字在当前源内需要是唯一的。 IndexedDB提供原子性保证，也就是对数据库的 CURD 操作是包含在一个事务内部的。这个数据库内，所有操作都是异步的，当成功或者失败的时候，会触发success和error事件。 ","link":"https://wzhzzmzzy.github.io/post/2019-6-1-JavaScript的细枝末节"},{"title":"JavaScript 笔记（一）：内存模型","content":"JS 原始数据类型的变量声明和赋值 let num = 23; 当我们创建了这么一个变量的时候，JS 会 为变量创建一个唯一标识符， 在内存里分配一个地址， 将值 23 存储在分配的地址。 let newNum = num; 此时，num和newNum指向的地址是相同的。 num = num + 1; 这样会导致num和newNum指向不同的地址，因为 JS 中原始数据类型不可变，当num + 1解析为24的时候，JS 会在内存中分配一个新地址，将24作为其值存储，num指向新地址。 字符串也是一样，当修改了字符串之后，不会在原来的内存位置对原串进行修改，而是重新分配一个内存地址用于存放新串。 调用堆栈和堆 “JS 中，原始数据类型放在调用栈中，而引用类型放在内存堆中。” 这句话基本是正确的，但是有一些小小的地方需要纠正：引用类型的变量本身也是放在栈中的。 JS 引用类型的变量声明和赋值 让我们从一个简单的例子开始。下面，我们声明一个名为myArray的变量，并用一个空数组初始化它。 let myArray = []; 当你声明变量“myArray”并为其指定非原始数据类型（如“[]”）时，以下是在内存中发生的情况： 为变量创建唯一标识符（“myArray”） 在内存中分配一个地址（将在运行时分配） 存储在堆上分配的内存地址的值（将在运行时分配） 堆上的内存地址存储分配的值（空数组[]） let vs. const 一般来说，我们应该尽可能多地使用const，只有当我们知道某个变量将发生改变时才使用let。 事实上，const的意义是：不允许更改变量的内存地址，let则允许。所以可以使用const来声明引用类型，只要不更改其指向即可。 ","link":"https://wzhzzmzzy.github.io/post/2019-5-31-JavaScript内存模型"},{"title":"Webpack 基础","content":"Webpack 基础 Webpack Entry Webpack根据入口文件（entry）构建依赖树，添加到依赖图中，遍历依赖图来对资源进行打包。 Webpack Entry 可以有两种用法，单入口或多入口： module.exports = { entry: './path/to/entry.js' } module.exports = { entry: { app: './path/app.js', adminApp: './path/admin.js' } } Webpack Output Webpack 通过 Output 将编译后的文件输出到磁盘。 单入口配置方式： const path = require('path'); module.exports = { entry: './path/to/entry.js', output: { filename: 'bundle.js', path: path.join(__dirname, 'dist') } }; 多入口配置方式： const path = require('path'); module.exports = { entry: { app: './path/app.js', adminApp: './path/admin.js' }, output: { filename: '[name].js', path: path.join(__dirname, 'dist') } }; Webpack Loader Webpack 默认只支持 JS 和 JSON 两种文件类型，通过 Loaders 去支持其他文件类型并且把他们转为有效的模块，并且可以添加到依赖图中。 Loader 本身是一个函数，读取源文件内容，返回转换的结果。 常用 Loaders babel-loader css-loader less-loader ts-loader file-loader：图片、字体打包。 raw-loader：字符串形式导入文本。 thread-loader：多进程打包 JS 和 CSS 使用语法 const path = require('path'); module.exports = { output: { filename: 'bundle.js', path: path.join(__dirname, 'dist') }, module: { rules: [ { text: /\\.txt$/, use: 'raw-loader' } ] } }; Webpack Plugins 插件用于对 Webpack 功能进行增强：bundle 文件优化、资源管理、环境变量注入。插件作用于整个构建的过程。 常用的 Plugins CommonsChunkPlugin：多页面打包，将共同引用的模块代码提取成公共 JS。 CleanWebpackPlugin：清理构建目录。 ExtractTextWebpackPlugin：将 CSS 提取成独立的 CSS 文件。 CopyWebpackPlugin：将文件或者文件夹拷贝到构建的输出目录。 HtmlWebpackPlugin：创建 HTML 文件，用于承载bundle。 UglifyjsWebpackPlugin：压缩代码。 ZipWebpackPlugin：压缩为 Zip。 使用语法 const path = require('path'); module.exports = { output: { filename: 'bundle.js', path: path.join(__dirname, 'dist') }, plugins: [ new HtmlWebpackPlugin({template: './src/index.html'}) ] }; Webpack Mode Mode 用于指定当前的构建环境，production、development、none。 针对于构建环境，Webpack 会自动对插件做一些配置。可以通过NODE_ENV环境变量来指定。 解析指定文件 ES6 和 React JSX babel-loader 依赖 babel-core，因此需要添加配置文件：.babelrc。 { &quot;presets&quot;: [ &quot;@babel/preset-env&quot; ] } 并需要安装依赖： yarn add -D @babel/core @babel/preset-env babel-loader 这样就可以使用 babel-loader 编译 ES6 代码了： const path = require('path'); module.exports = { entry: { main: './src/main.js', search: './src/search.js' }, output: { path: path.resolve(__dirname, 'dist'), filename: '[name].js' }, mode: 'production', module: { rules: [{ test: /.js$/, use: 'babel-loader' }] } } 解析 React 需要添加@babel/preset-react，别的没有任何差别。 CSS、Less 解析CSS需要使用css-loader和style-loader： yarn add -D style-loader css-loader const path = require('path'); module.exports = { entry: { // ... }, output: { // ... }, mode: 'production', module: { rules: [{ test: /.css$/, use: ['style-loader', 'css-loader'] }] } } loader 在一个 rule 中是链式调用的，并且顺序从右到左，所以需要将style-loader写在前面。 less-loader用于将 Less 转为 CSS。 yarn add -D less less-loader const path = require('path'); module.exports = { entry: { // ... }, output: { // ... }, mode: 'production', module: { rules: [{ test: /.css$/, use: ['style-loader', 'css-loader'] }, { test: /.less$/, use: ['style-loader', 'css-loader', 'less-loader'] }] } } 图片和字体 使用file-loader或者url-loader可以处理文件： yarn add -D file-loader url-loader const path = require('path'); module.exports = { entry: { // ... }, output: { // ... }, mode: 'production', module: { rules: [{ test: /.(png|jpg|jpeg|svg|gif)$/, use: [{ loader: 'url-loader', options: { limit: 10240 } }] }, { test: /.(otf|woff|woff2|eot|ttf)$/, use: 'file-loader' }] } } Webpack 文件监听 Webpack 当然也可以使用文件监听，当源码发生变化时自动重新构建。缺陷在于需要每次刷新浏览器。只需要在webpack命令后添加--watch即可。 可以添加一些相关的配置： module.export = { watch: true, watchOptions: { ignored: /node_modules/ aggregateTimeout: 300, pool: 1000 // 查询修改间隔时间 } } 热更新 使用webpack-dev-server可以获得热更新功能。WDS 不会导致浏览器刷新，也不会输出文件，而是全部放在内存当中，这也提高了速度。以下就是可以打开 WDS 的命令： webpack-dev-server --open 当然，首先需要安装它： yarn add -D webpack-dev-server 然后需要添加一些配置： const path = require('path'); module.exports = { entry: { main: './src/main.js', search: './src/search.js' }, output: { path: path.resolve(__dirname, 'dist'), filename: '[name].js' }, mode: 'development', // ... devServer: { contentBase: './dist', hot: true } } 为了实现更加多样的测试，可以使用webpack-dev-middleware。 原理分析 Webpack 热更新首先需要将 JS 编译为 Bundle，然后将热更新的文件输出到 HMR Runtime，Bundle Server 提供浏览器内的文件访问，HMR Runtime 则会被注入到浏览器中，用于更新后续的变化。 文件指纹 为了让更新的文件不会与之前的缓存文件冲突，导致新修改的文件不会被下载，使用文件指纹来标识文件内容。添加了文件指纹后，浏览器就可以知道需要下载哪些新文件，而之前的未修改的缓存还会继续使用。 有三种文件指纹哈希： Hash：与整个项目的构建相关，一旦有文件发生改变，整个项目的构建hash就会改变， ChunkHash：与 Webpack 打包的 Chunk 有关，不同的 Entry 有不同的 ChunkHash，只有 Chunk 改变了才会改变， ContentHash：根据文件内容来定义 hash，文件内容不变，则 ContentHash 不变。 输出文件名要携带 Hash 只需要修改 Output字段即可： const path = require('path'); module.exports = { entry: { main: './src/main.js', search: './src/search.js' }, output: { path: path.resolve(__dirname, 'dist'), filename: '[name].[chunkhash:8].js' }, // ... } 对于 CSS 文件指纹，我们会需要使用一个插件：MiniCssExtrackPlugin。 module.exports = { // ... module: { rules: [{ test: /.css$/, use: [ MiniCssExtractPlugin.loader, 'css-loader' ] }, { test: /.less$/, use: [ MiniCssExtractPlugin.loader, 'css-loader', 'less-loader' ] }] } plugins: [ new MiniCssExtractPlugin({ filename: `[name]:[content:8]:css` }) ] } 图片文件指纹设置一般使用[hash]，这个hash与图片文件本身的 MD5 相关。 const path = require('path'); module.exports = { // ... moduls: { rules: [{ test: /.(png|jpg|jpeg|svg|gif)$/, use: [{ loader: 'url-loader', options: { limit: 10240, name: '[name].[hash:8].[ext]' } }] }, { test: /.(otf|woff|woff2|eot|ttf)$/, use: [{ loader: 'file-loader', options: { name: '[name].[hash:8].[ext]' } }] }] } } 代码压缩 对于JS文件，Webpack 内置了uglifyjs-webpack-plugin；CSS 使用optimize-css-assets-webpack-plugin，同时使用 cssnano；HTML文件使用html-webpack-plugin。 const OptimizeCSSAssetsPlugin = require('optimize-css-assets-webpack-plugin'); module.exports = { plugins: [ new OptimizeCSSAssetsPlugin({ assetNameRegExp: /\\.css$/g, cssProcessor: require('cssnano') }), new HtmlWebpackPlugin({ template: path.join(__dirname, 'src/search.html'), filename: 'search.html', chunks: ['search'], inject: true, minify: { html5: true, collapseWhitespace: true, preseveLineBreaks: false, minifyCSS: true, minifyJS: true, removeComments: false } }), ] } ","link":"https://wzhzzmzzy.github.io/post/2019-5-28-Webpack基础"},{"title":"Webpack Tricks","content":"自动清理构建目录 通过 npm scripts 清理构建目录 rm -rf ./dist &amp;&amp; webpack Webpack 清理 避免构建前每次都要手动删除dist目录。首先我们需要安装clean-webpack-plugin，默认删除output指定的输出目录。 plugins: [ new CleanWebpackPlugin(); ] PostCSS 插件 autoprefixer 由于浏览器对于 CSS 属性的支持不同，所以有时会需要添加前缀： .box { -moz-border-radius: 10px; -webkit-border-radius: 10px; -o-border-radius: 10px; border-radius: 10px; } 我们可以通过插件autoprefixer来自动补全这些前缀。与之前用到的预处理不同的是，它是一个后置处理器。 npm i postcss-loader autoprefixer -D 然后我们可以修改一下之前对LESS的配置： { test: /.less$/, use: [ MiniCssExtractPlugin.loader, 'css-loader', 'less-loader', { loader: 'postcss-loader', options: { plugins: () =&gt; [ require('autoprefixer')({ browsers: ['last 2 version', '&gt;1%', 'ios 7'] }) ] } } ] } 移动端 CSS px自动换算rem 使用 CSS 媒体查询实现响应式布局，缺点在于需要写多套适配的样式代码。 @media screen and (max-width: 980px) { .header { width: 900px; } } 使用 rem(font-size of the root element) 可以减少代码量。 使用px2rem-loader自动将 CSS px换算成rem，可以使用lib-flexible自动在页面渲染时计算根元素的font-size。 { test: /.less$/, use: [ MiniCssExtractPlugin.loader, 'css-loader', 'less-loader', { loader: 'postcss-loader', options: { plugins: () =&gt; [ require('autoprefixer')({ browsers: ['last 2 version', '&gt;1%', 'ios 7'] }) ] } }, { loader: 'px2rem-loader', options: { remUnit: 75, // 1 rem == 75 px remPrecision: 8 // 保留小数 } } ] } 下面讲解如何便捷地引入内联 JS 代码。 静态资源内联 使用raw-loader即可内联 HTML 和 JS： &lt;script&gt;${require('raw-loader!babel-loader!./meta.html')}&lt;/script&gt; &lt;script&gt;${require('raw-loader!babel-loader!../node_modules/lib-flexible')}&lt;/script&gt; 内联 CSS 比较复杂，有两种做法：style-loader和html-inline-css-webpack-plugin： 使用style-loader时，options中设置singleton: true即可。 多页面应用打包通用方案 多页面应用对 SEO 更加友好，天然解耦。 利用glob.sync可以动态获取entry，设置html-webpack-plugin数量： const setMPA = () =&gt; { const entry = {}; const htmlWebpackPlugins = []; const entryFiles = glob.sync(path.join(__dirname, 'src/*/index.js')) Object.keys(entryFiles).map((index) =&gt; { const entryFile = entryFiles[index]; const match = entryFiles.match(/src\\/(.*)\\/index\\.js/); const pageName = match &amp;&amp; match[1]; entryFile[pageName] = entryFile; htmlWebpackPlugins.push( new HtmlWebpackPlugin({ template: path.join(__dirname, `src/${pageName}/index.html`), filename: `${pageName}.html`, chunks: [pageName], inject: true, minify: { html5: true,. collapseWhitespace: true, preserveLineBreaks: false, minifyCSS: true, minifyJS: true, removeComments: false } }) ); }) return { entry, htmlWebpackPlugins } } const { entry, htmlWebpackPlugins } = setMPA(); module.exports = { entry, plugins: [ //... ].concat(htmlWebpackPlugins) } Source Map 用于发生错误时定位代码段。一般只在开发环境使用，线上生产环境排查问题时可以将 SourceMap 上传到错误监控系统。 关键字 eval：使用eval包裹模块代码； source map：产生.map文件； cheap：不包含列信息，只能定位到行号； inline：将.map作为 DataURI 嵌入，不单独生成.map文件； module：包含loader的 Source Map。 通过这些关键字的排列组合可以拼接出不同的 Source Map 类型。 例子 使用eval，不会生成.map文件。 module.exports = { mode: 'none', devtools: 'source-map|eval|...' } ","link":"https://wzhzzmzzy.github.io/post/2019-6-14-Webpack进阶"},{"title":"Vue 的双向绑定","content":"发布 - 订阅模式的数据双向绑定 这是最简单有效的途径，让所有 JavaScript对象和 DOM元素都订阅一个发布者对象，任何时候如果 JavaScript 对象或者一个输入字段被侦测到发生了变化，就后反过来广播并传播到所有绑定的对象和元素。 实现 实现一个简单的发布订阅模式非常简单，下面是一个用 jQuery 实现的例子。 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;zh-CN&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt; &lt;title&gt;简单的数据双向绑定&lt;/title&gt; &lt;script src=&quot;https://code.jquery.com/jquery-3.4.1.min.js&quot; integrity=&quot;sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=&quot; crossorigin=&quot;anonymous&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(function() { //发布订阅原型 function PubSub() { //存储事件名与回调函数 var eventContainer = {}; //订阅 存储事件 this.subscribe = function(eventName, callback) { var callbacks = eventContainer[eventName] || []; callbacks.push(callback); eventContainer[eventName] = callbacks; } //发布 调用相应事件 this.publish = function() { var eventName = [].shift.call(arguments); var callbacks = eventContainer[eventName]; if (!callbacks || callbacks.length == 0) { return false; } for(var i = 0; i &lt; callbacks.length; i++) { var callback = callbacks[i]; callback.apply(this, arguments); } } } //实例化发布订阅原型 function InstancePubSub() { var pubSub = new PubSub; //监听model变化 pubSub.subscribe(&quot;model-change&quot;, function(key, newVal) { //model变化更新视图 $(&quot;[data-bind=&quot; + key + &quot;]&quot;).each(function() { if ($(this).is(&quot;input, textarea, select&quot;)) { $(this).val(newVal); } else { $(this).html(newVal); } }) $(&quot;#modelView&quot;).html(newVal) }); //对视图层元素进行change事件绑定 $(document).on(&quot;input&quot;, &quot;[data-bind]&quot;, function(evt) { //一旦view发生变化通知调用回调函数更新model pubSub.publish(&quot;view-change&quot;, $(this).attr(&quot;data-bind&quot;), $(this).val()); }); return pubSub; } function User() { var pubSubInstance = new InstancePubSub; var user = { properties : {}, _set : function(key, value) { this.properties[key] = value; //model变化通知更新view pubSubInstance.publish(&quot;model-change&quot;, key, value); }, _get : function(key) { return this.properties[key]; } }; pubSubInstance.subscribe(&quot;view-change&quot;, function(key, newVal) { //视图变化 更新model user._set(key, newVal); }); return user; } var user = new User; //设置model值 user._set(&quot;age&quot;, 1); //绑定model到view $(&quot;#modelView&quot;).html(user._get(&quot;age&quot;)) //测试model变化引起view变化 $(&quot;#btn&quot;).click(function() { user._set(&quot;age&quot;, parseInt(user._get(&quot;age&quot;)) + 1); }) }) &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;input type=&quot;number&quot; data-bind=&quot;age&quot; /&gt; &lt;div id=&quot;modelView&quot;&gt;&lt;/div&gt; &lt;button id=&quot;btn&quot;&gt;+1&lt;/button&gt; &lt;/body&gt; &lt;/html&gt; 这种方式虽然简单，但是毕竟并不快捷，修改数据时必须使用vm.set('property', value)，我们更希望使用vm.property = value这种方式进行更新。 脏值检查 Angular.js 通过脏值检测来比对数据是否有变更。最简单的方式就是使用setInterval()进行定期轮询。当然，不会真的这么无脑，Angular 只有在指定事件触发的时候才会进入脏值检测： DOM 事件，例如用户输入文本，点击按钮。 XHR 响应事件。 浏览器 Location 变更事件。 Timer 事件。 执行$digest()或者$apply()。 数据劫持 下面我们就来详细介绍一下 Vue 的做法。Vue.js 通过Object.definProperty()来劫持各个属性的setter或者getter。查看 MDN 文档中对defineProperty的解释：Object.defineProperty() 为了实现MVVM的数据双向绑定，就需要实现以下几点： 数据监听，如果数据发生变动可以拿到最新的值并通知订阅者。 指令解析器，对每个元素节点的指令进行扫描和解析，通过指令模板替换数据，以及绑定相应的更新函数。 watcher，连接监听器和解析器，订阅并收到所有属性变动的通知，执行指令绑定的相应回调。 MVVM 入口函数。 下面是流程图： 实现 Observer var data = {name: 'foo'}; observe(data); data.name = 'bar'; // for --&gt; bar function observe(data) { if (!data || typeof data !== 'object') return; Object.keys(data).forEach(function(key) { defineReactive(data, key, data[key]); }); }; function defineReactive(data, key, val) { observe(val); // 递归监听子属性 Object.defineProperty(data, key, { enumerable: true, // 可枚举 configurable: false, // 不能再define get: () =&gt; val, set: function(newVal) { console.log(val, ' --&gt; ', newVal); val = newVal; } }); } 这样我们就可以监听每个数据的变化了。监听到变化之后，需要通知订阅者，所以我们需要实现一个消息订阅器。很简单，只需要维护一个数组，用来收集订阅者，数据变动触发notify，然后调用订阅者的update即可。 我们将defineReactive中的set方法修改一下： function defineReactive(data, key, val) { var dep = new Dep(); observe(val); Object.defineProperty(data, key, { // ... set: function(newVal) { if (val === newVal) return; console.log(val, ' --&gt; ', newVal); val = newVal; dep.notify(); // 通知所有订阅者 } }); } function Dep() { this.subs = []; } Dep.prototype = { addSub: function(sub) { this.subs.push(sub); }, notify: function() { this.subs.forEach(function(sub) { sub.update(); }); } }; 那么还有一个问题，如何添加订阅呢？由于dep是私有的，我们不能直接将订阅者添加到其中。上面思路整理中，我们明确了订阅者应该是Watcher，我们可以在getter里面动手，这样就可以在闭包内操作了。 // Observer.js // ... Object.defineProperty(data, key, { get: function() { // 由于需要在闭包内添加watcher，所以通过Dep定义一个全局target属性，暂存watcher, 添加完移除 Dep.target &amp;&amp; dep.addSub(Dep.target); return val; } // ... }); // Watcher.js Watcher.prototype = { get: function(key) { Dep.target = this; this.value = data[key]; // 这里会触发属性的getter，从而添加订阅者 Dep.target = null; } } 这里就实现了一个 Observer 了，我们可以使用它监听数据、通知订阅者。接下来需要实现 Compiler。 实现 Compiler 由于我们需要操作多次 DOM 节点，为了提高性能，我们可以把节点换回文档碎片进行解析编译操作，解析完成再将fragment添加到原来真实的 DOM 节点当中。 function Compile(el) { this.$el = this.isElementNode(el) ? el : document.querySelector(el); if (this.$el) { this.$fragment = this.node2Fragment(this.$el); this.init(); this.$el.appendChild(this.$fragment); } } Compile.prototype = { init: function() { this.compileElement(this.$fragment); }, node2Fragment: function(el) { var fragment = document.createDocumentFragment(), child; // 将原生节点拷贝到fragment while (child = el.firstChild) { fragment.appendChild(child); // 会将第一个元素从 el 移动到 fragment } return fragment; } }; complieElement方法将遍历所有节点和其子节点，进行扫描解析编译，调用对应的指令渲染函数进行数据渲染，并调用对应的指令更新函数进行绑定： Compile.prototype = { // ... compileElement: function(el) { var childNodes = el.childNodes, me = this; [].slice.call(childNodes).forEach(function(node) { var text = node.textContent; var reg = /\\{\\{(.*)\\}\\}/; // 表达式文本 // 按元素节点方式编译 if (me.isElementNode(node)) { me.compile(node); } else if (me.isTextNode(node) &amp;&amp; reg.test(text)) { me.compileText(node, RegExp.$1); } // 递归编译子节点 if (node.childNodes &amp;&amp; node.childNodes.length) { me.compileElement(node); } }); }, compile: function(node) { var nodeAttrs = node.attributes, me = this; [].slice.call(nodeAttrs).forEach(function(attr) { // 规定：指令以 v-xxx 命名 // 如 &lt;span v-text=&quot;content&quot;&gt;&lt;/span&gt; 中指令为 v-text var attrName = attr.name; // v-text if (me.isDirective(attrName)) { var exp = attr.value; // 属性值 var dir = attrName.substring(2); // 指令 if (me.isEventDirective(dir)) { // 事件指令, 如 v-on:click compileUtil.eventHandler(node, me.$vm, exp, dir); } else { // 普通指令 compileUtil[dir] &amp;&amp; compileUtil[dir](node, me.$vm, exp); } } }); } }; // 指令处理集合 var compileUtil = { text: function(node, vm, exp) { this.bind(node, vm, exp, 'text'); }, // ... bind: function(node, vm, exp, dir) { var updaterFn = updater[dir + 'Updater']; // 第一次初始化视图 updaterFn &amp;&amp; updaterFn(node, vm[exp]); // 实例化订阅者，此操作会在对应的属性消息订阅器中添加了该订阅者watcher new Watcher(vm, exp, function(value, oldValue) { // 一旦属性值有变化，会收到通知执行此更新函数，更新视图 updaterFn &amp;&amp; updaterFn(node, value, oldValue); }); } }; // 更新函数 var updater = { textUpdater: function(node, value) { node.textContent = typeof value == 'undefined' ? '' : value; } // ... }; 这里递归编译节点树，指令的声明规定是通过特定前缀的节点属性来标记，如&lt;span v-text=&quot;content&quot; other-attr中v-text便是指令，而other-attr不是指令，只是普通的属性。监听数据、绑定更新函数的处理是在compileUtil.bind()这个方法中，通过new Watcher()添加回调来接收数据变化的通知 实现 Watcher Watcher 是 Observer 和 Compile 之间通信的桥梁，主要的工作有： 把自己添加到属性订阅器当中； 需要有update()方法； 属性变动时，调用自己的update()方法，出发Compile中绑定的回调。 function Watcher(vm, exp, callback) { this.cb = callback; this.vm = vm; this.exp = exp; // 此处为了触发属性的getter，从而在dep添加自己，结合Observer更易理解 this.value = this.get(); } Watcher.prototype = { update: function() { this.run(); // 属性值变化收到通知 }, run: function() { var value = this.get(); // 取到最新值 var oldVal = this.value; if (value !== oldVal) { this.value = value; this.cb.call(this.vm, value, oldVal); // 执行Compile中绑定的回调，更新视图 } }, get: function() { Dep.target = this; // 将当前订阅者指向自己 var value = this.vm[exp]; // 触发getter，添加自己到属性订阅器中 Dep.target = null; // 添加完毕，重置 return value; } }; // 这里再次列出Observer和Dep，方便理解 Object.defineProperty(data, key, { get: function() { // 由于需要在闭包内添加watcher，所以可以在Dep定义一个全局target属性，暂存watcher, 添加完移除 Dep.target &amp;&amp; dep.addDep(Dep.target); return val; } // ... 省略 }); Dep.prototype = { notify: function() { this.subs.forEach(function(sub) { sub.update(); // 调用订阅者的update方法，通知变化 }); } }; 实例化Watcher的时候，调用get()方法，通过Dep.target = watcherInstance标记订阅者是当前 watcher 实例，强行触发属性定义的getter方法，getter方法执行的时候，就会在属性的订阅器dep添加当前 watcher 实例，从而在属性值有变化的时候，watcherInstance 就能收到更新通知。 ok, Watcher 也已经实现了，完整代码。 基本上 vue 中数据绑定相关比较核心的几个模块也是这几个，猛戳这里, 在src 目录可找到 vue 源码。 最后来讲讲 MVVM 入口文件的相关逻辑和实现吧，相对就比较简单了~ 实现 MVVM MVVM 作为数据绑定的入口，整合 Observer、Compile 和 Watcher 三者，通过 Observer 来监听自己的 model 数据变化，通过 Compile 来解析编译模板指令，最终利用 Watcher 搭起 Observer 和 Compile 之间的通信桥梁，达到数据变化 -&gt; 视图更新；视图交互变化 (input) -&gt; 数据 model 变更的双向绑定效果。 一个简单的 MVVM 构造器是这样子： function MVVM(options) { this.$options = options; var data = this._data = this.$options.data; observe(data, this); this.$compile = new Compile(options.el || document.body, this) } 但是这里有个问题，从代码中可看出监听的数据对象是options.data，每次需要更新视图，则必须通过var vm = new MVVM({data:{name: 'foo'}}); vm._data.name = 'bar';这样的方式来改变数据。 显然不符合我们一开始的期望，我们所期望的调用方式应该是这样的： var vm = new MVVM({data: {name: 'foo'}}); vm.name = 'bar'; 所以这里需要给 MVVM 实例添加一个属性代理的方法，使访问vm的属性代理为访问vm._data的属性，改造后的代码如下： function MVVM(options) { this.$options = options; var data = this._data = this.$options.data, me = this; // 属性代理，实现 vm.xxx -&gt; vm._data.xxx Object.keys(data).forEach(function(key) { me._proxy(key); }); observe(data, this); this.$compile = new Compile(options.el || document.body, this) } MVVM.prototype = { _proxy: function(key) { var me = this; Object.defineProperty(me, key, { configurable: false, enumerable: true, get: function proxyGetter() { return me._data[key]; }, set: function proxySetter(newVal) { me._data[key] = newVal; } }); } }; 这里主要还是利用了Object.defineProperty()这个方法来劫持了vm实例对象的属性的读写权，使读写vm实例的属性转成读写了vm._data的属性值。 这里有一个在线的示例：双向绑定实现---无漏洞版 by Iwobi (@xiaomuzhu) on CodePen. 细节与弊端 Vue.js 2.0 的数据劫持是通过使用Object.defineProperty并辅以发布订阅模式，实现了双向绑定核心与业务代码之间的解耦合。 但是有一些缺陷，首先第一个缺陷：无法监听数组变化。Vue 文档里也提到，Vue 是可以检测数组变化的，但是只支持push、pop、shift、unshift、splice、sort、reverse八种方法。 并且，我们在上面的代码中，多次遍历方法遍历对象的属性，这就引出了第二个缺陷：只能劫持对象的属性。所以要对对象的属性进行递归深度遍历。显然劫持一个完整的对象会是更好的选择。 Proxy 实现双向绑定 在 ES2015 中规范中正式发布了 Proxy，它可以在目标对象之外添加一层拦截，外界对这个对象的访问都需要通过拦截层。我们可以认为 Proxy 是更好的Object.defineProperty。 直接监听对象而非属性 我们还是以上文中用Object.defineProperty实现的极简版双向绑定为例,用Proxy进行改写。 const input = document.getElementById('input'); const p = document.getElementById('p'); const obj = {}; const newObj = new Proxy(obj, { get: function(target, key, receiver) { console.log(`getting ${key}!`); return Reflect.get(target, key, receiver); }, set: function(target, key, value, receiver) { console.log(target, key, value, receiver); if (key === 'text') { input.value = value; p.innerHTML = value; } return Reflect.set(target, key, value, receiver); }, }); input.addEventListener('keyup', function(e) { newObj.text = e.target.value; }); 在线示例 Proxy版 by Iwobi (@xiaomuzhu) on CodePen. 我们可以看到,Proxy直接可以劫持整个对象,并返回一个新对象,不管是操作便利程度还是底层功能上都远强于Object.defineProperty。 监听数组的变化 当我们对数组进行操作(push、shift、splice等)时，会触发对应的方法名称和length的变化，我们可以借此进行操作,以上文中Object.defineProperty无法生效的列表渲染为例。 const list = document.getElementById('list'); const btn = document.getElementById('btn'); // 渲染列表 const Render = { // 初始化 init: function(arr) { const fragment = document.createDocumentFragment(); for (let i = 0; i &lt; arr.length; i++) { const li = document.createElement('li'); li.textContent = arr[i]; fragment.appendChild(li); } list.appendChild(fragment); }, // 我们只考虑了增加的情况,仅作为示例 change: function(val) { const li = document.createElement('li'); li.textContent = val; list.appendChild(li); }, }; // 初始数组 const arr = [1, 2, 3, 4]; // 监听数组 const newArr = new Proxy(arr, { get: function(target, key, receiver) { console.log(key); return Reflect.get(target, key, receiver); }, set: function(target, key, value, receiver) { console.log(target, key, value, receiver); if (key !== 'length') { Render.change(value); } return Reflect.set(target, key, value, receiver); }, }); // 初始化 window.onload = function() { Render.init(arr); } // push数字 btn.addEventListener('click', function() { newArr.push(6); }); 在线示例 Proxy列表渲染 by Iwobi (@xiaomuzhu) on CodePen. 很显然，Proxy不需要那么多hack（即使hack也无法完美实现监听）就可以无压力监听数组的变化,我们都知道,标准永远优先于hack。 其他优势 Proxy有多达13种拦截方法,不限于apply、ownKeys、deleteProperty、has等等是Object.defineProperty不具备的。 Proxy返回的是一个新对象,我们可以只操作新的对象达到目的,而Object.defineProperty只能遍历对象属性直接修改。 Proxy作为新标准将受到浏览器厂商重点持续的性能优化，也就是传说中的新标准的性能红利。 当然,Proxy 的劣势就是兼容性问题,而且无法用polyfill磨平,因此 Vue 的作者才声明需要等到下个大版本（3.0）才能用Proxy重写。 参考资料 面试官系列(4): 实现双向绑定Proxy比defineproperty优劣如何? 剖析Vue实现原理 - 如何实现双向绑定mvvm ","link":"https://wzhzzmzzy.github.io/post/2019-5-25-Vue双向绑定"},{"title":"浏览器工作原理","content":" How Browsers Work 浏览器的高层结构 浏览器的主要构件有： UI —— 地址栏、前后按钮、书签栏等。 浏览器引擎 —— 控制渲染引擎的接口。 渲染引擎 —— 负责显示请求到的内容。例如请求到的内容是 HTML，那么渲染引擎就需要负责解析 HTML 和CSS，并且在屏幕上显示解析到的内容。 网络 —— 用于发起 HTTP 请求。 UI 后端 —— 使用操作系统底层 API 渲染 UI。 JS 解释器 —— 用于解析并运行 JavaScript 代码。 数据存储 —— 持久化层，用于将所有的数据存储在硬盘上，例如 Cookies。 顺便提一下，Chrome的渲染引擎策略与其他主流浏览器不同，每一个标签页都有一个独立的渲染引擎实例。 渲染引擎 这里，我们只提及用于显示 HTML 和图片，以及 CSS的渲染引擎。 渲染引擎类型 Firefox 使用 Mozilla 自研的 Gecko，Safari 和 Chrome 使用 Webkit。Webkit是一个开源的渲染引擎，最初是用于 Linux，后被 Apple 修改用于支持 Mac 和 Windows。 核心工作流 渲染引擎从网络层获取到请求得到的文档，一般文档以 8K 大小的块组成。 渲染引擎从 HTML 中解析出 DOM 元素，组织为 Content Tree，然后从 HTML 标签样式以及 CSS 中解析出样式信息，最终组成 Render Tree。 Render Tree 由许多可视矩形组成，这些矩形有着颜色、尺寸的属性。这些矩形会以正确的顺序显示在屏幕上。 Render Tree 构建完成之后，就可以开始布局。也就是给每一个节点一个特定的坐标，以便于它能够在屏幕上显示。下一步是绘图，UI 后端会将Render Tree的每一个节点渲染出来。 为了用户体验考虑，整个流程是一个渐进的过程，也就是说，渲染引擎不会等待整个 HTML 文档被解析完成，而是解析一部分渲染一部分，然后继续处理文档剩余的部分，或是等待网络加载。 以下是 Webkit 和 Gecko 的工作流程： 从上面两张图可以看出，除了术语之外，基本流程都大致相同。 通用解析原理 一般而言，从代码文档到解析树，需要经历语法分析和词法分析。词法分析会辨识出哪些是有效的代码，哪些是无效的。 整个解析过程是迭代进行的，解析器通常会与词法分析器协同工作，辨识语法和标识符，进行匹配。如果匹配成功，解析树上就会多出一个与标识符相关的节点，然后进行下一个标识符的解析。如果匹配失败，解析器会在内部保存这个标识符，然后不停地询问词法分析器，直到完全匹配。如果无法匹配，那么就会报错。 解析树也不是最终产物，需要转化为机器码才可以被执行。一个常见的例子就是编译。编译器将源代码编译为机器码文档。 ","link":"https://wzhzzmzzy.github.io/post/2019-5-24-How-Browsers-Work"},{"title":"TypeScript 基础语法","content":"基础类型 TS 支持与 JS 几乎完全相同的基本数据类型，还添加了枚举类型。 布尔值（boolean） 数字（number） 字符串（string） 数组（number[]、Array&lt;number&gt;） 元组（[string, number]） 枚举：默认情况下，从0开始为元素编号。 你也可以手动的指定成员的数值。 enum Color {Red, Green, Blue} enum Color {Red = 1, Green = 2, Blue = 4} Any（any） Void（void) Null 和 Undefined（null / undefined） Never（never）：表示永不存在值的类型 Object（object）：非原始类型 类型断言 可以在编码时给代码动态添加类型，可以看做是类型转换。类型断言语法有两种，但是在 JSX 中只有 as 是被允许的。 let s: any = &quot;test string&quot;; let s_len: number = (&lt;string&gt;s).length; let s_len2: number = (s as string).length; 变量声明 var 过去 JavaScript 中最常见的变量声明符号。他的特点在于作用域：var声明可以在包含它的函数，模块，命名空间或全局作用域内部任何位置被访问。 还有一点会导致一些难以被发现的错误：变量被重复声明不会报错。 let 为了解决var所存在的问题，ES6 提出了let关键字。let的不同之处在于，它的作用域是块作用域，也称为此法作用域。并且，let变量重定义是不允许的， let还有一个特性是屏蔽，即在内部块作用域内可以声明同名变量，不会影响到外部变量。 const const关键字用于声明常量，不能被修改。 解构 ES6中添加的解构赋值在 TypeScript 中也可以使用： // 数组解构 let input = [1, 2]; let [first, second] = input; [second, first] = [first, second]; function foo([first, second]: [number, number]) { } foo(input); let [a] = [1, 2] // a === 1 let [, b, , c] = [1, 2, 3, 4] // b === 2 &amp;&amp; c == 4 // 对象解构 let o = {a: &quot;foo&quot;, b: &quot;bar&quot;}; let { c, d } = o; ({ d, e } = {a: &quot;foo&quot;, b: &quot;bar&quot;}); let {f, ...g} = o; 属性重命名 这是一个混乱的语法，不太建议去使用。 let { a: newName1, b: newName2 }= o; let {a, b}: {a: string, b: number} = o; 默认值 当属性为undefine时给予默认值。函数参数默认值使用也是如此。 function foo(o: { a: string, b?: number }) { let { a, b = 1001 } = o; } 函数声明 解构当然也可以用于函数声明。当存在深层嵌套解构的时候，就算这时没有堆叠在一起的重命名，默认值和类型注解，也是令人难以理解的。 type C = { a: string, b?: number } function f1({ a, b }: C): void { } function f2({ a=&quot;&quot;, b=0 } = {}): void { } f(); 展开 展开操作符正与解构相反。 它允许你将一个数组展开为另一个数组，或将一个对象展开为另一个对象。 let first = [1, 2]; let second = [3, 4]; let bothPlus = [0, ...first, ...second, 5]; let defaults = { food: &quot;spicy&quot;, price: &quot;$$&quot;, ambiance: &quot;noisy&quot; }; let search = { ...defaults, food: &quot;rich&quot; }; 注意，展开时后面的属性会覆盖前面的属性。另外，展开时对象本身的方法会丢失。 接口 TypeScript 的核心原则之一是Duck Typing。也就是，编译器检查类型时，并不会严格地给变量打上一个“实现了这个接口”的标记，而是判断他的是否具备了接口的所有要求，如果具备了，那就可以算是该接口的类型。 interface LabelledValue { label: string; } function printLabel(labelledObj: LabelledValue) { console.log(labelledObj.label); } let myObj = {size: 10, label: &quot;Size 10 Object&quot;}; printLabel(myObj); 可选属性 声明接口时可以声明可选属性，只需要带一个?即可。 interface SquareConfig { color?: string; width?: number; } 只读属性 可以给对象创建只读属性。 interface Point { readonly x: number; readonly y: number; } TypeScript 添加了 ReadonlyArray&lt;T&gt;，与Array&lt;T&gt;相似，只是把所有的可变方法都去掉了，因此可以确保数组创建后再也不能被修改。ReadonlyArray不可以被整个赋值为一个普通数组，但是可以用类型断言重写。 额外的属性检查 在使用接口时，有时会出现一些问题，比如将可选属性与接收接口指定类型的函数结合，你可能认为传入一个包含其他属性的对象也没问题，但是事实上，这是无法成功的。 interface SquareConfig { color?: string; width?: number; } function createSquare(config: SquareConfig): { color: string; area: number } { // ... } // error: 'colour' not expected in type 'SquareConfig' let mySquare = createSquare({ colour: &quot;red&quot;, width: 100 }); // 这样可以绕开检查 let mySquare = createSquare({ width: 100, opacity: 0.5 } as SquareConfig); // 最好的方法是给接口添加一个字符串索引签名 interface SquareConfig { color?: string; width?: number; [propName: string]: any; } 函数类型 函数当然也具有类型，也可以在接口声明，以下是一个函数接口的声明： interface SearchFunc { (source: string, subString: string): boolean; } // 对于函数，不会检查其中形参的名称是否符合声明，只要求对应位置上的参数类型是兼容的 let mySearch: SearchFunc = function(src: string, subStr: string) { let result = source.search(subString); return result &gt; -1; } 可索引的类型 与使用接口描述函数类型差不多，我们也可以描述那些能够“通过索引得到”的类型，比如a[10]或ageMap[&quot;daniel&quot;]。 可索引类型具有一个索引签名，它描述了对象索引的类型，还有相应的索引返回值类型。 interface StringArray { [index: number]: string; } let myArray: StringArray; myArray = [&quot;Bob&quot;, &quot;Fred&quot;]; let myStr: string = myArray[0]; 这里有个需要注意的地方：TypeScript 支持字符串和数字索引。可以同时使用两种类型，但是数字索引必须是字符串索引返回值的子类型。这是因为当使用 number来索引时，JavaScript会将它转换成string然后再去索引对象。 也就是说用 100（一个number）去索引等同于使用&quot;100&quot;（一个string）去索引，因此两者需要保持一致。 类类型 实现接口 与C#或Java里接口的基本作用一样。 interface ClockInterface { currentTime: Date; setTime(d: Date); } class Clock implements ClockInterface { currentTime: Date; setTime(d: Date) { this.currentTime = d; } constructor(h: number, m: number) { } } 接口描述了类的公共部分，而不是公共和私有两部分。 它不会帮你检查类是否具有某些私有成员。 当我们想要用接口去描述一个类的构造函数的时候，我们可以将类描述为一个只包含构造函数的接口： interface ClockConstructor { new (hour: number, minute: number): ClockInterface; } interface ClockInterface { tick(); } function createClock(ctor: ClockConstructor, hour: number, minute: number): ClockInterface { return new ctor(hour, minute); } class DigitalClock implements ClockInterface { constructor(h: number, m: number) { } tick() { console.log(&quot;beep beep&quot;); } } 继承接口 和类一样，接口也可以相互继承。一个接口可以继承多个接口，创建出多个接口的合成接口。 混合类型 当需要描述混合类型的时候，接口也是可以胜任的。 interface Counter { (start: number): string; interval: number; reset(): void; } 接口继承类 当接口继承了一个类类型时，它会继承类的成员但不包括其实现。 类 类 下面看一个使用类的例子。 class Greeter { greeting: string; constructor(message: string) { this.greeting = message; } greet() { return &quot;Hello, &quot; + this.greeting; } } let greeter = new Greeter(&quot;world&quot;); 继承 在构造函数里访问 this的属性之前，我们 一定要调用 super()。 这个是TypeScript强制执行的一条重要规则。 class Animal { name: string; constructor(theName: string) { this.name = theName; } move(distanceInMeters: number = 0) { console.log(`${this.name} moved ${distanceInMeters}m.`); } } class Snake extends Animal { constructor(name: string) { super(name); } move(distanceInMeters = 5) { console.log(&quot;Slithering...&quot;); super.move(distanceInMeters); } } class Horse extends Animal { constructor(name: string) { super(name); } move(distanceInMeters = 45) { console.log(&quot;Galloping...&quot;); super.move(distanceInMeters); } } 公共、私有、受保护、只读 默认为public，当然也可以明确标记；标记为private时，不可以在类外部访问；protected可以在派生类内访问。 属性还可以多一个readonly修饰符，必须有默认值或者在构造函数里赋值。 存取器 TypeScript 中当然有getter/setters。 let passcode = &quot;secret passcode&quot;; class Employee { private _fullName: string; get fullName(): string { return this._fullName; } set fullName(newName: string) { if (passcode &amp;&amp; passcode == &quot;secret passcode&quot;) { this._fullName = newName; } else { console.log(&quot;Error: Unauthorized update of employee!&quot;); } } } 静态属性 访问静态属性前面要加类名。 class Grid { static origin = {x: 0, y: 0}; calculateDistanceFromOrigin(point: {x: number; y: number;}) { let xDist = (point.x - Grid.origin.x); let yDist = (point.y - Grid.origin.y); return Math.sqrt(xDist * xDist + yDist * yDist) / this.scale; } constructor (public scale: number) { } } 抽象类 抽象类不可以被实例化。 abstract class Animal { abstract makeSound(): void; move(): void { console.log('roaming the earch...'); } } 构造函数的本质 在声明一个类的时候，事实上是声明了一个构造函数： class Greeter { greeting: string; constructor(message: string) { this.greeting = message; } greet() { return &quot;Hello, &quot; + this.greeting; } } let greeter: Greeter; greeter = new Greeter(&quot;world&quot;); console.log(greeter.greet()); // 编译后的 JavaScript let Greeter = (function () { function Greeter(message) { this.greeting = message; } Greeter.prototype.greet = function () { return &quot;Hello, &quot; + this.greeting; }; return Greeter; })(); let greeter; greeter = new Greeter(&quot;world&quot;); console.log(greeter.greet()); 把类当做接口使用 你可以在任何使用接口的地方使用类。 函数 在 TypeScript 中可以使用命名函数和匿名函数。函数可以使用函数外定义的变量。 函数类型 函数类型包含两部分：参数类型和返回值类型。 当写出完整函数类型的时候，这两部分都是需要的。只要参数类型是匹配的，那么就认为它是有效的函数类型，而不在乎参数名是否正确。 let myAdd: (x: number, y: number) =&gt; number = function(x: number, y: number): number { return x + y; }; 可选参数和默认参数 TypeScript里的每个函数参数都是必须的。，但是你可以传入null或者undefined。可选参数是指可以在参数名旁边添加?。默认值可以在无默认值的参数之前，如果要这样的话，就需要使用传入undefined来获取参数的默认值。 剩余参数 在TypeScript里，你可以把所有参数收集到一个变量里： function buildName(firstName: string, ...restOfName: string[]) { return firstName + &quot; &quot; + restOfName.join(&quot; &quot;); } let employeeName = buildName(&quot;Joseph&quot;, &quot;Samuel&quot;, &quot;Lucas&quot;, &quot;MacKinzie&quot;); this 如果你想了解JavaScript里的 this是如何工作的，那么首先阅读Yehuda Katz写的Understanding JavaScript Function Invocation and &quot;this&quot;。TypeScript能通知你错误地使用了this的地方。 JavaScript里，this的值在函数被调用的时候才会指定。为了解决这个问题，我们可以在函数被返回时就绑好正确的this。箭头函数能保存函数创建时的 this值，而不是调用时的值。 let deck = { suits: [&quot;hearts&quot;, &quot;spades&quot;, &quot;clubs&quot;, &quot;diamonds&quot;], cards: Array(52), createCardPicker: function() { // NOTE: the line below is now an arrow function, allowing us to capture 'this' right here return () =&gt; { let pickedCard = Math.floor(Math.random() * 52); let pickedSuit = Math.floor(pickedCard / 13); return {suit: this.suits[pickedSuit], card: pickedCard % 13}; } } } let cardPicker = deck.createCardPicker(); let pickedCard = cardPicker(); alert(&quot;card: &quot; + pickedCard.card + &quot; of &quot; + pickedCard.suit); 更好事情是，TypeScript会警告你犯了一个错误，如果你给编译器设置了--noImplicitThis标记。 它会指出this.suits[pickedSuit]里的this的类型为any。这是因为 this来自对象字面量里的函数表达式。 修改的方法是，提供一个显式的 this参数。 this参数是个假的参数，它出现在参数列表的最前面： this: void means that addClickListener expects f to be a function that does not require a this type. function f(this: void) { // make sure `this` is unusable in this standalone function } 我们往例子里加一些接口，代码就会变得更加清晰： interface Card { suit: string; card: number; } interface Deck { suits: string[]; cards: number[]; createCardPicker(this: Deck): () =&gt; Card; } let deck: Deck = { suits: [&quot;hearts&quot;, &quot;spades&quot;, &quot;clubs&quot;, &quot;diamonds&quot;], cards: Array(52), // NOTE: The function now explicitly specifies that its callee must be of type Deck createCardPicker: function(this: Deck) { return () =&gt; { let pickedCard = Math.floor(Math.random() * 52); let pickedSuit = Math.floor(pickedCard / 13); return {suit: this.suits[pickedSuit], card: pickedCard % 13}; } } } let cardPicker = deck.createCardPicker(); let pickedCard = cardPicker(); alert(&quot;card: &quot; + pickedCard.card + &quot; of &quot; + pickedCard.suit); 现在TypeScript知道createCardPicker期望在某个Deck对象上调用。 也就是说 this是Deck类型的，而非any，因此--noImplicitThis不会报错了。 如果你想要把一个函数作为参数传入一个库函数，而库函数所定义的函数类型中有this: void，那么意味着你需要修复你函数中this的类型，否则会报错。或者你可以直接传入一个箭头函数。 函数重载 TypeScript使用严格函数定义的另一个好处是可以使用函数重载。为了让编译器能够选择正确的检查类型，它与JavaScript里的处理流程相似。 它查找重载列表，尝试使用第一个重载定义。 如果匹配的话就使用这个。 因此，在定义重载的时候，一定要把最精确的定义放在最前面。 泛型 TypeScript的泛型和其他语言的泛型非常相似。使用泛型的好处是不会像使用any一样丢失类型信息。 function identity&lt;T&gt;(arg: T): T { return arg; } 泛型函数的类型 interface GenericIdentityFn { &lt;T&gt;(arg: T): T; } 泛型类 我们在类那节说过，类有两部分：静态部分和实例部分。 泛型类指的是实例部分的类型，所以类的静态属性不能使用这个泛型类型。 class GenericNumber&lt;T&gt; { zeroValue: T; add: (x: T, y: T) =&gt; T; } 泛型约束 由于泛型本身没有任何类型，所以这就弱化了编译器的功能。编译器会十分严格地要求泛型，所以我们无法调用泛型上的方法。我们可以给泛型添加约束来让泛型可以被更好地使用。 function loggingIdentity&lt;T extends Lengthwise&gt;(arg: T): T { console.log(arg.length); // Now we know it has a .length property, so no more error return arg; } 在泛型约束中使用类型参数 你可以声明一个类型参数，且它被另一个类型参数所约束。 比如，现在我们想要用属性名从对象里获取这个属性。 并且我们想要确保这个属性存在于对象 obj上，因此我们需要在这两个类型之间使用约束。 function getProperty(obj: T, key: K) { return obj[key]; } let x = { a: 1, b: 2, c: 3, d: 4 }; getProperty(x, &quot;a&quot;); // okay getProperty(x, &quot;m&quot;); // error: Argument of type 'm' isn't assignable to 'a' | 'b' | 'c' | 'd'. 在泛型里使用类类型 在TypeScript使用泛型创建工厂函数时，需要引用构造函数的类类型。比如， function create&lt;T&gt;(c: {new(): T; }): T { return new c(); } 一个更高级的例子，使用原型属性推断并约束构造函数与类实例的关系。 class BeeKeeper { hasMask: boolean; } class ZooKeeper { nametag: string; } class Animal { numLegs: number; } class Bee extends Animal { keeper: BeeKeeper; } class Lion extends Animal { keeper: ZooKeeper; } function createInstance&lt;A extends Animal&gt;(c: new () =&gt; A): A { return new c(); } createInstance(Lion).keeper.nametag; // typechecks! createInstance(Bee).keeper.hasMask; // typechecks! Symbol 自ECMAScript 2015起，symbol成为了一种新的原生类型，就像number和string一样。 symbol类型的值是通过Symbol构造函数创建的。 let sym1 = Symbol(); let sym2 = Symbol(&quot;key&quot;); // 可选的字符串key Symbols是不可改变且唯一的。 let sym2 = Symbol(&quot;key&quot;); let sym3 = Symbol(&quot;key&quot;); sym2 === sym3; // false, symbols是唯一的 像字符串一样，symbols也可以被用做对象属性的键。 let sym = Symbol(); let obj = { [sym]: &quot;value&quot; }; console.log(obj[sym]); // &quot;value&quot; Symbols也可以与计算出的属性名声明相结合来声明对象的属性和类成员。 const getClassNameSymbol = Symbol(); class C { [getClassNameSymbol](){ return &quot;C&quot;; } } let c = new C(); let className = c[getClassNameSymbol](); // &quot;C&quot; ","link":"https://wzhzzmzzy.github.io/post/2019-5-16-TypeScript基础"},{"title":"魔盒挑战第二期判题系统制作日志","content":" Github Repo： 题面 - Flask 前端页面 - VueElementAdmin 后端 - Tornado 遇到的坑 Python HTTP Service 异步 由于 eForm-Auth 在处理一个请求时会同步阻塞，并等待远端服务器的响应，直观的表现就是占用了过多的 Worker，无法处理之后过来的请求。因此，使用经典的同步 HTTP 框架，例如 Flask，就会让之后的请求超时。 之后我们选用了 tornado 的 AsyncHTTPClient 处理这个问题，也就导致了下面这个问题的发生。 Tornado Async Fetch 的缺陷 由于 eForm-Auth 是通过向学校的统一认证服务器发送 HTTP 模拟请求进行用户登录的，所以我们需要使用 tornado AsyncHTTPClient Fetch 对这个环节进行异步处理。由于对服务器发送请求会发生两次连续的需要通过 Cookie 鉴权的重定向，而 tornado Fetch 没有对重定向保持 Credential，而之前，当我们使用 Python 发送 HTTP 请求最主流的requests包对学校的统一认证服务进行访问时，则和浏览器会有相同的表现。 解决方法：手动处理 tornado Redirect async def post(self): ... http_client = AsyncHTTPClient() try: response = await http_client.fetch(url, method=&quot;POST&quot;, headers=headers, body=urlencode({&quot;IDToken1&quot;: id_tag, &quot;IDToken2&quot;: token}), follow_redirects=False ) except HTTPClientError as e: cookie = next(filter(lambda s: s.startswith( 'iPlanetDirectoryPro'), e.response.headers.get_list('Set-Cookie')) ) request = HTTPRequest( url=&quot;...&quot;, method='GET', headers={ &quot;Cookie&quot;: cookie, }, ) response = await http_client.fetch(request) res = json.loads(response.body).get('data') ... self.finish() else: self.set_status(status_code=400) ... self.finish() Github Personal Authorization Key 与 Gitee 私人令牌使用差异 当在 Azure Pipeline 中使用 Git 进行操作时，不可避免会需要使用 Github 或 Gitee 的 OpenAPI。这两者的私人令牌使用有差异，以git push为例： # Github PAT git push -f &quot;https://$(github-pat)@github.com/&lt;USER&gt;/&lt;REPO&gt;.git&quot; # Gitee 私人令牌 git push -f &quot;https://$(gitee-username):$(gitee-pat)@github.com/&lt;USER&gt;/&lt;REPO&gt;.git&quot; SQLite3 的奇妙错误（待解决） 我们需要一个查询所有用户的成绩单的接口：GET /inspect。 @app.route('/inspect', methods=['POST', 'GET']) def inspect(): if request.method == 'GET': db = get_db() try: test_grade = db.execute( ''' SELECT * FROM ( SELECT user.id_tag, user.username, test.test_status, test.test_grade FROM main.test, main.user WHERE test.user_id = user.id ORDER BY test_grade ASC ) GROUP BY id_tag ''').fetchall() return jsonify(list(map( lambda item: dict(zip(item.keys(), tuple(item))), test_grade))) except Exception as e: tb = sys.exc_info()[2] logging.error(e, exc_info=True) return jsonify({&quot;error&quot;: str(e.with_traceback(tb))}) if request.method == 'POST': ... 这里的问题发生在 SQL 语句里，我们在 PyCharm 中使用其 DATABASE 功能进行测试时，使用ORDER BY ... DESC可以查询到用户的历史最好成绩，但是使用 Python3 sqlite3 包时，表现截然相反：ORDER BY ... DESC获取的结果是用户的最坏成绩，使用ORDER BY ... ASC则能获得最好成绩。我们猜测是 Python3 的 sqlite3 实现问题。 ","link":"https://wzhzzmzzy.github.io/post/2019-5-20-Pandora-2nd-记录"},{"title":"TypeScript 类型系统","content":"类型推论 TypeScript中的类型是在哪里、如何被推断的呢？理解这个有助于我们在编写代码时更好地预测编译器的行为，避免一些难以被发现的Bug的出现。 简单例子 没有明确指出类型的地方，类型推论会帮助提供类型： let x = 3; // x: Int 这种推断发生在初始化变量和成员，设置默认参数值和决定函数返回值时。大多数情况下，类型推论是直截了当地。后面我们来看一些细微的差别。 最佳通用类型 我们很多时候会写出类型有些难以推断的混合表达式，最简单的例子就是同时包含的不同类型的元素的列表： let x = [0, 1, null]; 由于需要推断x的类型，编译器会检查列表中所有元素的类型，然后选择能覆盖所有类型的选项。没有找到最佳通用类型的情况下，类型推断的结果是联合数组类型。 上下文类型 TypeScript类型推论也可能按照相反的方向进行。 这被叫做“按上下文归类”。按上下文归类会发生在表达式的类型与所处的位置相关时。比如： window.onmousedown = function(mouseEvent) { console.log(mouseEvent.button); //&lt;- Error }; 这里，编译器会抛出一个类型错误。TypeScript 通过window.onmousedown来判断了mouseEvent的类型。你可以手动指定mouseEvent: Any，这样就不会报错了。 window.onmousedown = function(mouseEvent: any) { console.log(mouseEvent.button); //&lt;- Now, no error is given }; 这个函数表达式有明确的参数类型注解，上下文类型被忽略。 这样的话就不报错了，因为这里不会使用到上下文类型。 类型兼容性 TypeScript 的类型兼容是基于结构中的子类型的，而不是基于类型名义的。也就是说，只要结构子类型相同或包含，就可以使用。TypeScript的结构性子类型是根据JavaScript代码的典型写法来设计的。 因为JavaScript里广泛地使用匿名对象，例如函数表达式和对象字面量，所以使用结构类型系统来描述这些类型比使用名义类型系统更好。 interface Named { name: string; } class Person { name: string; } let p: Named; // OK, because of structural typing p = new Person(); 关于可靠性的注意事项 TypeScript的类型系统允许某些在编译阶段无法确认其安全性的操作。下面会解释何时会发生这种情况，以及它有利的一面。 开始 TypeScript 结构化类型系统的基本规则是，如果x要兼容y，那么y至少具有与x相同的属性。 interface Named { name: string; } let x: Named; // y's inferred type is { name: string; location: string; } let y = { name: 'Alice', location: 'Seattle' }; x = y; 这里要检查y是否能赋值给x，编译器检查x中的每个属性，看是否能在y中也找到对应属性。 在这个例子中，y必须包含名字是name的string类型成员。y满足条件，因此赋值正确。检查函数参数时也会使用相同的规则。 这个比较过程是递归进行的，检查每个成员及子成员。 比较两个函数 相对来讲，在比较原始类型和对象类型的时候是比较容易理解的，问题是如何判断两个函数是兼容的。 下面我们从两个简单的函数入手，它们仅是参数列表略有不同： let x = (a: number) =&gt; 0; let y = (b: number, s: string) =&gt; 0; y = x; // OK x = y; // Error 要查看x是否能赋值给y，首先看它们的参数列表。 x的每个参数必须能在y里找到对应类型的参数。 注意的是参数的名字相同与否无所谓，只看它们的类型。 这里，x的每个参数在y中都能找到对应的参数，所以允许赋值。 第二个赋值错误，因为y有个必需的第二个参数，但是x并没有，所以不允许赋值。 你可能会疑惑为什么允许忽略参数，像例子y = x中那样。 原因是忽略额外的参数在JavaScript里是很常见的。 例如，Array#forEach给回调函数传3个参数：数组元素，索引和整个数组。 尽管如此，传入一个只使用第一个参数的回调函数也是很有用的： let items = [1, 2, 3]; // Don't force these extra arguments items.forEach((item, index, array) =&gt; console.log(item)); // Should be OK! items.forEach((item) =&gt; console.log(item)); 下面来看看如何处理返回值类型，创建两个仅是返回值类型不同的函数： let x = () =&gt; ({name: 'Alice'}); let y = () =&gt; ({name: 'Alice', location: 'Seattle'}); x = y; // OK y = x; // Error, because x() lacks a location property 类型系统强制源函数的返回值类型必须是目标函数返回值类型的子类型。 函数参数双向协变 当比较函数参数类型时，只有当源函数参数能够赋值给目标函数或者反过来时才能赋值成功。 这是不稳定的，因为调用者可能传入了一个具有更精确类型信息的函数，但是调用这个传入的函数的时候却使用了不是那么精确的类型信息。 实际上，这极少会发生错误，并且能够实现很多JavaScript里的常见模式。 可选参数及剩余参数 比较函数兼容性的时候，可选参数与必须参数是可互换的。 源类型上有额外的可选参数不是错误，目标类型的可选参数在源类型里没有对应的参数也不是错误。 当一个函数有剩余参数时，它被当做无限个可选参数。 这对于类型系统来说是不稳定的，但从运行时的角度来看，可选参数一般来说是不强制的，因为对于大多数函数来说相当于传递了一些undefinded。 有一个好的例子，常见的函数接收一个回调函数并用对于程序员来说是可预知的参数但对类型系统来说是不确定的参数来调用： function invokeLater(args: any[], callback: (...args: any[]) =&gt; void) { /* ... Invoke callback with 'args' ... */ } // Unsound - invokeLater &quot;might&quot; provide any number of arguments invokeLater([1, 2], (x, y) =&gt; console.log(x + ', ' + y)); // Confusing (x and y are actually required) and undiscoverable invokeLater([1, 2], (x?, y?) =&gt; console.log(x + ', ' + y)); 函数重载 对于有重载的函数，源函数的每个重载都要在目标函数上找到对应的函数签名。 这确保了目标函数可以在所有源函数可调用的地方调用。 枚举 不同类型的枚举不兼容。枚举类型与数字类型兼容。 类 类与对象字面量和接口差不多，但有一点不同：类有静态部分和实例部分的类型。比较两个类类型的对象时，只有实例的成员会被比较。 静态成员和构造函数不在比较的范围内。 类的私有成员和受保护成员 类的私有成员和受保护成员会影响兼容性。 当检查类实例的兼容时，如果目标类型包含一个私有成员，那么源类型必须包含来自同一个类的这个私有成员。 同样地，这条规则也适用于包含受保护成员实例的类型检查。 这允许子类赋值给父类，但是不能赋值给其它有同样类型的类。 泛型 因为TypeScript是结构性的类型系统，类型参数只影响使用其做为类型一部分的结果类型。比如， interface Empty&lt;T&gt; { } let x: Empty&lt;number&gt;; let y: Empty&lt;string&gt;; x = y; // OK, because y matches structure of x 上面代码里，x和y是兼容的，因为它们的结构使用类型参数时并没有什么不同。 把这个例子改变一下，增加一个成员，就能看出是如何工作的了： interface NotEmpty&lt;T&gt; { data: T; } let x: NotEmpty&lt;number&gt;; let y: NotEmpty&lt;string&gt;; x = y; // Error, because x and y are not compatible 在这里，泛型类型在使用时就好比不是一个泛型类型。 对于没指定泛型类型的泛型参数时，会把所有泛型参数当成any比较。 然后用结果类型进行比较，就像上面第一个例子。 高级类型 交叉类型（Intersection Types） 交叉类型是将多个类型合并为一个类型。 例如， Person &amp; Serializable &amp; Loggable同时是 Person 和Serializable 和 Loggable。 就是说这个类型的对象同时拥有了这三种类型的成员。我们大多是在混入（mixins）或其它不适合典型面向对象模型的地方看到交叉类型的使用。 联合类型（Union Types） 联合类型与交叉类型很有关联，但是使用上却完全不同。联合类型表示一个值可以是几种类型之一。 我们用竖线（ |）分隔每个类型，所以 number | string | boolean表示一个值可以是 number， string，或 boolean。 如果一个值是联合类型，我们只能访问此联合类型的所有类型里共有的成员。 interface Bird { fly(); layEggs(); } interface Fish { swim(); layEggs(); } function getSmallPet(): Fish | Bird { // ... } let pet = getSmallPet(); pet.layEggs(); // okay pet.swim(); // errors 这里的联合类型可能有点复杂，但是你很容易就习惯了。 如果一个值的类型是 A | B，我们能够 确定的是它包含了 A 和 B中共有的成员。 这个例子里， Bird具有一个 fly成员。 我们不能确定一个Bird | Fish类型的变量是否有 fly方法。 如果变量在运行时是 Fish类型，那么调用pet.fly()就出错了。 类型保护与区分类型（Type Guards and Differentiating Types） 联合类型适合于那些值可以为不同类型的情况。但当我们想确切地了解是否为 Fish时怎么办？ 使用类型断言： let pet = getSmallPet(); if ((&lt;Fish&gt;pet).swim) { (&lt;Fish&gt;pet).swim(); } else { (&lt;Bird&gt;pet).fly(); } 用户自定义的类型保护 我们不得不多次使用类型断言去判断类型。如果我们只需要检查一次，在两个分支中都能知道类型就好了。这里可以使用类型保护机制： function isFish(pet: Fish | Bird): pet is Fish { return (&lt;Fish&gt;pet).swim !== undefined; } if (isFish(pet)) { pet.swim(); } else { pet.fly(); } 每当使用一些变量调用 isFish时，TypeScript会将变量缩减为那个具体的类型，只要这个类型与变量的原始类型是兼容的。注意TypeScript不仅知道在 if分支里 pet是 Fish类型； 它还清楚在 else分支里，一定 不是Fish类型，一定是 Bird类型。 typeof与instanceof类型保护 这两个关键字 JavaScript 中常用的判断类型的关键字，在使用联合类型与类型保护时也有用途。 // typeof function padLeft(value: string, padding: string | number) { if (typeof padding === &quot;number&quot;) { return Array(padding + 1).join(&quot; &quot;) + value; } if (typeof padding === &quot;string&quot;) { return padding + value; } throw new Error(`Expected string or number, got '${padding}'.`); } // instanceof // 类型为 XObject | YObject let padder: Padder = getRandomObject(); if (padder instanceof XObject) { padder; // 类型细化为'XObject' } if (padder instanceof YObject) { padder; // 类型细化为'YObject' } 可以为null的类型 TypeScript具有两种特殊的类型， null和 undefined。默认情况下，类型检查器认为 null与 undefined可以赋值给任何类型。这也意味着，你阻止不了将它们赋值给其它类型，就算是你想要阻止这种情况也不行。 null的发明者，Tony Hoare，称它为 价值亿万美金的错误。 --strictNullChecks标记可以解决此错误：当你声明一个变量时，它不会自动地包含 null或 undefined。 你可以使用联合类型明确的包含它们： let s = &quot;foo&quot;; s = null; // 错误, 'null'不能赋值给'string' let sn: string | null = &quot;bar&quot;; sn = null; // 可以 sn = undefined; // error, 'undefined'不能赋值给'string | null' 注意，按照JavaScript的语义，TypeScript会把 null和 undefined区别对待。 string | null， string | undefined和 string | undefined | null是不同的类型。 可选参数和可选属性 使用了 --strictNullChecks，可选参数会被自动地加上 | undefined: function f(x: number, y?: number) { return x + (y || 0); } f(1, 2); f(1); f(1, undefined); f(1, null); // error, 'null' is not assignable to 'number | undefined' 可选属性也会有同样的处理： class C { a: number; b?: number; } let c = new C(); c.a = 12; c.a = undefined; // error, 'undefined' is not assignable to 'number' c.b = 13; c.b = undefined; // ok c.b = null; // error, 'null' is not assignable to 'number | undefined' 类型保护和类型断言 由于可以为null的类型是通过联合类型实现，那么你需要使用类型保护来去除 null。 幸运地是这与在JavaScript里写的代码一致： function f(sn: string | null): string { if (sn == null) { return &quot;default&quot;; } else { return sn; } } 这里很明显地去除了 null，你也可以使用短路运算符： function f(sn: string | null): string { return sn || &quot;default&quot;; } 如果编译器不能够去除 null或 undefined，你可以使用类型断言手动去除。 语法是添加 !后缀：identifier!从 identifier的类型里去除了 null和 undefined： function broken(name: string | null): string { function postfix(epithet: string) { return name.charAt(0) + '. the ' + epithet; // error, 'name' is possibly null } name = name || &quot;Bob&quot;; return postfix(&quot;great&quot;); } function fixed(name: string | null): string { function postfix(epithet: string) { return name!.charAt(0) + '. the ' + epithet; // ok } name = name || &quot;Bob&quot;; return postfix(&quot;great&quot;); } 本例使用了嵌套函数，因为编译器无法去除嵌套函数的null（除非是立即调用的函数表达式）。 因为它无法跟踪所有对嵌套函数的调用，尤其是你将内层函数做为外层函数的返回值。 如果无法知道函数在哪里被调用，就无法知道调用时 name的类型。 类型别名 类型别名会给一个类型起个新名字。 类型别名有时和接口很像，但是可以作用于原始值，联合类型，元组以及其它任何你需要手写的类型。起别名不会新建一个类型 - 它创建了一个新 名字来引用那个类型。 给原始类型起别名通常没什么用，尽管可以做为文档的一种形式使用。 同接口一样，类型别名也可以是泛型 - 我们可以添加类型参数并且在别名声明的右侧传入： type Container&lt;T&gt; = { value: T }; 我们也可以使用类型别名来在属性里引用自己： type Tree&lt;T&gt; = { value: T; left: Tree&lt;T&gt;; right: Tree&lt;T&gt;; } 与交叉类型一起使用，我们可以创建出一些十分稀奇古怪的类型。 type LinkedList&lt;T&gt; = T &amp; { next: LinkedList&lt;T&gt; }; interface Person { name: string; } var people: LinkedList&lt;Person&gt;; var s = people.name; var s = people.next.name; var s = people.next.next.name; var s = people.next.next.next.name; 然而，类型别名不能出现在声明右侧的任何地方。 type Yikes = Array&lt;Yikes&gt;; // error 接口 vs. 类型别名 类型别名可以像接口一样；然而，仍有一些细微差别。 其一，接口创建了一个新的名字，可以在其它任何地方使用。其二，类型别名不能被 extends和 implements（自己也不能 extends和implements其它类型）。 另一方面，如果你无法通过接口来描述一个类型并且需要使用联合类型或元组类型，这时通常会使用类型别名。 字符串字面量类型 字符串字面量类型允许你指定字符串必须的固定值。 type Easing = &quot;ease-in&quot; | &quot;ease-out&quot; | &quot;ease-in-out&quot;; 你只能从三种允许的字符中选择其一来做为参数传递，传入其它值则会产生错误。 Argument of type '&quot;uneasy&quot;' is not assignable to parameter of type '&quot;ease-in&quot; | &quot;ease-out&quot; | &quot;ease-in-out&quot;' 字符串字面量类型还可以用于区分函数重载： function createElement(tagName: &quot;img&quot;): HTMLImageElement; function createElement(tagName: &quot;input&quot;): HTMLInputElement; // ... more overloads ... function createElement(tagName: string): Element { // ... code goes here ... } 数字字面量类型 TypeScript还具有数字字面量类型。 function rollDie(): 1 | 2 | 3 | 4 | 5 | 6 { // ... } 我们很少直接这样使用，但它们可以用在缩小范围调试bug的时候： function foo(x: number) { if (x !== 1 || x !== 2) { // ~~~~~~~ // Operator '!==' cannot be applied to types '1' and '2'. } } 换句话说，当 x与 2进行比较的时候，它的值必须为 1，这就意味着上面的比较检查是非法的。 可辨识联合（Discriminated Unions） 你可以合并单例类型，联合类型，类型保护和类型别名来创建一个叫做 可辨识联合的高级模式，它也称做 标签联合或 代数数据类型。 可辨识联合在函数式编程很有用处。 一些语言会自动地为你辨识联合；而TypeScript则基于已有的JavaScript模式。 它具有3个要素： 具有普通的单例类型属性— 可辨识的特征。 一个类型别名包含了那些类型的联合— 联合。 此属性上的类型保护。 interface Square { kind: &quot;square&quot;; size: number; } interface Rectangle { kind: &quot;rectangle&quot;; width: number; height: number; } interface Circle { kind: &quot;circle&quot;; radius: number; } 首先我们声明了将要联合的接口。 每个接口都有 kind属性但有不同的字符串字面量类型。 kind属性称做 可辨识的特征或 标签。 其它的属性则特定于各个接口。 注意，目前各个接口间是没有联系的。 下面我们把它们联合到一起： type Shape = Square | Rectangle | Circle; 现在我们使用可辨识联合: function area(s: Shape) { switch (s.kind) { case &quot;square&quot;: return s.size * s.size; case &quot;rectangle&quot;: return s.height * s.width; case &quot;circle&quot;: return Math.PI * s.radius ** 2; } } ","link":"https://wzhzzmzzy.github.io/post/2019-5-21-TypeScript类型系统"},{"title":"TypeScript 语法深入","content":"迭代器和生成器 当一个对象实现了Symbol.iterator，我们认为它是可迭代的。对象上的 Symbol.iterator函数负责返回供迭代的值。 for...of语句 与 for...in语句 下面的例子展示了两者之间的区别： let list = [4, 5, 6]; for (let i in list) { console.log(i); // &quot;0&quot;, &quot;1&quot;, &quot;2&quot;, } for (let i of list) { console.log(i); // &quot;4&quot;, &quot;5&quot;, &quot;6&quot; } 另一个区别是for..in可以操作任何对象；它提供了查看对象属性的一种方法。 但是 for..of关注于迭代对象的值。内置对象Map和Set已经实现了Symbol.iterator方法，让我们可以访问它们保存的值。 let pets = new Set([&quot;Cat&quot;, &quot;Dog&quot;, &quot;Hamster&quot;]); pets[&quot;species&quot;] = &quot;mammals&quot;; for (let pet in pets) { console.log(pet); // &quot;species&quot; } for (let pet of pets) { console.log(pet); // &quot;Cat&quot;, &quot;Dog&quot;, &quot;Hamster&quot; } 模块 TypeScript 中有着多种export形式和多种import形式，其他大多与 JavaScript 中的主流模块实现相仿：模块自声明、模块使用模块加载器去导入其他模块。 导出 导出声明 任何声明都可以通过export来导出： export interface StringValidator { isAcceptable(s: string): boolean; } export const numberRegexp = /^[0-9]+$/; export class ZipCodeValidator implements StringValidator { isAcceptable(s: string) { return s.length === 5 &amp;&amp; numberRegexp.test(s); } } 导出语句 export { ZipCodeValidator as mainValidator }; 重新导出 我们经常会去扩展其它模块，并且只导出那个模块的部分内容。 重新导出功能并不会在当前模块导入那个模块或定义一个新的局部变量。 export {ZipCodeValidator as RegExpBasedZipCodeValidator} from &quot;./ZipCodeValidator&quot;; 一个模块可以包裹多个模块，并且把他们导出的内容联合在一起： export * from &quot;./ZipCodeValidator&quot;; 导入 import { ZipCodeValidator } from &quot;./ZipCodeValidator&quot;; import { ZipCodeValidator as ZCV } from &quot;./ZipCodeValidator&quot;; import * as validator from &quot;./ZipCodeValidator&quot;; import &quot;./my-module.js&quot;; // 副作用导入：尽管不推荐这么做，一些模块会设置一些全局状态供其它模块使用。 这些模块可能没有任何的导出或用户根本就不关注它的导出。 使用下面的方法来导入这类模块： 默认导出 每个模块都可以有一个default导出。 默认导出使用 default关键字标记；并且一个模块只能够有一个default导出。 需要使用一种特殊的导入形式来导入 default导出。 JQuery.d.ts declare let $: JQuery; export default $; 类和函数声明可以直接被标记为默认导出。 标记为默认导出的类和函数的名字是可以省略的。 export =和import = require() export =语法定义一个模块的导出对象。 这里的对象一词指的是类，接口，命名空间，函数或枚举。 若使用export =导出一个模块，则必须使用TypeScript的特定语法import module = require(&quot;module&quot;)来导入此模块。 ZipCodeValidator.ts let numberRegexp = /^[0-9]+$/; class ZipCodeValidator { isAcceptable(s: string) { return s.length === 5 &amp;&amp; numberRegexp.test(s); } } export = ZipCodeValidator; Test.ts import zip = require(&quot;./ZipCodeValidator&quot;); // Some samples to try let strings = [&quot;Hello&quot;, &quot;98052&quot;, &quot;101&quot;]; // Validators to use let validator = new zip(); // Show whether each string passed each validator strings.forEach(s =&gt; { console.log(`&quot;${ s }&quot; - ${ validator.isAcceptable(s) ? &quot;matches&quot; : &quot;does not match&quot; }`); }); 可选的模块加载和其他高级加载场景 编译器会检测是否每个模块都会在生成的JavaScript中用到。 如果一个模块标识符只在类型注解部分使用，并且完全没有在表达式中使用时，就不会生成 require这个模块的代码。 省略掉没有用到的引用对性能提升是很有益的，并同时提供了选择性加载模块的能力。 命名空间 使用namespaces可以让你更好地组织代码，避免重名、让代码结构更清晰。 namespace Student { export interface Boy { name: String; } export class Gay extends Boy { name: String; } } 你也可以把名空间拆到多个文件当中： Student.ts namespace Student { export interface Boy { name: String; } } Gay.ts /// &lt;reference path=&quot;Student.ts&quot;&gt; namespace Student { export class Gay extends Boy { name: String; } } 尽管是不同的文件，它们仍是同一个命名空间，并且在使用的时候就如同它们在一个文件中定义的一样。 因为不同文件之间存在依赖关系，所以我们加入了引用标签来告诉编译器文件之间的关联。 我们的测试代码保持不变。 别名 另一种简化命名空间操作的方法是使用import q = x.y.z给常用的对象起一个短的名字。 不要与用来加载模块的 import x = require('name')语法弄混了，这里的语法是为指定的符号创建一个别名。 你可以用这种方法为任意标识符创建别名，也包括导入的模块中的对象。对于值来讲， import会生成与原始符号不同的引用，所以改变别名的var值并不会影响原始变量的值。 namespace Shapes { export namespace Polygons { export class Triangle { } export class Square { } } } import polygons = Shapes.Polygons; let sq = new polygons.Square(); // Same as &quot;new Shapes.Polygons.Square()&quot; 使用其他的 JavaScript 库 为了描述不是用TypeScript编写的类库的类型，我们需要声明类库导出的API。 由于大部分程序库只提供少数的顶级对象，命名空间是用来表示它们的一个好办法。 我们称其为声明是因为它不是外部程序的具体实现。 我们通常在 .d.ts里写这些声明。 如果你熟悉C/C++，你可以把它们当做 .h文件。 命名空间与模块 使用命名空间 命名空间是位于全局命名空间下的一个普通的带有名字的JavaScript对象。 这令命名空间十分容易使用。 它们可以在多文件中同时使用，并通过 --outFile结合在一起。 命名空间是帮你组织Web应用不错的方式，你可以把所有依赖都放在HTML页面的 &lt;script&gt;标签里。 但就像其它的全局命名空间污染一样，它很难去识别组件之间的依赖关系，尤其是在大型的应用中。 使用模块 像命名空间一样，模块可以包含代码和声明。 不同的是模块可以 声明它的依赖。 模块会把依赖添加到模块加载器上（例如CommonJs / Require.js）。 对于小型的JS应用来说可能没必要，但是对于大型应用，这一点点的花费会带来长久的模块化和可维护性上的便利。 模块也提供了更好的代码重用，更强的封闭性以及更好的使用工具进行优化。 对于Node.js应用来说，模块是默认并推荐的组织代码的方式。 从ECMAScript 2015开始，模块成为了语言内置的部分，应该会被所有正常的解释引擎所支持。 因此，对于新项目来说推荐使用模块做为组织代码的方式。 ","link":"https://wzhzzmzzy.github.io/post/2019-5-21-TypeScript语法"},{"title":"VueAdminTemplate源码分析","content":"Vue Element Admin - Documents 全局设置 整个页面可以有全局设置，之前我是写死在vuex当中的，但是这个template的全局设置是@/settings.js，然后在@/store/settings.js中使用vuex进行控制。似乎这样是更好的方法。 登录系统 路由：@/route，视图：@/views/login，数据：@/store/modules/user.js，Mock：mock/user.js，Cookies：@/utils/auth.js。 这里我学到的内容有： 路由守卫重定向到登录页面之后，可以携带redirect。 watch: { $route: { // 判断是否需要进行跳转 handler: function(route) { this.redirect = route.query &amp;&amp; route.query.redirect }, immediate: true } } 密码显示与不显示（Vue.nextTick）。 showPwd() { if (this.passwordType === 'password') { this.passwordType = '' } else { this.passwordType = 'password' } // 保证 Focus 发生在 密码框状态改变之后 this.$nextTick(() =&gt; { this.$refs.password.focus() }) } Cookies 的处理，我们会需要把 Token 写在浏览器的 Cookie 里，之前我写 H5 的时候完全忘记了对 Cookie 的复用。这里我们可以使用js-cookie库。 // @/utils/auth.js import Cookies from 'js-cookie' const TokenKey = 'vue_admin_template_token' export function getToken() { return Cookies.get(TokenKey) } export function setToken(token) { return Cookies.set(TokenKey, token) } export function removeToken() { return Cookies.remove(TokenKey) } 登录守卫 一般来说，我们会使用 Vue-Router 的路由守卫功能实现对用户在跳转到目标路由之前进行鉴权。在该项目中同样，根据浏览器当前是否保有 Cookies 来进行判断。这里没有对 Cookies 做任何校验，其实是可以做的。 const hasToken = getToken() // 获取浏览器当前的 Cookies if (hasToken) { // 如果 Cookies 存在，那就是已登录的状态 if (to.path === '/login') { next({ path: '/' }) } else { next() } } else { // 否则就是未登录，那么不需要登录态的页面是可以进入的 if (whiteList.indexOf(to.path) !== -1) { next() } else { // 需要登录态的页面重定向到 login next(`/login?redirect=${to.path}`) } } 为了照顾用户的观感，使用NProgress进度条： router.beforeEach(async(to, from, next) =&gt; { // start progress bar NProgress.start() ... }) router.afterEach(() =&gt; { // finish progress bar NProgress.done() }) Mock 使用mock.js可以脱离后台测试 API。以table为例： // API export function getList(params) { return request({ url: '/table/list', method: 'get', params }) } // Table import Mock from 'mockjs' const data = Mock.mock({ 'items|30': [{ id: '@id', title: '@sentence(10, 20)', 'status|1': ['published', 'draft', 'deleted'], author: 'name', display_time: '@datetime', pageviews: '@integer(300, 5000)' }] }) export default [ { url: '/table/list', type: 'get', response: config =&gt; { const items = data.items return { code: 20000, data: { total: items.length, items: items } } } } ] Nested 示例中给出了收缩列表的使用方式，写法是嵌套&lt;router-view&gt; // @/views/nested/menu1/index.vue &lt;template&gt; &lt;div style=&quot;padding:30px;&quot;&gt; &lt;el-alert :closable=&quot;false&quot; title=&quot;menu 1&quot;&gt; &lt;router-view /&gt; &lt;/el-alert&gt; &lt;/div&gt; &lt;/template&gt; // @/views/nested/menu1/menu1-2/index.vue &lt;template&gt; &lt;div style=&quot;padding:30px;&quot;&gt; &lt;el-alert :closable=&quot;false&quot; title=&quot;menu 1-2&quot; type=&quot;success&quot;&gt; &lt;router-view /&gt; &lt;/el-alert&gt; &lt;/div&gt; &lt;/template&gt; // @/views/nested/menu1/menu1-2/menu1-2-1/index.vue &lt;template functional&gt; &lt;div style=&quot;padding:30px;&quot;&gt; &lt;el-alert :closable=&quot;false&quot; title=&quot;menu 1-2-1&quot; type=&quot;warning&quot; /&gt; &lt;/div&gt; &lt;/template&gt; 对 Axios 的封装 在 Axios 中，可以创建默认访问器： const service = axios.create({ baseURL: process.env.VUE_APP_BASE_API, // url = base url + request url withCredentials: true, // send cookies when cross-domain requests timeout: 5000 // request timeout }) 对于每一个请求和响应，我们都可以添加 Hook 来做一些固定的预处理工作： // request interceptors service.interceptors.request.use( config =&gt; { // do something before request is sent if (store.getters.token) { config.headers['X-Token'] = getToken() } return config }, error =&gt; { // do something with request error console.log(error) // for debug return Promise.reject(error) } ) // response interceptors service.interceptors.response.use( response =&gt; { const res = response.data // if the custom code is not 20000, it is judged as an error. if (res.code !== 20000) { Message({ message: res.message || 'error', type: 'error', duration: 5 * 1000 }) // 50008: Illegal token; 50012: Other clients logged in; 50014: Token expired; if (res.code === 50008 || res.code === 50012 || res.code === 50014) { // to re-login MessageBox.confirm('You have been logged out, you can cancel to stay on this page, or log in again', 'Confirm logout', { confirmButtonText: 'Re-Login', cancelButtonText: 'Cancel', type: 'warning' }).then(() =&gt; { store.dispatch('user/resetToken').then(() =&gt; { location.reload() }) }) } return Promise.reject(res.message || 'error') } else { return res } }, error =&gt; { console.log('err' + error) // for debug Message({ message: error.message, type: 'error', duration: 5 * 1000 }) return Promise.reject(error) } ) 面包屑（Breadcrumb） 使用 Element-UI 中的el-breadcrumb即可。问题在于如何实现将面包屑独立成为单独可用的组件，并随着页面的路由更新。 初始化面包屑并随时更新 首先，通过 Hook 和侦听器可以解决一半的问题。 { watch: { $route() { this.getBreadcrumb() } }, created() { this.getBreadcrumb() } } 接下来，通过$route.matched可以拿到所有嵌套的路由片段，这里我们只需要使用path和meta.title即可。其中，meta.title是在@/router/index.js中定义过的。其中，对于特别的dashboard页面需要特别判断一下。 getBreadcrumb() { // only show routes with meta.title let matched = this.$route.matched.filter(item =&gt; item.meta &amp;&amp; item.meta.title) const first = matched[0] if (!this.isDashboard(first)) { matched = [{ path: '/dashboard', meta: { title: 'Dashboard' }}].concat(matched) } this.levelList = matched.filter(item =&gt; item.meta &amp;&amp; item.meta.title &amp;&amp; item.meta.breadcrumb !== false) } isDashboard(route) { const name = route &amp;&amp; route.name if (!name) { return false } return name.trim().toLocaleLowerCase() === 'Dashboard'.toLocaleLowerCase() } 对于有些不能够直接跳转的页面，需要获取meta.redirect来跳转。 布局（layout） Mobile 处理 在这个模板当中，使用了@/layout/ResizeMixin来做对小窗口的适配。当检测到窗口变小之后，会自动触发window.resize事件，只需要监听这个事件即可。对于当前是否要进行侧边栏的隐藏，则可以通过store来进行。 const WIDTH = 992 // refer to Bootstrap's responsive design $_isMobile() { const rect = body.getBoundingClientRect() return rect.width - 1 &lt; WIDTH } $_resizeHandler() { if (!document.hidden) { const isMobile = this.$_isMobile() store.dispatch('app/toggleDevice', isMobile ? 'mobile' : 'desktop') if (isMobile) { store.dispatch('app/closeSideBar', { withoutAnimation: true }) } } } 页面基础布局 我们会需要在页面上使用一个基础布局时，主要通过vue-router来实现，即，在所有需要使用到基础页面布局的路由上使用一个固定的Layout组件，然后使用嵌套路由进行内部组件的放置。 顶部栏（navbar） 顶部栏的功能比较少，因为这是一个较为纯粹的侧边栏结构，如果用过WordPress会觉得这个布局非常熟悉。顶部栏主要只包含hamburger，breadthumb，以及一个avatar和下拉框。 侧边栏 侧边栏需要做到的功能较多，该模板还支持了对用户权限的动态路由生成。 首先是一个比较简单的点：侧边栏的default-active。这可以通过路由来进行不同的分派。 然后是根据动态路由表对侧边栏进行渲染，避免了路由与侧边栏之间的耦合。这里需要对路由进行hidden的过滤，比如404页面就不应该被渲染。对于侧边栏每一个item上的LOGO，需要做一下分派。BTW，这里侧边栏的开合是使用vuex记录状态的，所以确实是可以这样用的。 这里的侧边栏item是使用了 JS 渲染的方式进行构建，以下是render函数： render(h, context) { const { icon, title } = context.props const vnodes = [] if (icon) { vnodes.push(&lt;svg-icon icon-class={icon}/&gt;) } if (title) { vnodes.push(&lt;span slot='title'&gt;{(title)}&lt;/span&gt;) } return vnodes } ","link":"https://wzhzzmzzy.github.io/post/2019-5-7-VueAdmin"},{"title":"Web 开发基础知识复习 —— HTML","content":"HTML基础 HTML 元素 首先是一些基础知识，显然，大多数HTML元素都有开始标签和结束标签，元素可以嵌套。块级元素（block）和内联元素（inline）这两类元素也十分浅显易懂： 块级元素在页面中以块的形式展现 —— 相对与其前面的内容它会出现在新的一行，其后的内容也会被挤到下一行展现。内联元素通常出现在块级元素中并包裹文档内容的一小部分，而不是一整个段落或者一组内容。 —— MDN 另外，还有一类元素是空元素（void elements），例如img，这些元素没有结束标签，只有一个标记，告诉你需要在文档的这个位置嵌入一些东西。 元素可以拥有属性，例如class、id。除了有值的属性，还可以有布尔属性，即不需要赋值的属性。对于属性值，包围其的引号是可以省略的，前提是它不含有空格。 HTML文档结构 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;我的测试站点&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;这是我的页面&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; 这是一个非常简单的HTML文档，分析如下： &lt;!DOCTYPE html&gt;是用于声明文档类型的。这是最短的有效文档声明。 &lt;html&gt;，根元素。 &lt;head&gt;，包含所有不在页面上显示，但是需要的内容。 &lt;meta charset=&quot;utf-8&quot;&gt;，设置文档的字符编码。 &lt;title&gt;，页面标题，出现在浏览器标签上。 &lt;body&gt;，显示的页面内容。 实体引用 HTML 有特别的设计，即忽略元素内容中的空格，并且其由于一些需要定义了一些特别的符号。这里就需要使用实体引用来在页面上显示这些特别的符号。 原义字符 等价引用 &lt; &amp;lt; &gt; &amp;gt; &quot; &amp;quot; ' &amp;apos; &amp; &amp;amp; 所有的实体引用列表在Wikipedia可查。 关于 HTML 头部 这里可以添加网页的源信息，比如标题、字符集、作者、描述等等。作者和描述会被搜索引擎捕获。 &lt;meta name=&quot;author&quot; content=&quot;wzhzzmzzy&quot;&gt; &lt;meta name=&quot;description&quot; content=&quot;HTML 的基础复习。&quot;&gt; 对于一些特别的网站，可能会有一些更复杂的metadata，比如推特和脸书，他们都有自己的协议。 此外，网页还可以添加一个16*16的小图标作为自己的favicon： &lt;link rel=&quot;shortcut icon&quot; href=&quot;favicon.ico&quot; type=&quot;image/x-icon&quot;&gt; 当然，还可以添加其他标准的图标，这里有MDN的为例： &lt;!-- third-generation iPad with high-resolution Retina display: --&gt; &lt;link rel=&quot;apple-touch-icon-precomposed&quot; sizes=&quot;144x144&quot; href=&quot;https://developer.cdn.mozilla.net/static/img/favicon144.a6e4162070f4.png&quot;&gt; &lt;!-- iPhone with high-resolution Retina display: --&gt; &lt;link rel=&quot;apple-touch-icon-precomposed&quot; sizes=&quot;114x114&quot; href=&quot;https://developer.cdn.mozilla.net/static/img/favicon114.0e9fabd44f85.png&quot;&gt; &lt;!-- first- and second-generation iPad: --&gt; &lt;link rel=&quot;apple-touch-icon-precomposed&quot; sizes=&quot;72x72&quot; href=&quot;https://developer.cdn.mozilla.net/static/img/favicon72.8ff9d87c82a0.png&quot;&gt; &lt;!-- non-Retina iPhone, iPod Touch, and Android 2.1+ devices: --&gt; &lt;link rel=&quot;apple-touch-icon-precomposed&quot; href=&quot;https://developer.cdn.mozilla.net/static/img/favicon57.a2490b9a2d76.png&quot;&gt; &lt;!-- basic favicon --&gt; &lt;link rel=&quot;shortcut icon&quot; href=&quot;https://developer.cdn.mozilla.net/static/img/favicon32.e02854fdcf73.png&quot;&gt; 在HTML中应用CSS和JavaScript可以使用&lt;link&gt;和&lt;script&gt;，非常简单： &lt;link rel=&quot;stylesheet&quot; href=&quot;index.css&quot;&gt; &lt;script src=&quot;main.js&quot;&gt;&lt;/script&gt; 值得一提的是，我们应该为我们的页面设定主要语言： &lt;html lang=&quot;en-US&quot;&gt; 语义 在HTML中，语义化是一个非常重要的事。其实语义化对实际编码的要求非常简单：在适当的地方使用适当的标签。例如，在大标题上使用h1，在地址上使用address，如此而已。语义化对用户迅速发现需要的信息、搜索引擎检索网页、无障碍阅读器来说是十分有益的。 斜体、粗体、下划线 b、i、u这些标签被用于表示传统意义上的粗体、斜体和下划线，但他们对语义没有任何帮助。当你需要表示强调时，可以使用em、strong标签。 超链接 在HTML中，超链接使用a标签实现。我们需要关注的是使用链接时的最佳实践： 不要重复URL作为链接文本的一部分 — URL看起来很丑，当屏幕朗读器一个字母一个字母的读出来的时候听起来就更丑了。 不要在链接文本中说“link”或“links to”——它只是噪音。屏幕阅读器告诉人们有一个链接。可视化用户也会知道有一个链接，因为链接通常是用不同的颜色设计的，并且存在下划线（这个惯例一般不应该被打破，因为用户习惯了它。） 保持你的链接标签尽可能短-长链接尤其惹恼屏幕阅读器用户，他们必须听到整件事读出来。 并且，最好尽量使用相对链接。 顺便，邮件地址的链接URL有所不同：&lt;a href=&quot;mailto:nowhere@mozilla.org&quot;&gt;Send email to nowhere&lt;/a&gt; 高级排版 HTML 有描述列表和引用来表示一些特别的文本内容。 描述列表 &lt;dl&gt; &lt;dt&gt;内心独白&lt;/dt&gt; &lt;dd&gt;戏剧中，某个角色对自己的内心活动或感受进行念白表演，这些台词只面向观众，而其他角色不会听到。&lt;/dd&gt; &lt;dt&gt;语言独白&lt;/dt&gt; &lt;dd&gt;戏剧中，某个角色把自己的想法直接进行念白表演，观众和其他角色都可以听到。&lt;/dd&gt; &lt;dt&gt;旁白&lt;/dt&gt; &lt;dd&gt;戏剧中，为渲染幽默或戏剧性效果而进行的场景之外的补充注释念白，只面向观众，内容一般都是角色的感受、想法、以及一些背景信息等。&lt;/dd&gt; &lt;/dl&gt; 内心独白 戏剧中，某个角色对自己的内心活动或感受进行念白表演，这些台词只面向观众，而其他角色不会听到。 语言独白 戏剧中，某个角色把自己的想法直接进行念白表演，观众和其他角色都可以听到。 旁白 戏剧中，为渲染幽默或戏剧性效果而进行的场景之外的补充注释念白，只面向观众，内容一般都是角色的感受、想法、以及一些背景信息等。 块引用 &lt;blockquote cite=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/blockquote&quot;&gt; &lt;p&gt;The &lt;strong&gt;HTML &lt;code&gt;&amp;lt;blockquote&amp;gt;&lt;/code&gt; Element&lt;/strong&gt; (or &lt;em&gt;HTML Block Quotation Element&lt;/em&gt;) indicates that the enclosed text is an extended quotation.&lt;/p&gt; &lt;/blockquote&gt; The HTML &lt;blockquote&gt; Element (or HTML Block Quotation Element) indicates that the enclosed text is an extended quotation. 行内引用 &lt;p&gt;The quote element — &lt;code&gt;&amp;lt;q&amp;gt;&lt;/code&gt; — is &lt;q cite=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/q&quot;&gt;intended for short quotations that don't require paragraph breaks.&lt;/q&gt;&lt;/p&gt; The quote element — &lt;q&gt; — is intended for short quotations that don't require paragraph breaks. #### 引文 #### cite属性用于表示引文的原地址，但是它不会出现在浏览器的渲染名单上，因此我们可以把cite放在元素旁边，然后给它加上链接。 &lt;p&gt;According to the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/blockquote&quot;&gt; &lt;cite&gt;MDN blockquote page&lt;/cite&gt;&lt;/a&gt;: &lt;/p&gt; &lt;blockquote cite=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/blockquote&quot;&gt; &lt;p&gt;The &lt;strong&gt;HTML &lt;code&gt;&amp;lt;blockquote&amp;gt;&lt;/code&gt; Element&lt;/strong&gt; (or &lt;em&gt;HTML Block Quotation Element&lt;/em&gt;) indicates that the enclosed text is an extended quotation.&lt;/p&gt; &lt;/blockquote&gt; &lt;p&gt;The quote element — &lt;code&gt;&amp;lt;q&amp;gt;&lt;/code&gt; — is &lt;q cite=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/q&quot;&gt;intended for short quotations that don't require paragraph breaks.&lt;/q&gt; -- &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/q&quot;&gt; &lt;cite&gt;MDN q page&lt;/cite&gt;&lt;/a&gt;.&lt;/p&gt; According to the MDN blockquote page: The HTML &lt;blockquote&gt; Element (or HTML Block Quotation Element) indicates that the enclosed text is an extended quotation. The quote element — &lt;q&gt; — is intended for short quotations that don't require paragraph breaks. -- MDN q page. ### 缩略语和联系方式 ### &lt;abbr&gt;，这是非常有用的一项工具，当我们鼠标悬停在其上时，会出现一个悬浮的文字提示。 &lt;p&gt;我们使用 &lt;abbr title=&quot;超文本标记语言（Hypertext Markup Language）&quot;&gt;HTML&lt;/abbr&gt; 来组织网页文档。&lt;/p&gt; &lt;p&gt;第 33 届 &lt;abbr title=&quot;夏季奥林匹克运动会&quot;&gt;奥运会&lt;/abbr&gt; 将于 2024 年 8 月在法国巴黎举行。&lt;/p&gt; &lt;address&gt;，用于标记联系方式，表现和普通的块级元素一样。 &lt;address&gt; &lt;p&gt;Chris Mills, Manchester, The Grim North, UK&lt;/p&gt; &lt;/address&gt; 展示代码 这是非常重要的需求，所以提供了好几个标签来提供完整的功能： code: 用于标记计算机通用代码。 pre: 对保留的空格（通常是代码块）——如果您在文本中使用缩进或多余的空白，浏览器将忽略它，您将不会在呈现的页面上看到它。但是，如果您将文本包含在&lt;pre&gt;&lt;/pre&gt;标签中，那么空白将会以与你在文本编辑器中看到的相同的方式渲染出来。 var: 用于标记具体变量名。 kbd: 用于标记输入电脑的键盘（或其他类型）输入。 samp: 用于标记计算机程序的输出。 const para = document.querySelector('p'); para.onclick = function() { alert('噢，噢，噢，别点我了。'); } 请不要使用 &lt;font&gt; 、 &lt;center&gt; 等表象元素。 在上述的 JavaScript 示例中，para 表示一个段落元素。 按 Ctrl/Cmd + A 选择全部内容。 $ ping mozilla.org PING mozilla.org (63.245.215.20): 56 data bytes 64 bytes from 63.245.215.20: icmp_seq=0 ttl=40 time=158.233 ms 时间和日期 &lt;time datetime=&quot;2016-01-20&quot;&gt;2016年1月20日&lt;/time&gt; 这同样是HTML语义化的一部分。 文档的基本组成 标题栏 通常横跨于整个页面顶部有一个大标题 和/或 一个标志。 这是网站的主要一般信息，通常存在于所有网页。 导航栏 指向网站各个主要区段的超链接。通常用菜单按钮、链接或标签页表示。类似于标题栏，导航栏通常应在所有网页之间保持一致，否则会让用户感到疑惑，甚至无所适从。许多 web 设计人员认为导航栏是标题栏的一部分，而不是独立的组件，但这并非决对；还有人认为，两者独立可以提供更好的 [无障碍访问特性](https://developer.mozilla.org/zh-CN/docs/learn/Accessibility)，因为屏幕阅读器可以更清晰地分辨二者。 主内容 中心的大部分区域是当前网页大多数的独有内容，例如视频、文章、地图、新闻等。这些内容是网站的一部分，且会因页面而异。 侧边栏 一些外围信息、链接、引用、广告等。通常与主内容相关（例如一个新闻页面上，侧边栏可能包含作者信息或相关文章链接），还可能存在其他的重复元素，如辅助导航系统。 页脚 横跨页面底部的狭长区域。和标题一样，页脚是放置公共信息（比如版权声明或联系方式）的，一般使用较小字体，且通常为次要内容。 还可以通过提供快速访问链接来进行 [SEO](https://developer.mozilla.org/en-US/docs/Glossary/SEO)。 对于这些部分，HTML都提供了特别的标签： &lt;header&gt;、&lt;nav&gt;、&lt;main&gt;、&lt;aside&gt;、&lt;footer&gt;。 有时候，我们的内容需要无法与现在的语义元素相应，那么就可以使用一些无语义元素：&lt;div&gt;、&lt;span&gt;。注意，尽量少用无语义元素。 验证文档 HTML 同样需要 Debug，但是浏览器没法给出非常明显的错误提示，所以我们可以借助W3C创建并维护的一个标记验证服务：Markup Validation Service ","link":"https://wzhzzmzzy.github.io/post/2019-4-3-Web开发基础复习"},{"title":"初试 GraphQL","content":" GraphQL 中文文档 语法 GraphQL 在服务端和客户端之间设定了一套全新的语法，这套语法非常简洁明了，不过有些地方还是需要仔细的研读文档才能理解。我们来整理一下吧。 入口 名为 Query 的类型是 GraphQL 的查询入口，指定了我们写的查询中可以包含的字段，以及字段的类型。 type Query { hero: Charactor } 这里表示我们的查询中可以包含hero这个字段，这个字段的类型是Charactor。 查询和变更 在 GraphQL 中，Client 可以使用非常简单的语法进行查询，发送的查询与需要的结果非常一致： # query { hero { name } } # response { &quot;data&quot;: { &quot;hero&quot;: { &quot;name&quot;: &quot;R2-D2&quot; } } } 这是 GraphQL 最重要的特性，这样可以保证你总是能得到想要的数据，服务器也能精准地了解到客户端需要哪些字段。 GraphQL 还有一个非常重要的特性：次级选择，即是说，当你进行查询时，可以对查询的嵌套对象进行字段指定，GraphQL 能够遍历相关对象和其字段，而不需要像 REST 一样多次往返查询。 参数 指定字段查询之外，GraphQL 还支持指定参数查询： # query { human(id: &quot;1000&quot;) { name height } } # response { &quot;data&quot;: { &quot;human&quot;: { &quot;name&quot;: &quot;&quot;, &quot;height&quot;: 1.72 } } } 在类似 REST 的系统中，只能传递一组简单参数，但是在 GraphQL 中，每个字段和嵌套对象都能有自己的一组参数，从而使得 GraphQL 可以完美替代多次 API 获取请求。甚至你也可以给标量字段传递参数，用于实现服务端的一次转换，而不用每个客户端分别转换。 参数可以是多种不同的类型，例如枚举类型等。 别名 为了让客户端可以更加方便地将数据转化为需要的格式，客户端可以在查询中指定别名： # query { empireHero: hero(episode: EMPIRE) { name } jediHero: hero(episode: JEDI) { name } } # response { &quot;data&quot;: { &quot;empireHero&quot;: { &quot;name&quot;: &quot;Luke Skywalker&quot; }, &quot;jediHero&quot;: { &quot;name&quot;: &quot;R2-D2&quot; } } } 片段 当你需要复用一个片段时，可以声明一个fragment，用于复用，使用的语法和ES6的对象扩展很像： { leftComparison: hero(episode: EMPIRE) { ...comparisonFields } rightComparison: hero(episode: JEDI) { ...comparisonFields } } fragment comparisonFields on Character { name appearsIn friends { name } } 片段可以使用变量： query HeroComparison($first: Int = 3) { leftComparison: hero(episode: EMPIRE) { ...comparisonFields } rightComparison: hero(episode: JEDI) { ...comparisonFields } } fragment comparisonFields on Character { name friendsConnection(first: $first) { totalCount edges { node { name } } } } 操作名称 上面的都是简写语法，省略了query关键字，我们可以给我们的查询添加名称： query HeroNameAndFriends { hero { name friends { name } } } 变量 在查询中，我们同样可以使用变量，当使用查询时，需要将valName: value传入。 query HeroNameAndFriends($episode: Episode = &quot;JEDI&quot;) { hero(episode: $episode) { name friends { name } } } 变量的前缀需要有$。 我们也可以使用指令来指定是否需要查询一个字段： query Hero($episode: Episode, $withFriends: Boolean!) { hero(episode: $episode) { name friends @include(if: $withFriends) { name } } } 变更 除了查询之外，我们也需要让客户端有变更服务端数据的能力。 mutation CreateReviewForEpisode($ep: Episode!, $review: ReviewInput!) { createReview(episode: $ep, review: $review) { stars commentary } } 内联片段 在查询的时候，我们可以在查询中添加对收到的不同类型的字段进行分别查询，可能这样说有点不直观，那就看个例子： // query query HeroForEpisode($ep: Episode!) { hero(episode: $ep) { name ... on Droid { primaryFunction } ... on Human { height } } } // response { &quot;data&quot;: { &quot;hero&quot;: { &quot;name&quot;: &quot;R2-D2&quot;, &quot;primaryFunction&quot;: &quot;Astromech&quot; } } } 元字段 某些时候，你可能不知道从服务端获得的类型是什么，这时候你就需要一些方法在客户端来决定如何处理数据。我们可以在查询中请求__typename，然后结果中可以看到对应的类型。 // query { search(text: &quot;an&quot;) { __typename ... on Human { name } ... on Droid { name } ... on Starship { name } } } // response { &quot;data&quot;: { &quot;search&quot;: [ { &quot;__typename&quot;: &quot;Human&quot;, &quot;name&quot;: &quot;Han Solo&quot; }, { &quot;__typename&quot;: &quot;Human&quot;, &quot;name&quot;: &quot;Leia Organa&quot; }, { &quot;__typename&quot;: &quot;Starship&quot;, &quot;name&quot;: &quot;TIE Advanced x1&quot; } ] } } Schema和类型 我们可以把GraphQL当做是一门强类型语言，每一个量都需要声明其不同的类型。 对象类型和字段 我们可以在GraphQL中声明对象类型及其字段。 type Character { name: String! appearsIn: [Episode!]! } !表示非空的字段，在GraphQL中，任何字段默认都是可以为空的。 []表示列表字段。 每一个字段可以带有零个或多个参数： type Starship { id: ID! name: String! length(unit: LengthUnit = METER): Float } 每个参数都是具名参数，需要一一对应。单数可以是可选的，也可以是必选的，如果是可选的话需要设置一个默认值。 查询和变更类型 有两张特别的类型：Query和Mutation。Query是你的Schema的查询入口，Mutation是你修改数据状态的入口。当然，除了他们两个是Schema的入口之外，他们和其他类型的构建方法别无二致。 标量类型 GraphQL预设了标量类型：Int、Float、String、Boolean、ID。 其中，Int是有符号三十二位整数，Float是有符号双精度浮点数，ID本质上与String相同，但是它并不要求可读性。我们同样可以自定义标量类型： scalar Date 我们自定义的标量类型需要我们自行实现如何将其序列化、反序列化和验证。 枚举类型 与一般的枚举类型并无差别。 enum Episod { NEWHOPE EMPIRE JEDI } 接口 GraphQL支持接口，一个接口是一个抽象类型，对象类型可以实现一个接口。 interface Character { id: ID! name: String! friends: [Character] appearsIn: [Episode]! } type Human implements Character { id: ID! name: String! friends: [Character] appearsIn: [Episode]! starships: [Starship] totalCredits: Int } type Droid implements Character { id: ID! name: String! friends: [Character] appearsIn: [Episode]! primaryFunction: String } 和Java中一样，一个被声明为接口类型的字段无法访问实现了接口的子类的专有字段。所以我们这里应该使用内联片段。 联合类型 这个十分好理解，一个字段不止可以是一个类型，也可以是其他类型。但是在查询联合类型的字段时，需要通过内联片段才可以。 union SearchResult = Human | Droid | Starship { search(text: &quot;an&quot;) { ... on Human { name height } ... on Droid { name primaryFunction } ... on Starship { name length } } } 输入类型 在Mutation中，我们可能需要传递一整个对象，而不是一个个传参。Input类型可以帮助我们做到这一点。 input ReviewInput { stars: Int! commentary: String } mutation CreateReviewForEpisode($ep: Episode!, $review: ReviewInput!) { createReview(episode: $ep, review: $review) { stars commentary } } 执行 GraphQL的每一个类型的每一个字段都需要在服务器上实现其resolver，当一个字段被执行的时候，相应的resolver被调用以产生下一个值。如果字段产生的是一个对象，那么这个查询还需要继续执行其对应字段的解析器，直到生成标量值。 在GraphQL服务端的顶层，是整个API的入口点：Query。解析器函数接受4个参数：obj、args、context、info。 异步解析 我们来分析一下下面这个解析器里面发生了什么： human(obj, args, context, info) { return context.db.loadHumanByID(args.id).then( userData =&gt; new Human(userData) ) } context提供一个数据库访问对象，用来通过查询中传递的参数id来查询数据，因为从数据库拉取数据的过程是一个一步操作，所以返回了一个Promise对象。 内省 我们有时候需要问GraphQL Schema支持哪些查询，通过__schema字段可以查到有哪些类型可用： { __schema { types { name } } } 内省系统支持的字段有：__Schema、__Type、__TypeKind、__Field、__InputValue、__EnumValue、__Directive。 __Type字段可以用来查询对应对象类型的类型和字段： { __type(name: &quot;Droid&quot;) { name fields { name type { name kind ofType { name kind } } } } } 在查询__Type的时候，可能会发现有些类型显示为NON_NULL或者LIST，而类型名称为null，这是因为是包装类型，需要通过ofType来获取其更详细的类型。 ","link":"https://wzhzzmzzy.github.io/post/2019-3-19-GraphQL"},{"title":"WebSocket聊天室（Vue + Tornado）","content":"对前端的一点想法 这个项目基本上是用 Vue + Vuex + Vue Router 三件套加上 Element-UI 完成的。用 Element 是因为我的CSS能力有点弱……坑不少，也是因为我对这方面的代码不太了解。前端代码完全和服务器端和中间件不一样，后端和中间件专注于数据的处理和网络通信，所以算法的分量会更重一点，前端在我看来就有更多的小 Tips，如果你没有见过前人巧妙的写法，或是你不够聪明，你是很难想到可以这样写的。 我没有完全了解Vue的API和教程里深入理解的所有内容，因为我觉得现有的内容足够让我写出一个完整的APP。顺便，作为单Vue文件组件来说，JSX是个非常好用的东西。完全了解一个框架或是一门语言我觉得是有一些益处的，这样可以帮助你理解别人（大佬）的代码，也可以让你触类旁通，或是理解有些地方为什么如此设计，或是对其内部工作原理得到一些自己的猜想。 不多说这个，先讲讲项目架构好了。 NPM项目的通用结构，因为没有用 TS 和 Jest，因为还没有仔细看过文档和实践过。不提 Webpack 和 Yarn 的配置，因为我只是大概了解一点，所以用了vue-cli一键建好。下一个项目会用上TS去感受一下，因为确实在写代码的时候发生了很多无意的小错误。 Vuex 在src/store中放置了 Vuex 的代码： - store - index.js - actions.js - mutations.js 需要在index.js中导入 Vuex ，并且Vue.use(Vuex)。Vuex 和 Flux 和 Redux 还是有一些不同的，最明显的不同就是你可以在mutations中直接对state进行修改，Redux则是需要一个个Pure Function，不去对状态做任何修改。 为了在其他组件中显示登录和创建房间的对话框、控制顶部导航栏的标签显示正确，我将控制显示的一些 Flag 变量放在了全局state中，不知道这是不是最佳实践。另外，我也不太理解要如何在一个mutation中调用另一个mutation。 总的来说，Vuex 的体验还是非常棒的。 Vue Router Vue 全家桶还不错，只是中文文档用词过于简略以至于有点无法理解，需要Google的帮助。Router 作为一个插件可以直接放到 Vue 中，这个不提，大家都是这样。在刚接触它时，只是知道可以这样写，看了Vant的H5 Demo之后，才发现原来 router.js 还有这种写法，也是这个Demo帮我了解了什么是导航守卫，以下是他的示例： // vant-demo/base/src/router.js import Vue from 'vue'; import Router from 'vue-router'; Vue.use(Router); const routes = [ { path: '*', redirect: '/goods' }, { name: 'user', component: () =&gt; import('./view/user'), meta: { title: '会员中心' } }, { name: 'cart', component: () =&gt; import('./view/cart'), meta: { title: '购物车' } } ]; // add route path routes.forEach(route =&gt; { route.path = route.path || '/' + (route.name || ''); }); const router = new Router({ routes }); router.beforeEach((to, from, next) =&gt; { const title = to.meta &amp;&amp; to.meta.title; if (title) { document.title = title; } next(); }); export { router }; 全局重定向和后面统一添加route path的方法还是让我有点惊奇，当然也是我大惊小怪了。总之这样的做法确实会高效和清晰很多。 由于聊天室的路由跳转都放在了顶部导航栏上，页面也少，所以十分简单。我更喜欢用命名路由跳转而不是使用URL。一开始使用Element还没有注意到他的navmenu是提供了对 Vue Router 的支持的，后来就直接在menu-item上添加需要导向的地方了。其他在 Element 上遇到的坑点之后再说。 &lt;template&gt; &lt;el-menu :default-active=&quot;navbarIndex&quot; mode=&quot;horizontal&quot; :router=&quot;true&quot; :collapse-transition=&quot;true&quot; &gt; &lt;!--Logo--&gt; &lt;img class=&quot;favicon&quot; src=&quot;https://picture-1256456369.cos.ap-shanghai.myqcloud.com/logo.2e928116.png&quot; alt=&quot;Logo&quot;&gt; &lt;el-menu-item index=&quot;1&quot; :route=&quot;{ name: 'lobby'} &quot;&gt; 大厅 &lt;/el-menu-item&gt; &lt;el-menu-item index=&quot;2&quot; :route=&quot;{ name: 'chatroom' }&quot;&gt; 房间 &lt;/el-menu-item&gt; &lt;!--右侧显示用户名--&gt; &lt;div class=&quot;userinfo&quot;&gt;&lt;span&gt;{{username}}&lt;/span&gt;&lt;/div&gt; &lt;/el-menu&gt; &lt;/template&gt; 本来想着可以使用一下命名视图，想想还是算了。 由于使用了Vuex，所以感觉路由传参似乎也是可有可无了，不过也不能这样说，如果参数较少，或是只有一个简单的 Flag，那么使用路由传参显然是代价比较小的方式。这里我没有用过，所以就不提了。 CSS 的一些小 Tips 一开始写的时候发现了一些奇怪的地方，比如我的el-container总是没有办法贴着浏览器的边缘，在Chrome中看到总有8px的margin存在，百度之后发现这是浏览器给的默认样式，可以通过全局样式把它消除掉： * { margin: 0; padding: 0; } 第二个问题，我的侧边栏无法保持和页面等高，总是缩成一小团，很奇怪，这个需要嵌套添加height: 100%样式才能解决，我没有找到更好的方法： html { height: 100%; } body { position: relative; height: 100%; overflow: hidden; } #app { height: 100%; } 第三个问题，我想要让聊天室里面的信息保持在一个高度不变的框里，避免当你信息太多的时候整个页面会刷的很长很长，也就是个滚动条的问题，只要对那个div设置固定的高度，然后设置overflow: auto即可，为了保证信息区域能覆盖页面的剩余区域，只要记得获取一下页面的高度信息即可： chatAreaStyle: { marginBottom: '20px', overflowX: 'hidden', height: '' } mounted() { this.chatAreaStyle.height = (document.body.clientHeight - 280) + &quot;px&quot;; }, 第四个问题，我想要让聊天室获得新消息的时候直接将聊天信息区域滑动到新消息的位置，即最底部，这里出现了一些小问题：因为我是使用&lt;el-tabs&gt;来显示多个聊天界面，而显示聊天信息的组件&lt;MessageArea&gt;是同一个，此问题至今未解决…… ","link":"https://wzhzzmzzy.github.io/post/2019-3-13-Vue聊天室"},{"title":"Scrapy-Splash 使用教程","content":"Scrapy-Splash Splash 是一个模拟浏览器操作的框架，相比较 Selenium 需要实体浏览器而言，Splash 可以作为一个服务使用，更加方便一些。 部署 一般直接使用 Docker 来运行 Splash。 docker run -d -p 8050:8050 scrapinghub/splash 这样就在本地局域网内打开了 Splash 的 Docker 容器。可以将它挂到云服务器上： docker run -d -p 0.0.0.0:8050:8050 scrapinghub/splash 然后直接 HTTP 访问服务器的 8050 端口即可。 使用 进入 Splash 的 Web APP，我们会发现有这样一段代码： function main(splash, args) assert(splash:go(args.url)) assert(splash:wait(0.5)) return { html = splash:html(), png = splash:png(), har = splash:har(), } end 这是一段 Lua 代码，用于限定发起访问的行为。执行上面的main函数后，会获取指定网页的截图、HTML 文档以及网络请求记录。 Lua 脚本 入口和返回值 我们来了解一下 Lua 脚本的入口和执行方式。 function main(splash, args) splash:go(&quot;https://www.baidu.com&quot;) splash:wait(0.5) local title = splash:evaljs(&quot;document.title&quot;) return {title=title} end main函数是 Splash 固定执行的函数名词，evaljs可以执行 JavaScript 脚本。 异步处理 function main(splash, args) local example_urls = {&quot;www.baidu.com&quot;, &quot;www.taobao.com&quot;, &quot;www.zhihu.com&quot;} local urls = args.urls or example_urls local results = {} for index, url in ipairs(urls) do local ok, reason = splash:go('https://' .. url) if ok then splash:wait(2) results[url] = splash:png() end end return results end Splash 内置了异步机制，比如对于wait函数，Splash 会转而执行其他工作。这里还做了一场检测，ok变量是go函数检测页面访问是否正常的标志，如果获取到 4xx 或 5xx 状态码，会跳过下面的访问。 Splash 对象属性 我们会注意到main函数有两个参数，splash类似于 Selenium 中的 WebDriver 对象，可以调用其方法和数学来控制过程。 args 用于获取加载时配置的参数，如 URL，如果是 GET 请求，可以获取 GET 请求参数。如果为 POST 请求，可以获取表单提交的数据。main函数的第二个参数也就是它。 js_enabled 控制是否可以执行 JavaScript 脚本代码，默认为true。 resource_timeout 设置加载的超时时间，如果设置为0或者nil则不检测超时。 images_enabled 这个属性可以设置图片是否加载，默认加载。可以加快加载速度。需要注意的是，这样可能会影响到网页脚本的执行。 plugins_enabled 可以控制浏览器插件（如 Flash）是否开启，默认不开启。 scroll_position 这个属性控制页面上下左右滚动，是个很常用的属性。 Splash 对象方法 go() 这个方法用来请求某个链接，还可以模拟 GET 和 POST 请求，同时支持传入请求头、表单等数据。 ok, reason = splash:go{url, bashurl=nil, headers=nil, http_method=&quot;GET&quot;, body=nil, formdata=nil} 其中body参数用于以 JSON 发送参数，formdata用content-type: application/x-www.form-urlencoded发送参数。 wait() 控制页面等待时间。 ok, reason = splash:wait{time, cancel_on_redirect=false, cancel_on_error=true} 其中，后两个参数表示是否在重定向/错误时停止等待。 jsfunc() 直接用 JavaScript 声明函数，JavaScript 代码需要用双中括号包围。 function main(splash, args) local func = splash:jsfunc([[ function () { var body = document.body; var divs = body.getElementsByTagName('div'); return divs.length; } ]]) splash:go(&quot;https://www.baidu.com&quot;) return (&quot;There are %s DIVs&quot;):format(func()) evaljs() 执行 JavaScript 代码，返回最后一条 JavaScript 语句的执行结果。 result = splash:evaljs(js) runjs() 与evaljs相似，更偏向于执行某些动作或者声明某些方法。 autoload() 负责当之后的每个页面请求时自动加载 JavaScript 代码或库，不执行任何操作。可以调用evaljs或runjs来执行操作。 ok, reason = splash:autoload{source_or_url, source=nil, url=nil} call_later() 此方法用于设定定时任务，设定定时任务后，Splash 会在页面请求之后自动为你执行。 http_get() 模拟 HTTP 发送 GET 请求。 response = splash:http_get{url, headers=nil, follow_redirects=true} http_post() response = splash:http_post{url, headers=nil, follow_redirects=true, body=nil} set_content() 用来直接设置页面内容。 html() 此方法用来获取当前访问的网页源码。 png() 获取 PNG 格式的网页截图。 jpeg() 获取 JPEG 格式的网页截图。 har() 用于获取页面加载过程的网络访问描述。 url() 获取当前正在访问的 URL。 get_cookies() 获取当前页面的 Cookies。 add_cookie() 添加 Cookie。 clear_cookies() 清除所有的 Cookies。 get_viewport_size() 获取当前浏览器页面的大小。 set_viewport_size() 设置浏览器页面大小。 set_user_agent() 设置浏览器的 UA。 set_custom_headers() 设置请求头。 function main(splash) splash:set_custom_headers({ [&quot;User-Agent&quot;] = &quot;Splash&quot;, [&quot;Site&quot;] = &quot;Splash&quot; }) splash:go(&quot;http://httpbin.org/get&quot;) return splash:html() end select() 使用 CSS 选择器选择节点并操作。 select_all() 选中所有符合条件的节点，参数是 CSS 选择器。 mouse_click() 模拟鼠标点击，可以传入坐标，也可以选中某个节点然后直接调用。 Splash API 调用 上面说的方法都是使用 Splash 运行 Lua 脚本，但是这些脚本都是在 Splash 页面中测试运行的，Splash 同样提供了 HTTP API 接口，请求这些接口，传递相应参数即可获得信息。 render.html http://localhost:8050/render.html?url=https://www.baidu.com&amp;wait=2 render.png/render.jpeg http://localhost:8050/render.png?url=http://www.jd.com&amp;wait=5&amp;width=1600&amp;height=900 JPEG 多了一个quality参数，设置图片质量。 render.har 返回 JSON 格式数据，包含页面加载过程中的 HAR 数据。 render.json 支持前面的所有功能，以 JSON 格式返回所有数据。需要启用的 API 就传入相应的参数。 http:;//localhost:8050/render.json?url=http://www.jd.com&amp;png=1 execute 这才是最强大的接口，可以直接和 Lua 脚本对接。 from urllib import parse, request lua_source = &quot;&quot;&quot; function main(splash) return &quot;hello&quot; end &quot;&quot;&quot; res = request.urlopen(&quot;http://118.25.193.162:8050/execute?&quot;+parse.urlencode({ 'lua_source': lua_source })) print(res.read().decode('utf8')) # hello ","link":"https://wzhzzmzzy.github.io/post/2018-8-5-Splash"},{"title":"模拟 HTTP 请求","content":"urllib urllib有四个模块： request，处理请求 error，处理错误 parse，对请求内容解码和编码 robotparser，查看robot.txt 发送请求 request用于发送请求。 urlopen() 示例： import urllib.request res = urllib.request.urlopen(&quot;https://www.python.org/&quot;) print(res.read().decode('utf8')) # get html print(type(res)) # &lt;class 'http.client.HTTPResponse'&gt; print(res.getheader(&quot;Server&quot;)) # 'nginx' print(res.getheaders()) # Response Headers print(res.status) # 200 这个方法也支持表单提交。 import urllib.request import urllib.parse data = bytes(urllib.parse.urlencode({&quot;word&quot;: &quot;hi&quot;}), encoding='utf8') res = urllib.request.urlopen(&quot;https://httpbin.org/post&quot;, data=data) print(res.read().decode('utf8')) Request Request类可以生成完整的请求实例，添加 Headers，指定 Method。 url = &quot;http://httpbin.org/post&quot; headers = { &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_6)&quot;, &quot;Host&quot;: 'httpbin.org' } dict = {'name': 'Amber'} data = bytes(urllib.parse.urlencode(dict), encoding='utf8') req = urllib.request.Request(url=url, data=data, headers=headers, method='POST') res = urllib.request.urlopen(req) print(res.read().decode('utf-8')) 高级用法 生成一个请求，不仅仅会需要 URI、参数、方法和请求头，还需要处理 Cookie、代理等等。生成这样的高级请求就要用到Handler。urllib.request.BaseHandler提供了最基本的方法，可以集成它来自己创建Handler，有一些内置的： HTTPDefaultErrorHandler HTTPRedirectHandler HTTPCookieProcessor ProxyHandle HTTPPasswordMgr HTTPBasicAuthHandler 还有一些其他的，可以查看文档。 另外一个重要的类是OpenerDirector，简称Opener。Opener可以使用open()方法，返回response。我们需要利用Handler来构建Opener。 Cookie 下面是一个利用HTTPCookieProcessor读写 Cookie 的例子： def build_cookie(cookie_file, login_req=None, override=False): &quot;&quot;&quot; 将 Cookies 写入 cookie_file，或从其中读出 Cookies :param cookie_file: Cookie 文件路径 :param login_req: 建立 Cookie 的请求 :param override: 是否覆盖原先的 Cookie 文件 :return: cookie_opener &quot;&quot;&quot; import os from http.cookiejar import LWPCookieJar from urllib.request import HTTPCookieProcessor, build_opener if (not os.path.exists(cookie_file)) or override: if login_req is None: raise Exception(&quot;请给出登陆请求！&quot;) cookie = LWPCookieJar(cookie_file) cookie_opener = build_opener(HTTPCookieProcessor(cookie)) cookie_opener.open(login_req) cookie.save(ignore_expires=True, ignore_discard=True) else: # 直接读取 cookie = LWPCookieJar() cookie.load(cookie_file, ignore_discard=True, ignore_expires=True) cookie_opener = build_opener(HTTPCookieProcessor(cookie)) return cookie_opener 代理 下面是一个利用ProxyHandler实现代理访问的方法： def build_proxy(proxy): &quot;&quot;&quot; 根据 proxy 参数获取代理访问 :param proxy: dict，key 为协议，value 为代理地址 :return: proxy_opener &quot;&quot;&quot; from urllib.request import ProxyHandler, build_opener return build_opener(ProxyHandler(proxy)) 处理异常 urllib提供了URLError和HTTPError，所有request返回的异常都在URLError中。 from urllib import request, error try: response = request.urlopen('https://xxx.com/') except error.HTTPError as e: print(e.reason, e.code, e.headers) except error.URLError as e: print(e.reason) else: print('Request Successfully') 解析链接 URL 中有一些很重要的信息，包括协议、域名、资源地址、参数、查询以及分段。使用parse模块可以对 URL 进行解析。 urlparse可以将 URL 分为协议、域名、资源地址、参数、查询以及分段六块，urlunparse可以将一个六元素列表组织成一个 URL。 urlsplit无视参数项，分解为协议、域名、资源地址、查询以及分段五块，urlunsplit将一个五元素列表组织成一个 URL。 urlencode将一个字典编码为一个 GET 查询字符串。parse_qs将一个 GET 查询字符串解码为字典。 quote将字符串进行 URL 序列化，unquote反之。 分析Robots协议 robotparse模块解析robots.txt，判断爬虫是否有权限对某个页面进行爬取。 def can_fetch(ua, url, robots_url): &quot;&quot;&quot; 查看 UA 是否可以爬取该 URL :param ua: 爬虫 User-Agent :param url: 需要爬取的页面地址 :param robots_url: 主站的 robots.txt :return: Bool &quot;&quot;&quot; from urllib import parse, robotparser robots = robotparser.RobotFileParser(robots_url) robots.read() return robots.can_fetch(ua, url) requests 基本用法 requests可以直接发起对应的 HTTP Method 请求： import requests url = &quot;https://www.baidu.com/&quot; requests.get(url) requests.post(url) requests.put(url) requests.delete(url) requests.options(url) GET 对于 GET 参数，可以直接将字典附加到requests.get()的params参数。对于 API 返回的 JSON，可以直接调用response.json()。可以直接附加 Headers。response的text属性是 Unicode 解码，content属性是二进制。封装的response中还可以获取 Cookies，History，URL，Status_Code import requests headers = { 'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.99 Safari/537.36' } res = requests.get('https://www.zhihu.com/', headers=headers) POST import requests data = {'name': 'germey', 'age': '22'} r = requests.post(&quot;http://httpbin.org/post&quot;, data=data) print(r.json()) 高级用法 文件上传 import requests files = {'file': open('favicon.ico', 'rb')} r = requests.post(&quot;http://httpbin.org/post&quot;, files=files) print(r.text) Cookie import requests res = requests.get(&quot;https://www.baidu.com/&quot;) print(res.cookies) for k, v in r.cookies.items(): print(k, '=', v) 在requests中使用 Cookie，可以像往常一样直接放在 Headers 中，不过稍微有些难看，下面是完整的使用 Cookie 的方式： import requests from http.cookiejar import LWPCookieJar jar = requests.cookies.RequestsCookieJar() cookie = LWPCookieJar() cookie.load(&quot;cookie.txt&quot;) for i in cookie: jar.set(i.name, i.value) Session 上面的维持 Cookie 发起访问的方式相当麻烦，所以requests提供了更好的方法：Session。对于浏览器来说，会话（Session）是无比平常的东西。如果留心的话，在解析网络时经常能发现 Request Headers 总会有keep-alive。事实上，会话是依赖于 Cookie 的，由于 HTTP 是无状态协议，所以使用 Cookie 来标记长连接，也就是会话。 import requests s = requests.Session() s.get(&quot;https://www.baidu.com&quot;) 会话可以看作是urllib的一个 Opener，在一次会话中，会保留 Cookie、代理，因而非常方便。 SSL 证书 requests提供了 SSL 证书验证的功能，如果遇到无法验证的 SSL 证书，可以添加verify=False跳过验证。 代理 import requests proxies = { 'http': 'http://127.0.0.1:1087', 'https': 'https://127.0.0.1:1087' } proxies_socks = { 'http': 'socks5://127.0.0.1:1086', 'https': 'socks5://127.0.0.1:1086' } requests.get(&quot;https://www.google.com&quot;, proxies=proxies) Prepared Request 有可能我们需要一个结构化的请求来多次复用，这时候我们可以使用Request类来生成一个底层的请求对象。一个请求对象可以自己与处理，但是当使用Session时，就需要使用Session去预处理。 from requests import Request, Session url = 'http://httpbin.reg/post' data = { 'name': 'germey' } headers = { 'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.99 Safari/537.36' } s = Session() req = Request('POST', url, data=data, headers=headers) # pre_req = req.prepare() pre_req = s.prepare_request(req) res = s.send(pre_req) print(res.text) 正则 完整讲述正则表达式过于复杂，不如自己理解。常用的正则表达式工具列在下方： 正则表达式测试——开源中国 正则表达式手册——开源中国 正则表达式入门教程 这里我们来说一些 Python3 re 模块的一些使用。 常用函数 修饰符 re.S：使.匹配换行符在内的所有字符； re.I：大小写不敏感； re.M：多行匹配，影响^和$； re.L：本地化识别匹配； re.U：根据 Unicode 解析字符； re.X：可以更灵活地写正则表达式。 一般常用re.S和re.I。 match() 从字符串起始处开始匹配，返回一个match对象，可以使用.group()获取匹配到的内容。 import re url = re.match(&quot;.*?&lt;title&gt;(.*?)&lt;/title&gt;&quot;, res.text) print(url.group(1)) # Google search() 和match()很像，区别是不是固定从开头开始查找。 import re res = re.search('&lt;title&gt;(.*?)&lt;/title&gt;', res.text) print(url.group(1)) findall() 获取所有正则能匹配到的内容。 import re res = re.findall('&lt;a.*?href=&quot;(.*?)&quot;', res.text) print(res) sub() 用正则表达式统一替换。 import re content = '123abc456' content = re.sub('\\d+', '', content) print(content) # abc compile() 获取一个组织完成的正则表达式对象，便于复用。 import re pattern = re.compile('ppp.*?ppp', re.S) ","link":"https://wzhzzmzzy.github.io/post/2018-7-30-模拟 HTTP 请求"},{"title":"网站架构及其演变过程","content":"网站架构及其演变过程 软件的三大类型 单机软件 C/S 结构 Client/Server 结构，客户端与服务器交互。一开始，是由于服务端需要管理一些数据，后来，服务端就不只是管理数据了，也需要处理一些业务逻辑。哪些工作需要放在服务端，哪些工作下放到客户端，就变成了见仁见智的问题。服务端的业务可以提供更好的安全性和稳定性，而且升级起来也比较容易，但是服务端的压力就会变大很多；下放到客户端就会增加安全性和稳定性问题，升级也是一个很大的问题。另外，由于网络 I/O 的巨大开销，通过网络传输的数据应该尽量少。 B/S 结构 服务器变得越来越强大，就有了浏览器，而且一个浏览器可以访问所有同种类型的网站，主要用作展示数据。B/S 结构除了提供统一的客户端还根据相应的协议和标准提供通用的服务器程序。 这就是软件的三大类型，各有特点。B/S 类型开发简单，使用方便，功能强大，所以现在使用最广泛。 基础结构并不简单 B/S 结构是最基础的结构，但是依然十分复杂。B/S 结构网络传输的分解方式有两种，一种是标准的 OSI 参考模型，一种是 TCP/IP 模型。 OSI 分为七层：应用层、表示层、会话层、传输层、网络层、数据链路层、物理层。这于 TCP/IP 是对应的，应用、表示、会话对应应用层，传输层对应传输层，网络层对应网络互联层，数据链路、物理层对应网络接入层。 OSI 参考模型较为复杂，一般来说，TCP/IP 四层模型更好理解： 网络接入层：将需要连接的节点接入网络，为数据传输提供条件； 网络互联层：找到要传输数据的目标节点； 传输层：实际传输数据； 应用层：使用接收到的数据。 稍微解释一下，网络接入层就是交通网络，数据包在这里传递，网络互联层是我们的地址，传输层是我们拿到数据包的地方，然后应用层拆包使用数据。 每一层都有自己的协议族，TCP/IP 协议族就泛指他们。简单理解的话，网际互联层是 IP 协议，传输层是 TCP 协议，应用层是 HTTP 协议。另外，在 B/S 结构中还使用到了 DNS 协议，而且在 HTTP 协议之上还有其他的规范，比如 Python 的 WSGI、Java Web 的Servlet 等等。 数据传输本质大家都知道，是按照晶体振动周期或者其整数倍来传输代表 0/1 的高低电平，传输过程中最为关键的就是各种传输协议，对硬件来说是总线协议，对网络来说就是网络传输协议。要开发一个如前面所述的 B/S 结构系统并非难事，但是这样的系统并不好用，除了用户交互之外，最重要的问题就是速度问题。比如 12306 的购票系统。虽然这个系统已经花了很大力气去优化，但是依然只能说是堪堪可用的地步。解决速度问题的核心就是解决海量数据操作和高并发问题，网站复杂的架构就是从这两个问题演变出来的。 海量数据的解决方案 无论是企业的业务系统还是互联网的网站程序，都面临着数据量大的问题，如果解决不好就严重影响着系统的运行速度。不过，也有着很多的解决方案 缓存和页面静态化 数据量大这个问题最直接的使用方案就是使用缓存。缓存就是将数据库中获取的结果暂时保存起来，下次使用的时候不用再到数据库里去获取，这样可以大大减少数据库服务器的压力，也避免了瓶颈的出现。 缓存的使用方式可以分为直接保存到内存和使用缓存框架两种。直接操作主要是使用Map，尤其是ConcurrentHashMap。常用的缓存框架有Ehcache，Memcache和Redis。缓存使用过程中，最重要的问题是什么时候创建缓存，和缓存的失效机制。缓存可以在第一次获取的时候创建，也可以在程序启动和缓存失效之后立即创建，缓存的失效还可以定期失效，也可以是数据发生变化时立即失效，数据发生变化时失效还有着粒度大小的区分。 对于空数据，缓存应该有一个特别的标识符或者类型来保存，避免每次都因为缓存为空而访问数据库。 缓存同样也有缺点，它只适用于数据变化不是很频繁的情况。 与缓存相似的另一种技术叫做页面静态化，原理上和缓存很相似，页面静态化就是将最后一次访问的页面保存起来，不用每次都调用生成新的页面了。不但不需要查库，连应用程序处理都不用了。 页面静态化可以使用模板生成，也可以使用缓存服务器在应用服务器的上一层缓存生成的页面，比如使用Squid，另外 Nginx 也提供了相应的功能。 数据库优化 要解决数据量问题，数据库优化是必不可少的一环。数据库优化方法很多，表结构、SQL 语句、分区和分表、索引优化、使用存储过程代替直接操作等，有时候合理使用冗余也能获得很好的效果。 表结构优化 表结构优化是数据库中最基础也是最重要的，但也是最复杂的，不细说。 SQL 语句优化 基础的 SQL 优化是在语法层面，更重要的是逻辑层面，也需要根据实际情况具体处理，而且要和索引缓存配合使用。不过有一个通用的做法：将涉及大数据业务的 SQL 语句执行时间详细记录下来，其次通过仔细分析日志找出需要优化的语句和其中的问题，然后再有的放矢地优化，而不是不分重点对每条语句都花同样的时间和精力优化。 分区 数据量变大，如果可以分区或者分表，可以起到很好的效果。一张表中的数据量很大，操作速度就会变慢，就可以用多张表中保存。但是多张表会造成操作的麻烦，所以可以通过分区来达到目的。分区就是将一张表中的数据按照一定的规则分到不同的区来保存。 分表 如果一张表中的数据可以分为几种固定不变的类型，而且同时对多种类型共同操作的次数不多，那么都可以通过分表来处理。 索引优化 索引就是为数据表的某一个字段建立一张列表，记录字段值与物理位置的映射，加快查询的速度。索引增加查询的时候降低了数据操作（增删改）的速度，因为数据变化的时候需要更新相关的索引。所以需要多添加一些测试。 使用存储过程代替常用操作 存储过程只需要单次编译，而且可以在存储过程中做一些复杂的操作，比直接操作高效很多。 分离活跃数据 有时候，数据总量很大，但是活跃数据并不多，这种情况就可以将活跃数据单独保存起来从而提高处理效率。比如，对网站来说，活跃用户只占总用户的一小部分，这时候就可以给活跃用户一张特殊的表，找不到再到不活跃用户表中去查找。 批量读取和延迟修改 批量读取和延迟修改的原理是通过减少操作次数来提高效率，如果使用恰当，效率将会有非常大的提高。 批量读取是将多次查询合并到一次中进行，如果每保存一条记录都查询一次数据库，那么对每个需要检查的字段，都需要查询与要保存的记录条数相同次数的数据库，这时候可以先将所有要保存的数据的相应字段读取到一个变量中，然后使用in语句统一查询数据库。 延迟修改主要针对高并发而且频繁修改的数据，比如一些统计数据。这种情况可以先将需要修改的数据暂时保存到缓存中，然后定时将缓存中的数据保存到数据库中，程序在读取数据时可以同时读取数据库中和缓存中的数据。 读写分离 读写分离的本质是对数据库进行集群，这样就可以在高并发的情况下将数据库的操作分配到多个数据库服务器去处理，从而降低单台服务器的压力了，不过由于数据库的特殊性——每台服务器所保存的数据都需要一致，所以数据同步就成了数据库集群中最核心的问题。这个问题当多台服务器可以进行写数据时数据同步变得更加复杂，所以一般将写操作交给一台主服务器来处理，然后同步到多台从服务器中。如果从服务器数量多，那么可以让主服务器先向其中一部分从服务器同步数据，第一部分从服务器接收到数据后向另一部分同步。 读写分离还需要考虑负载均衡问题，需要专门的软硬件配合。 分布式数据库 分布式数据库是将不同的表存放到不同的数据库中，然后再存放到不同的服务器。这样再处理请求时，如果需要调用多个表，可以让多台服务器同时处理，提高处理的速度。 数据库集群（读写分离）的作用是将多个请求分配到不同的服务器处理，从而减轻单台服务器的压力，而分布式数据库是解决单个请求本身就很复杂的问题，它可以将单个请求分配到多个服务器处理，使用分布时候，每个节点还可以同时使用读写分离，从而组成多个节点群。 实际情况中，分布式数据库有很多复杂的问题需要解决，比如事务处理、多表查询等等。分布式的另一种思路是，将不同业务的数据表保存到不同的节点，让不同的业务调用不同的数据库，这种用法其实是和集群一样起到了分流的作用，不过这种情况就不需要同步数据了。 NoSQL 和 Hadoop NoSQL 是近年非常火热的一门技术，发展十分迅速，其核心思想就是非结构化。它与关系型数据库不同，不需要事先定义表结构，突破了数据库范式的制约，非常灵活。另外，由于通过多个快存储数据的特点，操作大数据的速度也非常快。关系型数据库的特点就是强一致性，而 NoSQL 舍弃了强一致性，换取了关系型数据库无法获得的高并发下的高速查询能力。这正是现代互联网所需要的。 Hadoop 是专门针对大数据处理的一套框架。Hadoop 对数据存储和处理都提供了相应的解决方案，思路和前面讲的分布式数据库和集群的方案类似，不过 Hadoop 是将同一个表的数据分为多块保存到多个节点，而且一块数据都有多个节点保存，这里的集群不但可以并行处理，还保证了数据的有效冗余，避免数据的损失。 Hadoop 对数据的处理是先对每一块数据找到相应的节点并进行处理，然后对每一个处理的结果进行处理，生成最终的结果。 高并发的解决方案 除了数据量大，还有一个常见的问题就是并发量高，很多架构就是为这个问题而设计的。 应用和静态资源分离 在 B/S 架构中，很多应用程序和静态资源一开始是放在一起的，为了应对高并发，简单的静态资源（图片、视频、JavaScript 脚本、CSS 样式表和一些资源文件）可以被放到其他的专门的服务器上，因为这些文件没有状态，所以分离比较简单。通过不同的域名可以让浏览器直接访问资源服务器而不是应用服务器。 页面缓存 上面已经详细叙述过了，这里再多说一个点，对于某一小块数据经常变化的页面，可以先生成静态页面，然后用 AJAX 或者 Fetch API 等方法动态获取数据。 集群与分布式 集群是每台服务器都有相同的功能，主要起到分流的作用，分布式是将不同的业务放到不同的服务器上，用来提高单个请求的处理速度。 集群有两个方式：静态资源集群、应用程序集群。静态资源集群比较简单，应用程序集群就比较复杂了。因为应用程序在处理过程中可能会使用到一些缓存的数据，如果集群就需要同步这些数据。其中最重要的就是session，session同步也是就应用程序集群中一个非常核心的问题。session同步有两种处理方式，一种是在session发生变化后自动同步到其他服务器，另一种方式是用一个程序统一管理session。所有集群的服务器都是用同一个session。 还有一种思路来简单解决session同步问题：session需要同步是因为需要让不同的服务器为一个用户提供服务，如果负载均衡在分配请求时可以将同一个用户分配到同一台服务器进行处理，也就不需要session同步了，这种方法一般也不会对负载均衡带来太大的问题。 反向代理 反向代理指的是客户端直接访问服务器并不真正提供服务，从别的服务器获取资源然后将结果返回给用户。 反向代理服务器可以和实际处理请求的服务器在一台主机上，而且一台反向代理服务器也可以访问多台实际处理请求的服务器。反向代理服务服务器主要有三个作用： 可以作为前端服务器跟实际处理请求的服务器（如 Tomcat、uwsgi）集成； 可以用做负载均衡； 转发请求，将不同类型的资源请求转发到不同的服务器处理。 CDN CDN 其实是一种特殊的集群页面缓存服务器，和普通集群的多台页面缓存服务器比，主要是它存放的位置和分配请求的方式有点特殊。CDN 服务器是分布在全国各地的，根据用户请求的位置选择最合适的 CDN 服务器节点获取数据。CDN 的每个节点其实就是一个页面缓存服务器，如果没有请求资源的缓存，就会从主服务器获取，否则直接返回缓存的页面。CDN 分配请求的方式比较特殊，并不是普通的负载均衡服务器，而是专门的 CDN 域名解析服务器在解析域名的时候就分配好的，一般的做法是从 ISP （互联网服务提供商）那里使用 CNAME 将域名解析到一个特别的域名，然后再解析到专门的 CDN 服务器，到相应的 CDN 节点。 底层优化 前面讲了这么多架构，都是建立在最开始讲到的 TCP/IP 模型之上的。如果可以加快网络传输速度，那么就可以从根本上加快整个系统的运转。网络传输是根据各种协议来完成的，但是协议也不是不可以更改，Google 就是用了 Quic、Spdy 等新的协议来传输数据，Quic 比 TCP 效率高 而比 UDP 更安全。现在，Spdy 有些特性包含到了 HTTP/2 中，Google 已经转向了 HTTP/2 。 小结 网站架构的整个演变过程主要是围绕大数据和高并发两个问题展开的，解决的方案主要分为使用缓存和使用多资源两种类型。多资源指的是多存储、多处理器、多网络，对于多资源来说又分为单资源处理一个请求，和多资源合作处理一个请求。 网站具体需要使用什么样的架构，需要根据实际需要做出选择。要注意，使用复杂架构之前要把自己的业务优化好，这是基础中的基础。 ","link":"https://wzhzzmzzy.github.io/post/2018-7-14-网站架构及其演变"},{"title":"操作系统笔记（四）：网络编程","content":"网络编程 IP Internet IP 地址 一个 IP 地址是一个 32 位无符号整数。 struct in_addr { unsigned int s_addr; } 为什么要用结构体来存放标量 IP 地址？ 把一个标量地址存放在结构中，是套接字接口早期实现的不幸产物。为 IP地址定义一个标量类型应该更有意义，但是现在更改已经太迟了，因为已经有大量应用是基于此的了。 因为因特网主机可以有不同的主机字节顺序，TCP/IP 为任意整数数据项定义了统一的网络字节顺序，大端字节顺序。 Unix 提供了下面的函数在网络和主机字节顺序之间实现转换： #include &lt;netinet/in.h&gt; unsigned long int htonl(unsigned long int hostlong); unsigned short int htons(unsigned short int hostshort); unsigned long int ntohl(unsigned long int netlong); unsigned short int ntohs(unsigned long int netshort); 因特网域名 我们可以通过调用gethostbyname和gethostbyaddr，从 DNS 数据库中检索任意的主机条目。 #include &lt;netdb.h&gt; struct hostent *gethostbyname(const char *name); struct hostent *gethostbyaddr(const char *addr, int len, 0); gethostname返回与域名name相关的主机条目，gethostbyaddr返回与 IP 地址addr相关的主机条目。第二个参数给出了一个 IP 地址的字节长度。 套接字接口 套接字接口是一组函数，他们和 Unix I/O 函数结合，用以创建网络应用。 从 Unix 内核的角度看，套接字是通信的一个端点，从 Unix 程序的角度看，套接字就是一个有相应描述符的打开文件。 因特网的套接字地址存放在类型为sockaddr_in的 16 字节结构中。 struct sockaddr { unsigned short sa_family; char sa_data[14]; } // socket.h struct socketaddr_in { unsigned short sin_family; // AF_INET unsigned short sin_port; // Port number struct in_addr sin_addr; // IP address unsigned char sin_zero[8]; // Pad to sizeof(struct sockaddr) } // netinet/in.h connect、bind、accept函数要求一个指向与协议相关的套接字地址结构的指针。 socket函数 客户端和服务器使用socket函数来创建一个套接字描述符。 #include &lt;sys/types.h&gt; #include &lt;sys/socket.h&gt; int socket(int domain, int type, int protocol); clientfd = Socket(AF_INET, SOCK_STREAM, 0); AF_INET表示使用 IPv4 协议，SOCK_STREAM表示套接字是因特网连接的一个端点。现在获得的描述符并不能读写。读写之前，客户端和服务器有着分别的打开工作。 connect函数 客户端通过connect函数来建立与服务器的连接。 #include &lt;sys/socket.h&gt; int connect(int sockfd, struct sockaddr *serv_addr, int addrlen); 试图连接时，connect函数会阻塞，一直到连接成功或是发生错误。得到的连接是：(x:y, serv_addr.sin_addr:serv_addr.sin_port)。 open_clientfd函数 将socket和connect函数包装成一个open_clientfd的辅助函数是很方便的，客户端可以用它来和服务器建立连接。 #include &quot;csapp.h&quot; int open_clientfd(char *hostname, int port); int open_clientfd(char *hostname, int port) { int clientfd; struct hostent *hp; struct sockaddr_in serveraddr; if ((clientfd = socket(AF_INEF, SOCK_STREAM, 0)) &lt; 0) return -1; if ((hp = gethostbyname(hostname)) == NULL) return -2; bzero((char *) &amp;serveraddr, sizeof(serveraddr)); serveraddr.sin_family = AF_INET; bcopy((char *)hp-&gt;h_addr_list[0], (char *)&amp;serveraddr.sin_addr.s_addr, hp-&gt;h_length); serveraddr.sin_port = htons(port); if (connect(clientfd, (SA *)&amp;serveraddr, sizeof(serveraddr)) &lt; 0) return -1; return clientfd; } bind、listen、accept 这三个函数用于服务器端和客户端之间建立连接。 #include &lt;sys/socket.h&gt; int bind(int sockfd, struct sockaddr *my_addr, int addrlen); int listen(int sockfd, int backlog); int accept(int listenfd, struct sockaddr *addr, int *addrlen); bind函数告诉内核将my_addr中的服务器套接字和套接字描述符sockfd联系起来，参数addrlen就是sizeof(sockaddr_in)。 listen函数告知内核，使用套接字的是服务器而非客户端，将sockfd从主动套接字转化为监听套接字，backlog暗示了内核在开始拒绝连接请求之前，应该放入队列中等待的未完成连接的数量。 我们可以用open_listenfd函数来整合socket\\bind\\listen三个函数。 #include &quot;csapp.h&quot; int open_listenfd(int port); int open_listenfd(int port) { int listenfd, optval=1; struct sockaddr_in serveraddr; if ((listenfd = socket(AF_INET, SOCK_STREAM, 0)) &lt; 0) return -1; if (setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, (const void *)&amp;optval, sizeof(int)) &lt; 0) return -1; bzero((char *)&amp;serveraddr, sizeof(serveraddr)); serveraddr.sin_family = AF_INET; serveraddr.sin_addr.s_addr = htonl(INADDR_ANY); serveraddr.sin_port = htons((unsigned short)port); if (bind(listenfd, (SA *)&amp;serveraddr, sizeof(serveraddr)) &lt; 0) return -1; if (listen(listenfd, LISTENQ) &lt; 0) return -1; return listenfd; } accept函数用于等待客户端的连接请求到达监听描述符listenfd，然后在addr中填写客户端的套接字地址，返回一个已连接描述符，可以用来利用 Unix I/O 函数与客户端通信。 服务器调用accept，等待连接； 客户端调用connect，发送一个连接请求到listenfd； accept打开了一个新的已连接描述符connfd，在clientfd和connfd之间建立连接，随后返回connfd给应用程序。客户端页从connect返回。 监听描述符和已连接描述符的区别 之所以accept要重新打开一个已连接描述符，是为了支持服务器的并发访问。如果只有一个监听描述符，就无法fork新的进程。 Web Server WEB 传输的内容是 MIME 类型相关的字节序列。WEB 服务器以两种不同的方式向客户端提供内容： 取一个磁盘文件，将内容返回给客户端，磁盘文件称为静态内容。 运行一个可执行文件，将输出返回给客户端，运行时产生的输出称为动态内容。 要实现一个简单的 Web Server，只有简单的几步要完成： 打开监听套接字： listenfd = Open_listenfd(port); 进入无限循环，打开已连接套接字，开始处理 HTTP 事务： while (1) { clientlen = sizeof(clientaddr); connfd = Accept(listenfd, (SA *)&amp;clientaddr, &amp;clientlen); // 打开已连接套接字 doit(connfd); // 处理 HTTP 事务 Close(connfd); } 处理 HTTP 事务，对 HTTP 请求进行解析，获取 METHOD、URI、协议版本： Rio_readinitb(rio, fb); // 初始化 rio 读写缓冲区 Rio_readlineb(rio, buf, MAXLINE); sscanf(buf, &quot;%s %s %s&quot;, method, uri, version); 解析 HTTP METHOD，对 GET 以外的请求返回 501；解析 URI，判断静态请求或动态请求，解析 CGI 参数，对不存在的静态文件返回 404；解析请求头，不作处理，直接输出： if (strcasecmp(method, &quot;GET&quot;)) { // 当遇到 GET 以外的 METHOD 时，给出 501 clienterror(fd, method, &quot;501&quot;, &quot;Not Implemented&quot;, &quot;Tiny does not implement this method&quot;); return; } read_requesthdrs(&amp;rio); // 获取 Request Headers is_static = parse_uri(uri, filename, cgiargs); // 获取 CGI 需要的参数以及静态文件名 if (stat(filename, &amp;sbuf) &lt; 0) { // 查看文件状态 clienterror(fd, filename, &quot;404&quot;, &quot;Not found&quot;, &quot;Tiny couldn't find this file&quot;); return; } 这里使用到了返回错误的clienterror，直接向socket写入报错信息即可： void clienterror(int fd, char *cause, char *errnum, char *shortmsg, char *longmsg) { char buf[MAXLINE], body[MAXBUF]; /* Build the HTTP response body */ sprintf(body, &quot;&lt;html&gt;&lt;title&gt;Tiny Error&lt;/title&gt;&quot;); sprintf(body, &quot;%s&lt;body bgcolor=&quot;&quot;ffffff&quot;&quot;&gt;\\r\\n&quot;, body); sprintf(body, &quot;%s%s: %s\\r\\n&quot;, body, errnum, shortmsg); sprintf(body, &quot;%s&lt;p&gt;%s: %s\\r\\n&quot;, body, longmsg, cause); sprintf(body, &quot;%s&lt;hr&gt;&lt;em&gt;The Tiny Web server&lt;/em&gt;\\r\\n&quot;, body); /* Print the HTTP response */ sprintf(buf, &quot;HTTP/1.0 %s %s\\r\\n&quot;, errnum, shortmsg); Rio_writen(fd, buf, strlen(buf)); sprintf(buf, &quot;Content-type: text/html\\r\\n&quot;); Rio_writen(fd, buf, strlen(buf)); sprintf(buf, &quot;Content-length: %d\\r\\n\\r\\n&quot;, (int)strlen(body)); Rio_writen(fd, buf, strlen(buf)); Rio_writen(fd, body, strlen(body)); } 对于静态文件，直接打开并写入socket即可，无法访问返回 403： if (is_static) { /* Serve static content */ if (!(S_ISREG(sbuf.st_mode)) || !(S_IRUSR &amp; sbuf.st_mode)) { clienterror(fd, filename, &quot;403&quot;, &quot;Forbidden&quot;, &quot;Tiny couldn't read the file&quot;); return; } serve_static(fd, filename, sbuf.st_size); } 对于动态请求处理，运行相应的cgi-bin目录下的程序，给出参数即可： else { /* Serve dynamic content */ if (!(S_ISREG(sbuf.st_mode)) || !(S_IXUSR &amp; sbuf.st_mode)) { clienterror(fd, filename, &quot;403&quot;, &quot;Forbidden&quot;, &quot;Tiny couldn't run the CGI program&quot;); return; } serve_dynamic(fd, filename, cgiargs); } 至此，一个简单的本地 Web Server 就完成了。 ","link":"https://wzhzzmzzy.github.io/post/2018-7-14-网络编程"},{"title":"操作系统笔记（三）：虚拟存储器","content":"虚拟存储器 为了更加有效地管理存储器并且少出错，现代系统提供了一种对主存的抽象概念，叫做虚拟存储器。虚拟存储器是硬件异常、硬件地址翻译、主存、磁盘文件和内核软件的完美交互，它为每个进程提供了一个大的、一致的和私有的地址空间。通过一个很清晰的机制，虚拟存储器提供了三个重要的能力： 它将主存看成是一个存储在磁盘上的地址空间的高速缓存，在主存中只保存活动区域，并根据需要在磁盘和主存之间来回传送数据，通过这种方式，它高效地使用了主存。 它为每个进程提供了一致的地址空间，从而简化了存储器管理。 它保护了每 个进程的地址空间不被其他进程破坏。 虚拟存储器作为缓存的工具 虚拟存储器被组织为一个由存放在磁盘上的 N 个连续的字节大小的单元组成的数组。每字节都有一个唯一的虚拟地址，这个唯一的虚拟地址是作为到数组的索引的。磁盘上数组的内容被缓存在主存中。 虚拟存储器被分为一定大小的块，这些块称为虚拟页，类似的，物理存储器被分割为物理页。 可以将主存看作磁盘的缓存，那么虚拟存储就能在主存上获得缓存。 DRAM 缓存的组织结构 SRAM 缓存指的是 CPU 和主存之间的高速缓存，DRAM 缓存表示虚拟存储器系统的缓存，它在主存中缓存虚拟页。 由于 DRAM 缓存未命中时有着巨大的不命中开销，所以DRAM 缓存时全相连的，也就是说，任何虚拟页都可以放置在任何的物理页中。 页表 虚拟存储器系统必须有某种方法来判定一个虚拟页是否存放在 DRAM 中 的某个地方。如果是，系统还必须确定这个虚拟页存放在哪个物理页中。如果不命中，系统必须判断这个虚拟页存放在磁盘的哪个位置，在物理存储器中选择一个牺牲页，并将虚拟页从磁盘拷贝到 DRAM 中，替换这个牺牲页。 页表提供了虚拟页到物理页到映射。 缺页 DRAM 缓存不命中称为缺页。缺页异常调用内核中的缺页异常处理程序，选择一个牺牲页。磁盘和存储器之间传送页到活动叫做交换或者页面调度。在正常使用时，主存会一直等待，直到有不命中发生时，才会换入页面，这种策略称为按需页面调度。 局部性 局部性是程序十分重要的一个特性，尽管在整个运行过程中，程序引用的不同页面的总数可能超出物理存储器总的大小，但是局部性原则保证了在任意时刻，程序将往往在一个较小的活动页面集合上工作，这个集合叫做工作集。 只要我们的程序有好的时间局部性，虚拟存储器系统就能工作得相当好。 虚拟存储器作为存储器管理的工具 虚拟存储器简化了存储器管理，并提供了一种自然的保护存储器的方法。 操作系统为每个进程提供一个独立的页表，因而也就是一个独立的虚拟地址空间。 独立的地址空间允许每个进程的存储器映像使用相同的基本格式，而不管代码和数据实际存放在物理存储器的何处。 虚拟存储器还使得容易向存储器中加载可执行文件和共享对象文件。 虚拟存储器简化了向用户进程提供一个简单的分配额外存储器的工作。 独立地址空间为操作系统提供了一个管理用户进程和操作系统自身之间共享的一致机制。 地址翻译 形式上来说，地址翻译是一个 N 元素的虚拟地址空间中的元素和一个 M 元素的物理地址空间中元素之间的映射。 页面命中时，CPU 执行如下步骤： 处理器生成虚拟地址，传给 MMU； MMU 生成 PTE 地址，从缓存请求得到它； 缓存向 MMU 返回 PTE； MMU 构造物理地址，传送给缓存； 缓存返回请求的数据字给处理器。 页面命中完全由硬件处理，缺页则要求硬件和系统内核协作完成。 处理器生成虚拟地址，传给 MMU； MMU 生成 PTE 地址，从缓存请求得到它； 缓存向 MMU 返回 PTE； PTE 中的有效位数零，所以 MMU 触发了一次异常，传递 CPU 中的控制到系统内核中的缺页异常处理程序。 缺页处理程序确定出物理存储器中的牺牲页，如果这个页面已经被修改了，就把它换出磁盘。 利用 TLB 加速地址翻译 正如我们看到的，每次 CPU 产生一个虚拟地址， MMU 就必须查阅一个 PTE, 以便将虚拟地址翻译为物理地址。在最糟糕的情况下，这又会要求从存储器取一次数据，代价是几十到几百个周期。如果 PTE 碰巧缓存在 L1 缓存中，那么开销就下降到 1 个或 2 个周期。 系统在 MMU 中包括了一个关于 PTE 的小的缓存，称为翻译后备缓冲器。 TLB 是一个小的、虚拟寻址的缓存，其中每一行都保存着一个由单个 PTE 组成的块。当 TLB 命中时，MMU 的翻译步骤会变得非常快。 存储器映射 Linux (以及其他一些形式的 Unix) 通过将一个虚拟存储器区域与一个磁盘上的对象关联起来，以初始化这个虚拟存储器区域的内容，这个过程称为存储器映射。虚拟存储器区域可以映射到两种类型的对象中的一种： Unix 文件系统中的普通文件； 匿名文件:一个区域也可以映射到一个匿名文件，匿名文件是由内核创建的，包含的全是二进制零。 一个对象可以被映射到虚拟存储器的一个区城，要么作为共享对象，要么作为私有对象。如果一个进程将一个共享对象映射到它的虚拟地址空间的一个区域内，那么这个进程对这个区域的任何写操作，对于那些也把这个共享对象映射到它们虚拟存储器的其他进程而言也是可见的。而且，这些变化也会反映在磁盘上的原始对象中。 另一方面，对一个映射到私有对象的区域做的改变，对于其他进程来说是不可见的，并且进程对这个区域所做的任何写操作都不会反映在磁盘上的对象中。一个映射到共享对象的虚拟存储器区域叫做共享区域。类似地，也有私有区域。 私有对象有一种特别的机制叫做写时拷贝。两个进程将一个私有对象映射到它们虚拟存储器的不同区域，但是共享这个对象的同一个物理拷贝。对于每个映象私有对象的进程，相应私有区域的页表条目都被标记为只读。并且区域结构被标记为私有的写时拷贝。 再看fork函数 既然我们理解了虚拟存储器和存储器映射，那么我们可以清晰地知道fork函数是如何创建一个带有自己独立虚拟地址空间的新进程的。 当fork函数被当前进程调用时，内核为新进程创建各种数据结构，并分配给它一个唯一的 PID。为了给这个新进程创建虚拟存储器，它创建了当前进程的mm_struct、区域结构和页表的原样拷贝。它将两个进程中的每个页面都标记为只读，并将两个进程中的每个区域结构都标记为私有的写时拷贝。 当fork在新进程中返回时，新进程现在的虚拟存储器刚好和调用fork时存在的虚拟存储器相同。当这两个进程中的任一个后来进行写操作时，写时拷贝机制就会创建新页面，因此，也就为每个进程保持了私有地址空间的抽象概念。 系统级 I/O 所有语言的运行时系统都提供执行 I/O 的较高级别的工具，包含像printf和scanf这样带缓冲区的 I/O 函数。这些高级 I/O 函数都是由系统级 Unix I/O 函数来实现的。 Unix I/O 一个 Unix 文件就是一个 m 个字节的序列。所有的 I/O 设备，比如网络、磁盘、终端，都被模型化为文件。Unix I/O 就是一个统一的应用接口。 一个应用程序通过要求内核打开相应的文件来宣告它想要访问一个 I/O 设备。内核返回一个小的非负整数，叫做描述符。在后续的文件操作中，描述符用于标识这个文件。 打开和关闭文件 进程通过调用open函数来打开一个已存在的文件或者创建一个新文件。 #include &lt;sys/types.h&gt; #include &lt;sys/stat.h&gt; #include &lt;fcnt1.h&gt; int open(char *filename, int flags, mode_t mode); open函数将filename转换为一个文件描述符，并且返回描述符数字，flags参数指明如何访问这个文件，mode参数指定了新文件的访问权限位。 读写文件 应用程序是通过分别调用read和write函数来执行输入和输出的。 #include &lt;unistd.h&gt; ssize_t read(int fd, void *buf, size_t n); ssize_t write(int fd, const void *buf, size_t n); read函数从描述符为fd的当前文件位置拷贝最多n个字节到存储器位置buf。返回值-1表示一个错误，而返回值0表示 EOF。否则，返回值表示的是实际传送的字节数量。 write函数从存储器位置buf拷贝至多n个字节到描述符fd的当前文件位置。 标准 I/O ANSI C 定义了一组高级输入输出函数，称为标准 I/O 库，为程序员提供了 Unix I/O 的较高级别的替代。这个库提供了打开和关闭文件的函数 (fopen和fclose、读和写字节的函数 (fread和fwrite)、读和写字符串的函数 (fgets和fputs), 以及复杂的格式化的 I/O 函数 (scanf和printf)。 标准 I/O 库将一个打开的文件模型化为一个流。对于程序员而言，一个流就是一个指向 FILE 类型的结构的指针。 #include &lt;stdio.h&gt; extern FILE *stdin; extern FILE *stdout; extern FILE *stderr; 流和套接字的限制 流的输入输出是有限制的。 跟在输出函数之后的输入函数。如果中间没有插入对fflush、fseek、fsetpos或者rewind的调用，一个输入函数不能跟随在一个输出函数之后。fflush函数清空与流相关的缓冲区。后三个函数使用 Unix I/Olseek函数来重置当前的文件位置。 跟在输入函数之后的输出函数。如果中间没有插入对fseek、fsetpos或者rewind的调用，一个输出函数不能跟随在一个输入函数之后，除非该输入函数遇到了一个 EOF。 这些限制同样适用于套接字，但是对套接字使用lseek是非法的。对流的第一个限制能够采用刷新缓冲区来满足，第二个限制只能通过对同一个套接字打开两个流来满足。 FILE *fpin, *fpout; fpin = fdopen(sockfd, &quot;r&quot;); fpout = fdopen(sockfd, &quot;w&quot;); 这里就有些麻烦，两个流都需要被关闭，而且关闭时都会试图关闭同一个套接字描述符，所以第二个操作就会失败。因此，在网络套接字上，不应该使用标准 I/O 来输入输出。 ","link":"https://wzhzzmzzy.github.io/post/2018-7-13-虚拟存储器"},{"title":"操作系统笔记（二）：异常控制流","content":"异常控制流 程序需要对程序状态的变化作出反应，所以需要跳转、调用、返回这样的一些程序指令。系统也必须能够对系统状态的变化作出反应，这些系统状态不是被内部程序变量捕获的，而且也不一定要和程序执行相关。 现代系统通过控制流突变来对情况作出反应，这种突变称为异常控制流。异常控制流发生在系统的各个层次。 异常 异常是异常控制流的一种形式，一部分由硬件实现，一部分由操作系统实现。异常就是控制流的突变，用来响应处理器状态中的某些变化。在处理器中，状态被编码为不同的位和信号，状态变化就称为事件。事件可能和当前指令的执行直接相关，也可能无关。 当事件发生时，处理器会通过异常表，进行一次间接过程调用，到异常处理程序当中。 异常处理 系统中可能的每种类型的异常都分配来一个唯一的异常号。异常类似于过程调用，但是有一些重要的不同之处。 过程调用时，处理器会先将返回地址压栈，但是根据异常的类型，返回地址要么时当前指令，要么是下一条指令。 处理器也把一些额外的处理器状态压栈，如标志位等，重新开始被中断的程序会需要这些状态。 如果控制从一个用户程序转移到内核，那么所有这些项目都被压到内核栈中，而不是用户栈。 异常处理程序运行在内核模式下，也就是说它们对所有的系统资源都有完全的访问权限。 一旦硬件触发了异常，剩下的工作由异常处理程序在软件中完成。 异常的类别 异常分为四类：中断、陷阱、故障、终止。 中断 中断是异步的，是来自处理器外部的 I/O 设备信号的结果。硬件中断不是由任何一条专门的指令造成的。硬件中断的异常处理程序通常称为中断处理程序。 陷阱和系统调用 陷阱是有意的异常，是执行指令的结果。陷阱最重要的用途是在用户程序和内核之间提供一个像过程一样的接口，叫做系统调用。 用户程序经常需要向内核请求服务，比如read、fork、execve、exit等等。为了允许这些对内核服务的访问，处理器提供了syscall n指令。执行syscall指令会导致一个到异常处理程序的陷阱。从程序猿的角度看，系统调用和普通的函数调用说一样的，然而，实现非常不同。系统调用运行在内核模式中。 故障 故障由错误情况引起。能够被故障处理程序修正。一个经典的故障实例是缺页。当发生缺页异常时，我们需要从磁盘中取出缺少的物理页面。 终止 终止时不可恢复的致命错误造成的结果，通常是一些硬件错误，比如 RAM 位被损坏时发生的奇偶错误。终止处理程序从不将控制返回给应用程序。 Linux/IA32 系统中的异常 IA32 系统定义中，有高达 256 种不同的异常类型。0～31 对应 Intel 架构师定义的异常，32～255 对应操作系统定义的中断和陷阱。 Linux/IA32 故障和终止 除法错误、一般保护故障、缺页、机器检查。 Linux/IA32 系统调用 Linux 提供上百种系统调用，用于请求内核服务。在 IA32 系统上，系统调用通过int n的陷阱命令来提供。在 C 中，我们可以用syscall直接调用任何系统调用，但是几乎没必要这么做。对于大多数系统调用，标准 C 库提供了一组方便的包装函数。这些函数称为系统级函数。 举一个简单的例子，是输出 Hello world 的程序： int main() { write(1, &quot;hello, world\\n&quot;, 13); exit(0); } write函数的第一个参数是将输出发送到stdout，第二个参数是要写的字节序列，第三个参数是要写的字节数。 进程 异常时允许操作系统提供进程概念所需要的基本构造块。 进程的经典定义是一个执行中的程序的实例。系统中的每个程序都是运行在某个进程的上下文中的。上下文由程序正确运行所需要的状态组成。这个状态包括存放在存储器中的程序的代码和数据它的栈、通用目的寄存器的内容、程序计数器、环境变量以及打开文件 描述符的集合。 每当用户在 Shell 中运行一个程序，Shell 会创建一个新的进程，并在其中运行可执行目标文件。 进程提供给应用程序一些关键的抽象： 一个独立的逻辑控制流，提供独占处理器的假象； 一个私有的地址空间，提供独占存储器的假象。 逻辑控制流 程序执行时，PC 会有一连串的值，表示一连串控制指令，这个 PC 值的序列就称为逻辑控制流。每个进程都拥有一个逻辑流，三个逻辑流的执行是交错的。进程 A 运行了一会儿，然后 B 开始运行到完成。然后进程 C 运行了一会儿，进程 A 接着运行到完成。 并发流 一个逻辑流的执行在时间上与另一个流重叠，称为并发流。多个流并发地执行的一般现象称为并发。一个进程和其他进程轮流运行的概念称为多任务。一个进程执行它的控制流的一部分的每一时间段叫做时间片。 如果两个流并发地运行于不同的处理器核或者计算机上，那么称为并行流。 私有地址空间 进程拥有它的私有地址空间，和这个空间相关联的存储器上不能被其他进程读写的。每个私有地址空间有着相同的通用结构。 用户模式和内核模式 为了使操作系统内核提供一个无懈可击的进程假象，处理器必须提供一种机制，限制一个应用可以执行的指令以及可以访问的地址空间范围。处理器通过模式位来进行区分，模式位描述了进程当前想有的特权。 设置模式位后，进程就运行在内核模式中，可以执行指令集的任何指令，访问存储器的任何位置。没有设置模式位时，进程就运行在用户模式中，用户模式中的进程不允许执行特权指令。 应用程序的进程初始时是在用户模式中的，进程从用户模式变为内核模式的唯一方法是通过异常。 上下文切换 内核使用上下文切换来实现多任务。 内核为每一个进程维持上下文，上下文就是内核重新启动一个被抢占的进程所需的状态。在进程执行的某些时刻，内核可以决定抢占当前进程，并重新开始一个之前被抢占的进程。这就叫做调度，由调度器管理。当内核选择一个新的进程运行时，就说调度了这个进程。 上下文切换的步骤：1) 保存当前进程的上下文， 2) 恢复某个先前被抢占的进程被保存的上下文， 3) 将控制传递给这个新恢复的进程。 一般而言，硬件高速缓存存储器不能和诸如中断和上下文切换这样的异常控制流很好地交互。 如果当前进程被一个中断暂时中断，那么对于中断处理程序来说高速缓存是冷的。 如果处理程序从 主存中访问了足够多的表项，那么当被中断的进程继续时，高速缓存对它来说也是冷的了。在这种情况下，我们就说中断处理程序污染了高速缓存。 系统调用错误处理 当 Unix 系统级函数遇到错误时，它们典型地会返回-1, 并设置全局整数变量errno来表示什么出错了。错误检查十分重要，但是会让代码变得臃肿。 举个例子，一个简单的 Unix Fork 错误检查： if (pid = fork()) &lt; 0) { fprintf(stderr, &quot;fork error: %s\\n&quot;, strerror(errno)); exit(0); } 这个流程很简单，fprintf函数将一些简单的错误信息发送到stderr管道中。但是其实可以包装一下。 void unix_error(char *msg) { fprintf(stderr, &quot;%s: %s\\n&quot;, msg, strerror(errno)); exit(0); } pid_t Fork(void) { pid_t pid; if ((pid = fork()) &lt; 0) unix_error(&quot;Fork error&quot;); return pid; } 这样的话，我们要Fork时，操作就只有一行了： pid = Fork(); 进程控制 获取进程ID 每个进程都有一个 PID，getpid函数返回调用它的进程的 PID。getppid函数返回它的父进程的 PID。 #include &lt;sys/types.h&gt; #include &lt;unistd.h&gt; pid_t getpid(void); pid_t getppid(void); 创建和终止进程 进程总是在下面三种状态之一：运行、挂起、终止。 父进程通过fork来创建一个新的子进程。新创建的子进程几乎但不完全与父进程相同。子进程的到与父进程用户级虚拟地址空间相同但是独立的一份拷贝。子进程还获得与父进程 任何打开文件描述符相同的拷贝，这就意味着当父进程调用fork时，子进程可以读写父进程中打开的任何文件。 fork函数调用一次，返回两次，父进程中，fork返回子进程的 PID。在子进程中， fork 返回 0。因为子进程的 PID 总是非零的，返回值就提供一个明确的方法来分辨程序是在父进程还是在子进程中执行。下面是一个简单的例子： #include &quot;csapp.h&quot; int main() { pid_t pid; int x = 1; pid = Fork(); if (pid == 0) { printf(&quot;child: x=%d\\n&quot;, ++x); exit(0); } printf(&quot;parent: x=%d\\n&quot;, --x); exit(0); } 总结一下fork的特性：调用一次，返回两次、并发执行、相同但是独立的地址空间、共享文件。 回收子进程 当进程终止时，会保持在终止状态一段时间，直到被父进程回收。内核将子进程的退出状态传递给父进程，然后抛弃已经终止的进程。终止还未回收的进程称为僵死进程。 如果父进程没有回收子进程就终止了，内核会安排init来回收它们。 一个进程可以调用waitpid来等待子进程终止或者停止。 #include &lt;sys/types.h&gt; #include &lt;sys/wait.h&gt; pid_t waitpid(pid_t pid, int *status, int options); // 如果成功，返回子进程的 PID，如果 WHOHANG，返回 0，如果其他错误，返回 -1 waitpid有点复杂，当options=0时，它挂起调用进程，直到等待集合中一个子进程终止。如果刚调用就终止了，那么waitpid就立即返回。 判定等待集合的成员 等待集合的成员由参数pid来确定：如果pid&gt;0，那么等待集合就是一个pid指向的单独的子进程；如果pid=-1那么等待集合就由父进程所有的子进程组成。 修改默认行为 可以将options设置为常量WHOHANG和WUNTRACED的各种组合，修改默认行为： WHOHANG：不等待，如果子进程未终止，直接返回 0； WUNTRACED：挂起，直到子进程终止，返回终止的子进程的 PID； WHOHANG|WUNTRACED：立即返回，返回值视情况而定。 检查已经回收的子进程的退出状态 如果status参数非空，waitpid就会在status参数中放上返回的子进程的状态信息。 错误条件 如果调用进程没有子进程，或者被信号中断，那么waitpid返回-1。 wait函数 wait是waitpid的简单版本，wait(&amp;status)等价于waitpid(-1, &amp;status, 0)。 有一个waitpid的示例： #include &quot;csapp.h&quot; #define N 2 int main() { int status, i; pid_t pid[N], retpid; for (i = 0; i &lt; N; ++i) { if ((pid[i] = Fork()) == 0) exit(100+i); } i = 0; while ((retpid = waitpid(pid[i++], &amp;status, 0)) &gt; 0) { if (WIFEXITED(status)) printf(&quot;child %d terminated normally with exit status=%d\\n&quot;, retpid, WEXITSTATUS(status)); else printf(&quot;child %d terminated abnormally\\n&quot;, retpid); } if (errno != ECHILD) unix_error(&quot;waitpid error&quot;); exit(0); } 让进程休眠 sleep函数将进程挂起一段时间。pause函数让调用函数休眠，直到收到一个信号。 加载并运行程序 execve函数在进程的上下文中加载并运行一个程序。 #include &lt;unistd.h&gt; int execve(const char *filename, const char *argv[], const char *envp[]); execve函数加载并运行可执行目标文件，以及参数列表和环境变量列表。只有当出现错误的时候，才返回到调用程序。execve函数在当前进程的上下文中加载并运行一个新的程序。它会覆盖当 前进程的地址空间，但并没有创建一个新进程。新的程序仍然有相同的 PID, 并且继承了调用execve函数时已打开的所有文件描述符。 信号 一个信号就是一条小消息，它通知进程系统中发生了一个某种类型的事件。 每种信号类型都对应于某种系统事件。低层的硬件异常是由内核异常处理程序处理的，正常情况下，对用户进程而言是不可见的。信号提供了一种机制，通知用户进程发生了这些异常。 信号术语 传送信号由两个不同的步骤组成：发送信号、接收信号。 一个只发出而没有被接收的信号叫做待处理信号。在任何时刻，一种类型至多只会有一个待处理信号。 一个进程可以有选择性地阻塞接收某种信号。当一 种信号被阻塞时，它仍可以被发送，但是产生的待处理信号不会被接收，直到进程取消对这种信号的阻塞。 发送信号 Unix 系统提供了大量向进程发送信号的机制。所有这些机制都是基于进程组这个概念的。 每个进程都只属于一个进程组，进程组是由一个正整数进程组 ID 来标识的。 getpgrp函数返回进程组 ID。默认地，一个子进程和它的父进程同属于一个进程组。一个进程可以通过使用setpgid函数来改变自己或者其他进程的进程组。 #include &lt;unistd.h&gt; pid_t getpgrp(void); pid_t setpgid(pid_t pid, pid_t pgid); // setpgid 将 pid 的进程组改为 pgid。pid=0 表示当前进程的 PID，pgid=0 表示当前进程的进程组。 // setpgid(0, 0) 会创建一个新的进程组。 /bin/kill用于发送信号。 $ /bin/kill -9 15213 # 发给进程 $ /bin/kill -9 -15213 # 发给进程组 C 语言中也有kill函数，用于发送信号。 接收信号 当内核从一个异常处理程序返回，准备将控制传递给进程p时，会检查进程p的未被阻塞的待处理信号的集合。如果这个集合为空，那么内核将控制传递到p到逻辑控制流的下一条指令。 如果集合非空，内核选择最小的信号，强制p接收。进程可以注册信号处理器来捕获和处理信号。 信号处理程序是计算机系统中并发的又一个示例。信号处理程序的执行中断 main函数的执行，类似于低层异常处理程序中断当前应用程序的控制流的方式。因为信号处理程序的逻辑控制流与主函数的逻辑控制流重叠，信号处理程序和主函数并发地运行。 ","link":"https://wzhzzmzzy.github.io/post/2018-7-12-异常控制流"},{"title":"操作系统笔记（一）：链接","content":"链接 链接（linking）是将各种代码和数据部分收集起来并组合成为一个单一文件的过程 。链接可以执行于编译时、加载时，甚至运行时。 链接器十分关键，它使得分离编译成为可能。我们不需要组织一个巨大的源文件，而可以将其分解为更小、更好管理的模块。 编译器驱动程序 举一个非常简单的例子： // main.c #include &lt;stdio.h&gt; void swap(); int buf[2] = {1, 2}; int main() { printf(&quot;%d %d\\n&quot;, buf[0], buf[1]); swap(); printf(&quot;%d %d\\n&quot;, buf[0], buf[1]); return 0; } // swap.c extern int buf[]; int *bufp0 = &amp;buf[0]; int *bufp1; void swap() { int temp; bufp1 = &amp;buf[1]; temp = *bufp0; *bufp0 = *bufp1; *bufp1 = temp; } 这是一个两个源文件组成的实例程序。使用下面的命令可以初始化这个程序： $ gcc -O2 -g -o p main.c swap.c 首先，编译系统运行 C 预处理器。它将 C 源程序main.c翻译成 ASCII 码中间文件main.i，然后运行 C 编译器，将main.i翻译成 ASCII 汇编语言文件main.s，然后运行汇编器，将main.s翻译成一个可重定位目标文件main.o。 驱动程序经过相同的过程生成swap.o，然后运行链接器，将多个源文件组合起来，创建一个可执行目标文件。 静态链接 上面 GCC 所使用的链接器 Unix ld 称为静态链接器，以一组可重定位目标文件和命令行参数作为输入，生成一个完全链接的可以加载和运行的可执行目标文件作为输出。 要构造可执行文件，链接器需要完成两个主要任务： 符号解析：将每个符号引用和一个符号定义联系起来。 重定位：将数据节和代码重定位。 目标文件 目标文件有三种形式： 可重定位目标文件：包含二进制代码和数据，可以合并，创建可执行目标文件。 可执行目标文件：包含二进制代码和数据，可以直接被拷贝到存储器并执行。 共享目标文件：一种特殊类型的可重定位目标文件，可以动态地被加载到存储器并链接。 可重定位目标文件 Unix 系统中使用 ELF 格式。ELF 头以一个 16 字节的序列开始，描述生成该文件的系统的字的大小和字节顺序。ELF 头剩下的部分包含帮助链接器语法分析和解释目标文件的信息。ELF 文件的末尾是节头部表。头和节头部表之间的都是节，包含： .text：机器代码； .rodata：只读数据； .data：已经初始化的全局 C 变量； .bss：未初始化的全局 C 变量； .symtab：一个符号表，记录定义和引用的函数和全局变量信息； .rel.text：描述.text节中位置的列表，当链接器把这个目标文件和其他文件结合时， 需要修改这些位置。 .debug：调试符号表，包含程序中定义的局部变量和类型定义； .line：行号和.text机器指令之间的映射，使用-g选项时才会得到这张表。 .strtab：字符串表，其内容包括.syrntab和.debug节中的符号表。 符号和符号表 每个可重定位目标模块都有一个符号表，包含其定义和引用的符号信息。在链接器上下文中，有两不同的符号：由模块定义，能被其他模块引用的全局符号、在本模块中的本地符号。本地符号指的是静态（static）属性。 对于模块而言，静态属性类似于面向对象中的私有属性，也就是说，得到了静态声明的属性不可以在模块外部被引用。 可执行目标文件 可执行目标文件和可重定位目标文件相似，还包括程序入口点，也就是当程序运行时要执行的第一条指令的地址。.text、.rodata和.data和可重定位目标文件中的节是相似的，除了这些节已经被定位到它们最终运行的存储器地址以外。 可执行文件被设计得很容易加载到存储器。要运行可执行目标文件p，可以在 Unix Shell 的命令行中输入它的位置： $ ./p Shell 会认为p是一个可执行目标文件，通过调用某个主流在存储器中的加载器来运行它。任何 Unix 程序都可以通过调用execve函数来调用加载器。加载器将可执行目标文件中的代码和数据从磁盘拷贝到存储器，然后通过跳转到程序的第一条指令或入口点来运行程序。这个将程序拷贝到存储器并运行的过程称为加载。 简单描述一下加载的过程：Unix 系统每个程序都运行于一个进程上下文中，有自己虚拟的地址空间。当 Shell 运行一个程序时，生成一个子进程，子进程通过execve系统调用启动加载器。加载器删除子进程现有的虚拟存储器段，并创建一组新的代码、数据、堆和栈段。新的堆栈被初始化为 0。然后，将虚拟地址空间中的页映射到可执行文件的页大小的片，新代码和数据段被初始化为可执行文件的内容。最后，加载器跳转到_start地址，最终会调用应用程序的main函数。 动态链接共享库 静态库有着一些明显的缺点，即维护起来相对麻烦，并且当使用非常频繁时会系统资源造成极大浪费。 共享库是致力于解决静态库缺陷的一个现代创新产物。动态链接器可以将共享库加载到任意地址，与程序链接。共享库也称为共享对象（shared object），在 Unix 中通常为.so后缀，Windows 大量使用了共享库，称为 DLL。 在任何给定的文件系统中，对于一个库只有一个.so文件，所有引用它的程序共享这个文件中的代码和数据。并且，一个共享库的一个副本可以被多个正在运行的不同进程共享。 创建共享库的命令如下： $ gcc -shared -fPIC -o libvector.so addvec.c multvec.c 创建了共享库后，可以将其与源代码链接： $ gcc -o p2 main2.c ./libvector.so 这样就创建了一个可执行目标文件p2，此文件的形式使得它在运行时可以和libvector.so链接。基本思路是当创建可执行文件时，静态执行一些链接，然后程序加载时，动态完成链接过程。这里有一点很重要：p2中没有任何libvector.so中的数据节，链接器只是获取了一部分libvector.so中的重定位和符号表信息。 动态链接器通过执行重定位和符号引用完成链接，并最后将控制传递给应用程序。 从应用程序中加载和链接共享库 在应用程序运行时，也可以要求动态链接器加载和链接任意共享库，无需在编译时链接到应用中。动态链接是一项强大有用的技术，可以用于很多方面，例如分发软件、构建高性能 Web 服务器等。其思路是将生成动态内容等每个函数打包在共享库中，当一个来自 Web 的请求到达时，服务器加载和链接适当的函数，然后直接调用它，而不是fork和exevce在子进程的上下文中运行函数。 Unix 提供了一个简单的dlopen函数来支持动态链接操作。 与位置无关的代码（PIC） 共享库的一个主要目的就是允许多个正在运行的进程共享存储器中相同的库代码。要使多个进程共享一个拷贝，一种方法就是给每个共享库分配一个专用的地址片，然后要求加载器总是在这个地址加载共享库。这个方法对空间的使用率不高，并且难以管理。另一种更好的方法是编译库代码，使得不需要链接器修改，库代码就可以在任何位置加载和执行。这种代码就称为位置无关代码（PIC）。之前我们用到了 GCC 的-fPIC选项，就是指示 GCC 编译出 PIC 代码。 ","link":"https://wzhzzmzzy.github.io/post/2018-7-11-链接"},{"title":"SICP 阅读理解（一）","content":"Scheme 学习记录 Lisp Lisp 不是一门主流语言，但其具有一个非常重要的语言特性：计算过程的 Lisp 描述本身又可以作为 Lisp 的数据来表示和操作。Scheme 是 Lisp 的一种方言。 程序设计的基本元素 每一种强有力的语言都提供了三种机制： 基本的表达形式，用于表示语言所关心的最简单的个体。 组合的方法，通过他们可以从较简单的东西出发，构造出复杂的元素。 抽象的方法，通过他们可以为复合对象命名。 在程序设计中，我们需要处理两类要素：过程和数据。不那么正式地说，数据是一种我们希望去操作的东西，而过程就是有关操作这些数据的规则的描述。 表达式 表达式用于求值。括号将表达式括起，称为组合式。最左侧的元素称为运算符，其他称为运算对象。 &gt; (+ 1 2) 3 这种方式称为前缀表示，好处是可以适应任意个参数的情况。 &gt; (+ 1 2 3) 6 前缀表示的另一个优点是可以直接扩充。 &gt; (+ (+ 1 2) (+ 3 4)) 10 由于表达式可能很长，写成一行会不易阅读，所以可以添加适当的缩进。 &gt; (+ (+ 1 (- 3 1) (- 5 3) (* 3 (/ 2 2))) (+ 1 1)) 10 命名和环境 define在 Scheme 中是命名的符号。 &gt; (define size 2) &gt; size 2 这是 Scheme 中最简单的抽象方法，允许我们用一个简单的名字去引用一个组合运算的结果。 我们能够将值与符号关联，而后又能提取出这些值，这意味着解释器必须维护存储，这种存储就被称为环境。 组合式的求值 要求值一个组合式，要做两件事： 求值该组合式的各个子表达式； 将运算符应用于子表达式的值。 这个规律是递归运行的。 注意define不是一个运算符，是一个特殊符号，也就是说，(define x 2)不是一个组合式，而是改变了某一个关联词的值，在函数式编程中，我们称之为副作用。 复合过程 在任何一门强有力的程序语言中，必然会出现我们之前已经看到的一些元素： 数和算术运算是基本的数据和过程； 组合式的嵌套提供了一种组织起多个操作的方法； 定义是一种受限的抽象手段，为名字关联相应的值。 下面我们来讲解过程定义，它可以为复合操作提供名字。 过程定义的一般形式是 (define (&lt;name&gt; &lt;formal parameters&gt;) &lt;body&gt;) (define (square x) (* x x)) &lt;name&gt;是一个符号，过程定义将在环境中关联于这个符号。&lt;formal parameters&gt;是一些名字，他们用在过程体中，用于表示过程应用时与他们对应的各个实际参数。&lt;body&gt;是一个表达式。 过程应用的代换模型 对于一个过程应用，我们要对它求值时，可以假想是这样一个模型：将复合过程应用于实际参数，就是在将过程体中的每个形参用相应的实际参数替代，然后对这一过程求值。 这时候就会有一个问题：它会先依次计算每个参数的值，然后再对组合式求值，还是先将组合式全部展开，然后依次应用于每个运算符？前者，“先求值参数后应用”，我们称为应用序求值，后者，“完全展开而后规约”，我们称为正则序求值。 条件表达式和谓词 有时候我们需要分情况分析过程，给出不同的结果，这时候我们就需要一个条件表达式。 cond就是这样一个词，使用如下： (define (abs x) (cond ((&gt; x 0) x) ((= x 0) x) ((&lt; x 0) (- x)))) cond之后的每一行，称为子句，即一对有括号括起的表达式。前者称为谓词，值会被解释为真或者假。 绝对值函数的另一种写法是 (define (abs x) (cond ((&lt; x 0) (- x) (else x)))) 还有一个条件词是if。 (define (abs x) (if (&lt; x 0) (- x) x)) if是条件表达式的一种受限形式，适合只有两种情况的需要。 除了一些常用谓词&lt;，=，&gt;之外，还有一些复合谓词： &gt; (and (&lt; 1 0) ( &gt; 1 0)) #f &gt; (or (&lt; 1 0) ( &gt; 1 0)) #t &gt; (not (&lt; 1 0)) #t 实例：牛顿法求平方根 牛顿法的表述如下：如果对xxx的平方根的值有了一个猜测yyy，那么就可以通过执行一个简单操作来得到一个更好的猜测，求yyy和xy\\frac{x}{y}yx​的平均值。 (define (sqrt-iter guess x) (if (good-enough? guess x) guess (sqrt-iter (improve guess x) x))) (define (improve guess x) (average guess (/ x guess))) (define (average x y) (/ (+ x y) 2)) (define (good-enough? guess x) (&lt; (abs (- (square guess) x)) 0.001)) (define (sqrt x) (sqrt-iter 1.0 x)) 过程做为黑箱抽象 在我们写sqrt时就能发现，当我们编写sqrt-iter时，我们完全不用在意good-enough?中的逻辑是什么样子，把它看做一个“黑箱”。我们只需要关注它的返回值即可。 我们在写sqrt时，声明了sqrt-iter，improve，good-enough?这几个名字。这些名字在全局环境中存在，也就是说，在这个环境中，其他人不可以再使用这些名字。但是这并不必要。所以我们可以把这些名字定义在sqrt内部，这称为局部环境。 (define (sqrt x) (define (sqrt-iter guess x) (if (good-enough? guess x) guess (sqrt-iter (improve guess x) x))) (define (improve guess x) (average guess (/ x guess))) (define (good-enough? guess x) (&lt; (abs (- (square guess) x)) 0.001)) (sqrt-iter 1.0 x)) 这种嵌套的定义为块结构。每个变量都有自己的作用域。 过程与他们产生的计算 能够看清楚所考虑的动作的后果的能力，对于成为程序设计专家是至关重要的。我们需要对计算过程中各种动作的进行情况做出规划，用程序去控制这一过程的进展。一个过程也就是一种模式，描述了一个计算过程的局部演化方式，描述了这一计算过程中的每个步骤是怎样基于前面的步骤建立起来的。 线性的递归和迭代 下面是一个阶乘递归函数： (define (f n) (if (= n 1) 1 (* n (f (- n 1))))) 这样的递归非常耗费资源，所以我们可以改为另一种形式： (define (f n) (define (f-iter cnt low high) (if (&gt; low high) cnt (f-iter (* cnt low) (+ low 1) high))) (f-iter 1 1 n)) 这种形式称为线性迭代，上面一种形式称为线性递归。 ","link":"https://wzhzzmzzy.github.io/post/2018-1-22-Scheme"},{"title":"SSH Tricks","content":"ssh OpenSSH 是最常见的 SSH 软件，基于 SSH 协议，其中的信息交互是全部加密过的。 最基本的用法 $ ssh user@host 如果远程用户名和本地用户名一致的话，那么登录的时候就可以省略用户名。 $ ssh host SSH 的默认端口是 22，使用-p参数可以指定端口。 ssh -p 12450 user@host 中间人攻击 SSH 使用了公钥加密，用于保证通信的安全，过程如下： 远程主机收到用户的登录请求，把自己的公钥发给用户； 用户用公钥加密密码，发送给远程主机； 远程主机用私钥解密密码，进行认证。 这个过程本身是安全的，但是如果有人截获了用户的登录请求，然后冒充远程主机，用户就很难辨别真伪。因为 SSH 协议的公钥是没有 CA 公证的。 这种情况就叫做“中间人攻击”。 那么如何应对呢？ 口令登陆 如果第一次登陆主机，系统会出现一些提示，获取到了公钥指纹，但是无法确认主机的真实性。这个指纹是 1024 位的公钥在 MD5 算法哈希过之后获取的 128 位指纹。 用户接受指纹后，系统会保存远程主机的公钥，然后就可以输入密码了。 这个公钥会保存在$HOME/.ssh/known_hosts中。 公钥登陆 使用密码登陆，每次都要输入，未免有些麻烦，我们可以使用公钥登陆来省去这个步骤。 这个方法的原理很简单，用户将自己的公钥存储在远程主机上，登陆的时候远程主机会向用户发送一段随机字符串，用户用自己的私钥加密，然后发回来。远程主机用公钥解密，如果成功，那么用户就是可信的。 使用ssh-keygen可以生成一个公钥，生成的公钥会出现在$HOME/.ssh/目录下：id_rsa和id_rsa.pub。 然后把公钥传送到主机上： $ ssh-copy-id user@host 这样就不需要再使用口令了。 注意，远程主机的 ssh 配置/etc/ssh/sshd_conifg中需要开启对应功能。 RSAAuthentication yes PubkeyAuthentication yes AuthorizedKeysFile .ssh/authorized_keys 记得改变配置后重启服务： // Ubuntu service ssh restart // CentOS systemctl restart sshd.service ","link":"https://wzhzzmzzy.github.io/post/2018-5-19-ssh"},{"title":"NumPy 学习笔记","content":"Python2 科学计算 NumPy import numpy as npv np.__version__ # 版本号 nbarray 对象 NumPy中用ndarray表示数组，是整个库的核心对象，NumPy中所有函数都是围绕ndarray对象进行处理的。ndarray的结构并不复杂，但是功能十分强大。不但可以用它高效地存储大量的数值元素，从而提高数值计算的运算速度，还能用它与各种扩展库进行数值交换。 创建 创建数组很简单。 a = np.array([1,2,3,4]) b = np.array([[1,2,3,4],[5,6,7,8]]) 数组的形状可以由shape属性获得，是一个描述数组各个轴长度的元组。可以通过修改shape属性值来对数组进行重新划分。 a.shape # (4,) b.shape # (2, 4) a.shape = 2, 2 # a array([[1,2],[3,4]]) b.shape = 4, -1 # b array([[1,2],[3,4],[5,6],[7,8]]) 可以使用数组的reshape()方法，来根据原数组创建新数组，这个方法接受元组，或者将元组拆包也可。 元素类型 数组的元素类型可以通过dtype属性获得。在前面的例子中，创建数组所用的序列的元素都是整数，因此所创建的数组的元素类型是整形，并且是32位的长整型。dtype.type可以获取type类型的对象。 a.dtype # dtype('int64') a.dtype.type # &lt;type 'numpy.int64'&gt; 可以通过dtype参数在创建数组时指定元素类型，注意float类型是64位的双精度浮点类型，而complex是128位的双精度复数类型，np.int32则是NumPy`定义的新的数据类型——32位符号整数类型： ai32 = np.array([1,2,3,4], dtype=np.int32) af = np.array([1,2,3,4], dtype=float) ac = np.array([1,2,3,4], dtype=complex) NumPy也有自己的浮点数类型：float16，float32，float64，float128。当使用float64作为dtype参数时，效果和内置的float类型相同。 每种元素数值类型都有几种不同的字符串表达方式，字符串和类型之间的对应关系都存储在typeDict字典中，可以通过下面的命令获得对应的所有键值： [key for key, value in np.typeDict.items() if value is np.float64] # [12, 'd', 'float64', 'float_', 'float', 'f8', 'double', 'Float64'] 完整的类型列表可以通过下面的语句得到，它将typeDict字典中的所有制转换为一个集合，从而去除其中的重复项。 set(np.typeDict.values()) 通过NumPy的数值类型也可以创建数值对象，下面创建一个16位的符号整数对象，它与Python的整数对象不同的是，它的范围有限，因此计算200*200会溢出，得到一个负数，这一点与C语言的16位整数相同。 另外值得注意的是，NumPy的数值对象的运算速度比Python内置类型的运算速度慢很多，如果程序中需要大量地对单个数值运算，应当尽量避免使用NumPy的数值对象。下面的命令比较了两者的运算速度： u = 3.14 v = np.float64(u) %timeit u*u %timeit v*v 使用astype()方法可以对数组的元素类型进行转换，下面将浮点数数组t1转换为32为整数数组，将双精度的复数数组t2转换为单精度的复数数组： t1 = np.array([1,2,3,4], dtype=np.float) t2 = np.array([1,2,3,4], dtype=np.complex) t3 = t1.astype(np.int32) t4 = t2.astype(np.complex64) 自动生成数组 前面的例子都是先创建一个Python的序列对象，然后通过np.array()将其转换为数组，这样做显然效率不高。因此NumPy提供了很多专门用于创建数组的函数。下面每一个函数都有一些关键字参数，具体用法参看函数说明。 arange()类似于内置函数range()，通过制定开始值、终值和步长来创建表示等差数列的一维数组，注意所得到的结果不包含终值。例如下面的程序创建开始值为0，终值为1，步长为0.1的等差数组，注意终值1不在数组中。 np.arange(0, 1, 0.1) # array([0. , 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9]) linspace()通过制定初值、终值和元素个数来创建表示等差数列的一维数组。可以通过endpoint参数制定是否包含终值，默认值为True，即包含终值。 np.linspace(0, 1, 10) # 步长 1/9 np.linspace(0, 1, 10, endpoint=False) # 步长 1/10 logspace()和linspace()类似，不过它所创建的数组是等比数列。下面的例子产生从 10010^0100 到 10210^2102，有5个元素的等比数列，注意起始值0代表 10010^0100，而终值2表示 10210^2102： np.logspace(0, 2, 5) # [1. , 3.16227766, 10. , 31.6227766 , 100. ] 基数可以通过base参数确定，其默认值为10。下面通过将base参数设置为2，并设置endpoint参数为False，创建一个比例为 2frac1122^{frac{1}{12}}2frac112 的等比数组，此等比数组的比值啥音乐中相差半音的两个音阶之间的频率比值，因此可以用它计算一个八度中所有半音的频率： np.logspace(0, 1, 12, base=2, endpoint=False) # [ 1. 1.05946309 1.12246205 1.18920712 1.25992105 1.33483985 1.41421356 1.49830708 1.58740105 1.68179283 1.78179744 1.88774863] zeros()、ones()、empty()可以创建指定形状和类型的数组。其中empty()只分配数组所使用的内存，不对数组元素进行初始化操作，因此它的运行速度是最快的。下面的程序创建一个形状为(2, 3)、元素类型为整数的数组，注意其中的元素值没有被初始化： 而zeros()将数组元素初始化为0，ones()将数组元素初始化为1。下面创建一个长度为4，元素类型为整数的一位数组，并且元素全部初始化为0。 np.empty((2,3), np.int) np.zeros(4, np.int) np.full(4, np.pi) # 初始化为指定的值 此外，zeros_like()、ones_like()、empty_like()、full_like()等函数创建与参数数组的形状与类型相同的数组，因此zeros_like(a)和zeros(a.shape, a.dtype)的效果相同。 frombuffer()、fromstring()、fromfile()等函数可以从字节序列或文件创建数组。下面以fromstring()为例介绍它们的用法，先创建8个字符的字符串s，Python的字符串实际上是一个字节序列，每个字符占一个字节。因此如果从字符串s创建一个8为整数数组，所得到的数组是字符串的ASCII编码。 s = &quot;abcedfg&quot; np.fromstring(s, dtype=np.int8) 如果从字符串s创建一个16位整数数组，那么两个相邻的字节就表示一个整数，吧字节98和字节97当作一个16位的整数，他的值就是 98×256+97=2518598\\times 256+97=2518598×256+97=25185。可以看出，16位的整数啥以低位字节在前的方式保存在内存中的。 np.fromstring(s, dtype=np.int16) # array([25185, 25699, 26213, 26727], dtype=int16) 如果把整个字符串转化为一个64位的双精度浮点数数组，那么它的值是： np.fromstring(s, dtype=np.float) # array([8.54088322e+194]) 显然这个结果没有什么意义，但是如果我们用C语言的二进制方式写了一组double类型的数值到某个文件中，那就可以从此文件读取相应的数据，并通过fromstring()将其转换为float64类型的数组，或者直接使用fromfile()从二进制文件读取数据。 fromstring()会对字符串的字节序列进行复制，而使用frombuffer()创建的数组与原始字符串共享内存。由于字符串是只读的，因此无法修改所创建的数组的内容： buf = np.frombutter(s, dtype=np.int16) buf[1] = 10 # ValueError Python中还有一些类型也支持buffer接口，例如bytearray、array.array等。在后面的章节中，我们会介绍如何使用这些对象实现动态数组功能。 还可以先定义一个从下标计算数值的函数，然后用fromfunction()通过此函数创建数组： func = lambda i: i%4+1 np.fromfunction(func, (10,)) # [1., 2., 3., 4., 1., 2., 3., 4., 1., 2.] func = lambda i,j: (i+1)*(j+1) np.fromfunction(func2, (9,9)) # 九九乘法表 # [[ 1. 2. 3. 4. 5. 6. 7. 8. 9.] # [ 2. 4. 6. 8. 10. 12. 14. 16. 18.] # [ 3. 6. 9. 12. 15. 18. 21. 24. 27.] # [ 4. 8. 12. 16. 20. 24. 28. 32. 36.] # [ 5. 10. 15. 20. 25. 30. 35. 40. 45.] # [ 6. 12. 18. 24. 30. 36. 42. 48. 54.] # [ 7. 14. 21. 28. 35. 42. 49. 56. 63.] # [ 8. 16. 24. 32. 40. 48. 56. 64. 72.] # [ 9. 18. 27. 36. 45. 54. 63. 72. 81.]] 存取元素 可以使用和列表相同的方式对数组的元素进行存取： a = np.arange(10) a[5] # 5 a[3:5] # [3, 4] a[:5] # [0, 1, 2, 3, 4] a[:-1] # [0, 1, 2, 3, 4, 5, 6, 7, 8] a[1:-1:2] # [1, 3, 5, 7] a[::-1] # [9, 8, 7, 6, 5, 4, 3, 2, 1, 0] a[5:1:-2] # [5, 3] 和列表不同的是，通过切片获取的新数组的原始数组的一个试图。它与原始数组共享一块数据存储空间。下面的程序将b的第二个元素修改为-10，a的第5个元素也同时被修改为-10，因此它们在内存中的地址相同。 除了使用切片下标存取元素之外，NumPy还提供了整数列表、整数数组和布尔数组等几种高级下标存取方法。 当使用整数列表对数组元素进行存取时，将使用列表中的每个元素作为下标。使用列表作为下标得到的数组不和原始数组共享内存，整数序列下标也可以用来修改元素的值： x = np.arange(10, 1, -1) a = x[[3, 3, 1, 8]] b = x[[3, 3, -3, 8]] x[[3, 5, 1]] = -1, -2, -3 当使用整数数组作为数组下标时，将会得到一个形状和下标数组相同的新数组，新数组的每一个元素都是用下标数组中对应位置的值作为下标从原数组获得的值。当下标数组是一维数组时，结果和用列表作为下标的结果是一样的，而多维数组时，得到的也是多维数组： x = np.aragne(10,1,-1) x[np.array([3,3,1,8])] x[np.array([[3,3,1,8],[3,3,-1,8]])] x[[3,3,1,8,3,3,-1,8]].reshape(2,4) # 和上一句等同 当使用布尔数组b作为下标存取数组x中的元素时，将获得数组x中与数组b中True对应的元素。使用布尔数组作为下标获得的数组不和原始数组共享数据内存，注意这种方式只对应于布尔数组，不能使用布尔列表。 x[np.array([True, False, True, False, False])] x[np.array([True, False, True])] # 等同 布尔数组一般不是手工产生，而是使用布尔运算的ufunc函数产生，关于ufunc函数请参照下一节的介绍。下面我们举一些简单的例子说明布尔数组下标的用法： x = np.random.randint(0, 10, 6) # 产生一个长度为6，元素值为0到9的随机整数数组 x[x&gt;5] # 生成一个布尔数组，收集x中所有大于5的数 多维数组 多维数组的存取和一维数组类似，因为多维数组有多个轴，所以它的下标需要用多个值来表示。NumPy采用元组作为数组的下标，元祖中的每个元素和数组的每个轴对应。 为什么用元组作为下标？Python的下标语法本身不支持多维，但可以使用任何对象作为下标，因此，NumPy使用元组作为下标存取数组中的元素，使用元组可以很方便地表示多个轴的下标。虽然在Python程序中经常用圆括号将元组的元素括起来，但是事实上元组的语法只需要用逗号隔开元素即可，例如，x,y=y,x就是用元组交换变量值的一个例子。因此，a[1,2]和a[(1,2)]完全相同，都是使用元组(1,2)作为数组a的下标。 可以通过arange相加可以获取需要的二维数组，这样构成的数组，第0个元素与数组的纵轴对应，而第1个元素和横轴对应： a = np.arange(0, 60, 10).reshape(-1, 1) + np.aragne(0, 6) a[0] # [0 1 2 3 4 5] a[1] # [10 11 12 13 14 15] a[:, 2] # [2 12 22 32 42 52] a[2::2, ::2] # [[20 22 24] [40 42 44]] 如果下标元组中只包含整数和切片，那么得到的数组和原始数组共享数据，它是原数组的视图。下面的例子中，数组b是a的视图，它们共享数据，因此修改b[0]时，数组a中对应的元素也被修改。 b = a[0, 3:5] b[0] = -b[0] a[0, 3:5] # array([-3, 4]) 因为数组的下标是一个元组，所以我们可以将下标元组保存起来，用同一个元组存取多个数组。在下面的例子中，a[idx]和a[::2,2:]相同，a[idx][idx]和a[::2,2:][::2,2:]。 idx = slice(None, None, 2), slice(2, None) 切片对象。根据Python的语法，在[]中可以使用以冒号隔开的两个或三个整数表示切片，但是单独生成切片对象时需要使用slice()来创建。它由三个参数，分别为开始值、终值和步长，当这些值需要省略时可以使用None。 用Python的内置函数slice()创建下标比较麻烦，因此NumPy提供一个s_对象来帮助我们创建数组下标，请注意s_实际上是IndexExpression类的一个对象： np.s_[::2, 2:] # (slice(None, None, 2), slice(2, None, None)) s_为什么不是函数？根据Python的语法，只有在中括号[]中才能使用以冒号隔开的切片语法，如果s_是函数，那么这些切片必须使用slice()创建。类似的对象还有mgrid和ogrid等，后面我们会学习它们的用法。Python的下标语法实际上会调用__getitem__()方法，因此我们可以很容易自己实现s_对象的功能： class S(object): def __getitem__(self, index): return index 在多维数组的下标元组中，也可以使用整数元祖或列表、整数数组和布尔数组。当下标使用这些对象时，所获得的数字是原始数据的副本，因此修改结果数组不会改变原始数组。 结构数组 在 C 语言中我们可以通过struct关键字定义结构类型，结构中的字段占据连续的内存空间。类型相同的两个结构所占用的内存大小相同，因此可以很容易定义结构数组。和C语言一样，在NumPy中也很容易对这种结构数组进行操作。只要NumPy中的结构定义和C语言中的结构定义相同，就可以很方便地读取C语言的结构数组的二进制数据，将其转换为NumPy的结构数组。 假设我们需要定义一个结构数组，它的每个元素都有name、age和weight字段。在NumPy中可以如下定义： persontype = np.dtype({ 'names':['name', 'age', 'weight'], 'formats':['S30', 'i', 'f']}, align=True) a = np.array([(&quot;Zhang&quot;, 32, 75.5), (&quot;Wang&quot;, 24, 65.2)], dtype=persontype) 我们先创建一个dtype对象persontype，它的参数是一个描述结构类型的各个字段的字典，字典有两个键：'names'和'formats'。每个键对应的值都是一个列表。'names'定义结构中每个字段的名称，而'formats'则定义每个字段的类型。这里我们使用类型字符串定义字段类型。 'S30': 长度为30字节的字符串类型，由于结构中每个元素大小必须固定，因此需要制定字符串的长度。 'i'：32位整数，相当于np.int32。 'f'：32位单精度浮点数类型，相当于np.float32。 然后我们调用array()以创建数组，通过dtype参数指定所创建的数组的元素类型为persontype。下面查看数组a的元素类型： a.dtype # dtype({'names':['name','age','weight'], 'formats':['S30','&lt;i4','&lt;f4'], 'offsets':[0,32,36], 'itemsize':40, 'aligned':True}) 还可以用包含多个元组的列表来描述结构的类型： dtype([('name', '|S30'), ('age', '&lt;i4'), ('weight', '&lt;f4')]) 其中形如“（字段名，类型描述）”的元组描述了结构中的每个字段。类型字符串前面的'I'、'&lt;'、'&gt;'等字符表示字段值的字节顺序： 'I'：忽视字节顺序。 '&lt;'：低位字节在前，即小端模式。 '&gt;'：高位字节在前，即大端模式。 结构数组的存取方式和一般数组相同，通过下标能够取得其中的元素，注意元素的值看上去像是数组，实际上是结构。这里的aligned=True用于标记内存对齐，以免在某些 C 编译器下发生读取错误的问题。 print a[0] a[0].dtype # ('Zhang', 32, 75.5) # dtype({'names':['name','age','weight'], 'formats':['S30','&lt;i4','&lt;f4'], 'offsets':[0,32,36], 'itemsize':40, 'aligned':True}) 我们可以使用字段名作为下标获取对应的字段值： a[0]['name'] # 'Zhang' a[0]是一个结构元素，它和数组a共享内存，因此可以通过修改它的字段改变原始数组中对应元素的字段。我们不但可以获得结构元素的某个字段，而且可以直接获得结构数组的字段，返回的是原始数组的视图，因此可以通过修改b[0]来改变a[0]['age']。 通过a.tostring()或a.tofile()方法，可以将数组a以二进制的方式转换成字符串或者写入文件： a.tofile('test.bin') 利用下面的C语言程序可以将test.bin文件中的数据读取出来。 struct person { char name[30]; int age; float weight; } p[3]; int main() { FILE *fp = fopen(&quot;test.bin&quot;, &quot;rb&quot;); fread(p, sizeof person, 2, fp); fclose(fp); for(int i = 0; i &lt; 2; ++i) printf(&quot;%s %d %f\\n&quot;, p[i].name, p[i].age, p[i].weight); } 数组使用strides属性来保存查询时指针在内存中所需要移动的字节数。 我们也可以使用view方法来使用不同的dtype来查看同一块内存区域下的数据。 import numpy as np a = np.array([[0,1],[2,3],[4,5]], dtype=np.float32) b = a.view(np.uint32) c = a.view(np.uint8) ufunc函数 ufunc相当于Python的map，能对数组的每一个元素执行运算。区别在于返回了一个新数组，并没有改变原数组的值。也可以通过out参数来指定保存计算结果的数组。另一个区别是NumPy的这些ufunc函数都是用C语言实现的，所以比Py2自带的函数用map去实现这样的功能要快十倍以上。 这些函数也支持单个数值的运算，但是在单个数值时会比math库中的函数慢很多。此外，对于单个数值的计算，np.sin()和math.sin返回值类型不同，NumPy的返回值是float64类型。通过下标运算获取的数组元素的类型为NumPy中定义的类型，将其转换为Python的标准类型还需要花费额外的时间。数组提供了item()方法来解决这个问题，用来获取数组中的单个元素，并且直接返回为标准的Python数据类型。 通过在ufunc函数中指定out，可以指定输出的变量。 x = np.linspace(0, 2*np.pi, 10) y = np.sin(x, out = x) y is x # True 四则运算、比较运算和布尔运算 NumPy提供了很多ufunc函数，比如计算两个数组之和的add()函数，还有subtract，multiply等等。 使用==、&gt;等比较运算符对两个数组进行比较，将返回一个布尔数组，它的每个元素值都是两个数组对应元素的比较结果。由于Python中布尔运算使用and、or、not等关键字，无法被重载，因此数组的布尔运算只能通过相应的ufunc函数进行。这些函数名以logical_开头。 np.logical_or(a==b, a&gt;b) # 等同于 a &gt;= b 可以使用数组的any()和all()函数，和Python内置的函数相同。 bitwise_开头的是位运算函数。对于布尔数组来说，位运算和布尔运算结果相同，但是使用时位运算的优先级高于布尔运算。整数位运算和C语言位运算相同，注意元素类型的符号。 自定义ufunc函数 通过NumPy提供的标准ufunc函数，可以组合出复杂的表达式，在C语言级别对数组的每个元素进行计算。但是有时候这种表达式不易编写，而对每个元素进行计算的程序却很容易用Python实现，这是可以用frompyfunc()将计算单个元素的函数转换成ufunc函数，这样就可以方便地用所产生的ufunc函数对数组进行计算了。 下面是一个计算三角波上某点的Y坐标的函数。 def triangle_wave(x, c, c0, hc): x = x - int(x) if x &gt;= c: r = 0.0 elif x &lt; c0: r = x / c0 * hc else: r = (c-x) / (c-c0) * hc return r 通过frompyfunc()可以将计算单个值的函数转换为能对数组的每个元素进行计算的ufunc函数。值得注意的是，转化之后的函数返回值类型是object，需要用astype方法把它转化为双精度浮点数组。 frompyfunc(func, nin, nout) # 函数 传参个数 返回值个数 trignle_wave_ufunc = np.frompyfunc(triagnle_wave, 4, 1) 广播 当使用ufunc函数对两个数组进行计算时，ufunc函数会对这两个数组的对应元素进行计算，因此它要求这两个数组的形状相同。如果形状不同，会进行如下广播处理： 让所有输入数组都向维数最多的数组看起，不足部分通过加1补齐。 输出数组的shape属性是输入数组的shape属性的各个轴上的最大值。 如果输入数组的某个轴的长为1或与输出数组的对应轴长度相同，这个数组就能够用来计算，否则会报错。 当输入数组的某个轴长度为1时，沿着此轴运算时，都用此轴的第一组值。 由于这些原因，我们需要用repeat函数来扩展我们的数组。axis表示扩展的方向。 a = np.arange(0, 60, 10).reshape(-1, 1).repeat(5, axis=1) &quot;&quot;&quot; [[ 0 0 0 0 0] [10 10 10 10 10] [20 20 20 20 20] [30 30 30 30 30] [40 40 40 40 40] [50 50 50 50 50]] &quot;&quot;&quot; 但是一般我们并不会使用repeat，这样太浪费内存空间了，使用ogrid可以获取一个用于创建广播的数组，mgrid用于获取广播的结果数组。注意他们都使用下标来获取值，有两种下标形式：开始:结束:步长，和开始:结束:长度j。 x, y = np.ogrid[:5, :5] a, b = np.mgrid[:5, :5] ","link":"https://wzhzzmzzy.github.io/post/2018-4-21-Python科学计算"},{"title":"Python - mitsuhiko/unp Note","content":"unp click Python 的一个命令行参数库，用于生成命令行程序。 @click.command()，指定函数为命令行接口。 @click.option('--param', default=default_val, prompt='Val Name', help='description')，指定参数。 @click.argument('param', nargs=-1)，简单参数，-1表示不定参数。 @click.group()，指定函数为命令行接口组，可以使用@func.command()，可以使用func.add_command()。 @click.password_option()，直接获取--password参数，隐藏并允许重复输入。 @click.version_option()，当获取到--version时，直接调用print_version()函数。 click.echo('')，控制台输出。 装饰器可以叠加。作为主函数的函数需要加上@click.command()。对于每一个参数，被装饰的函数都需要有一个对应的参数。 option 的参数 定位参数，表示直接输入参数时的参数名。不定数量。 callback，当输入该参数时，会调用callback指定的函数，而不是被装饰的主函数。 type，参数的类型，可以使用click.Choice(['1', '2'])指定可选值。 nargs，参数数量，-1 表示不定数量。 required，是否必须。 help，描述信息。 hide_input，隐藏输入信息。 confirmation_prompt，是否允许重复输入。 default，设定默认值。 is_flag, 设定当标明该参数时的布尔值。 subprocess Popen 开启一个子进程，执行一些命令行程序。第一个参数是一个可迭代对象，包含命令和参数。之后可以指定输入输出和错误流，执行的目录，如果不指定目录默认为当前目录，也可以指定环境变量。 使用Popen().communicate()可以等待进程结束。可以直接获取返回值。 使用stdin、stdout、stderr可以指定流，返回一个Popen对象，可以其中包含输入输出流。 总结 还是学到了一点有意思的东西。 常量设置 可以通过object()和is来判断常量标记，很方便也很轻量。 PWD = object() def getItem(arg): if arg is PWD: return './' 文件操作 获取文件名、针对文件名寻找 PATH 中的可执行命令、目录之间的操作、当前目录下有重名时的处理，都是需要做好的。 工厂模式 unp处理方式是针对每个压缩包创建一个对应的解压类实例，使用实例进行解压。所有的解压类都来自UnpackerBase。实际解压工序不同，所以real_unpacker方法单独获得重载。 为了便于选择文件对应的解压类，UnpackerBase有一个id属性，并且使用了@register_unpacker将所有的类都放入一个列表中。 ","link":"https://wzhzzmzzy.github.io/post/2018-3-27-unp"},{"title":"SQL 语法详解","content":"SQL 入门 入门书：《SQL 必知必会（第 4 版）》 什么是 SQL SQL 是用于操作数据库的语言。为了简化读写，SQL中只有很少几个关键词。 数据库中存储数据的主体是表。表由列组成，每一列有其数据类型和唯一的列名。表中的数据按行存储，每一行就是一个记录。主键是每个记录的唯一标识，是一个特殊的列。 检索数据 SELECT SELECT prod_name FROM Products; 从表Products检索列prod_name。 注意 SQL 不区分大小写，SELECT和select是一样的。 SELECT prod_id, prod_name, prod_price FROM Products; 通过逗号隔开可以区分多个类名。 SELECT * FROM Products; 这样可以检索所有的列。*称为通配符。 SELECT 会返回所有匹配的行，这就导致可能会有选择出的数据是重复的。DISTINCT可以确保不重复。 SELECT DISTINCT vend_id FROM Products; 如果需要限制返回的行数，是可以做到的，但是在不同的 DBMS 中，对此的设计是不同的。 -- 检索前五行数据 -- SQL Server / Access SELECT TOP 5 prod_name FROM Products; -- Oracle SELECT prod_name FROM Products WHERE ROWNUM &lt;= 5; -- MySQL / MariaDB / PostgreSQL / SQLite SELECT prod_name FROM Products LIMIT 5; -- 在 MySQL 中返回后五行数据 SELECT prod_name FROM Products LIMIT 5 OFFSET 5; 排序检索 ORDER BY子句可以对输出进行排序。 -- 字典序 SELECT prod_name FROM Products ORDER BY prod_name; 注意，ORDER BY子句需要是SELECT语句中的最后一条子句。 完全可以使用不选择的列去排序。 可以按多个列进行排序，只需要在ORDER BY子句中指明列名，并使用逗号隔开即可。排序的优先级和子句中的顺序一样。 除了使用列名排序，还可以使用列位置来排序。 SELECT prod_id, prod_price, prod_name FROM Products ORDER BY 2, 3; 排序默认按照升序排序，也可以使用ORDER BY子句进行降序排序，这需要指定DESC关键字。 SELECT prod_id, prod_price, prod_name FROM Products ORDER BY prod_price DESC; 过滤数据 使用WHERE子句可以指定搜索条件。 SELECT prod_name, prod_price FROM Products WHERE prod_price = 3.49; WHERE子句有多个操作符。 操作符 说明 = 等于 &lt;&gt;, != 不等于 &lt;, &lt;= 小于（等于） !&lt; 不小于 &gt;, &gt;= 大于（等于） !&gt; 不大于 BETWEEN 在指定的两个值之间 IS NULL 为空值 举一些例子： -- != SELECT vend_id FROM Products WHERE vend_id != 'DLL01'; -- BETWEEN SELECT prod_name, prod_price FROM Products WHERE prod_price BETWEEN 5 AND 10; 对于空值，需要使用IS NULL来检查。 WHERE中的条件可以组合，这需要使用AND和OR关键字。 -- AND SELECT prod_id, prod_price, prod_name FROM Products WHERE vend_id = 'DLL01' AND prod_price &lt;= 4; -- OR SELECT prod_name, prod_price FROM Products WHERE vend_id = 'DLL01' OR vend_id = ‘BRS01’; 当同时使用OR和AND时，会先求解AND，然后求解OR。为此可以用括号来指定优先级。 有时，可以使用IN来表示筛选条件。 SELECT prod_name, prod_price FROM Products WHERE vend_id IN ( 'DLL01', 'BRS01' ) 这样写比使用OR更为清晰。 NOT用于否定其后的条件。 通配符 通配符本身实际上是 SQL 的WHERE 子句中有特殊含义的字符，SQL 支持几种通配符，为了使用通配符搜索子句，需要使用LIKE操作符。LIKE指示 DBMS，后跟的搜索模式利用通配符匹配而不是简单的相等匹配进行比较。 通配符只能用于文本字段。 注意，通配符花费使用更高的代价，所以如果能使用其他的操作符达到相同的目的，尽量不要使用通配符。如果要使用通配符，尽量不要用在搜索模式的开始处，这样是最慢的。 % %表示任意字符出现任意次数（0 次、1 次、多次）。 SELECT prod_id, prod_name FROM Products WHERE prod_name LIKE '%bean bag%'; 这个语句搜索所有包含bean bag的字段。 _ _匹配任意字符一次。 SELECT prod_id, prod_name FROM Products WHERE prod_name LIKE '__ inch%'; 这个通配符指明了字符的数量。 [] []用于指定一个字符集，必须匹配指定位置的一个字符。 SELECT cust_contact FROM Customers WHERE cust_contact LIKE '[JM]%' ORDER BY cust_contact; 搜索所有以J或者M开头的字段。 这个通配符可以使用^作为前置来否定，即查找补集。 如果使用Access的话，需要用!来否定。 计算字段 字段（field）基本和列是一个意思。一般来说，计算字段用于格式化和转换数据。在数据库服务器上完成这些工作要比客户端中更快。 拼接字符串 拼接的方法在不同的 DBMS 中不同。通常使用+和||来拼接。 -- + SELECT vend_name + '(' + vend_country + ')' FROM Vendors ORDER BY vend_name; -- || SELECT vend_name || '(' || vend_country || ')' FROM Vendors ORDER BY vend_name; 在 MySQL 和 MariaDB 中，需要使用特殊的方法。 SELECT Concat(vend_name, '(', vend_country, ')') FROM Vendors ORDER BY vend_name; 有许多数据库会将字段之间用空格填充，但是我们很可能不需要这些空格。我们可以使用RTRIM函数来去掉右边的空格。 SELECT RTRIM(vend_name) + '(' + RTRIM(vend_country) + ')' FROM Vendors ORDER BY vend_name; LTRIM去掉左边的空格，TRIM去掉所有空格。 使用别名 拼接字段地址之后，新计算出来的列没有名字。我们可以给它一个别名，使用AS关键字。 SELECT Concat(vend_name, '(', vend_country, ')') AS vend_title FROM Vendors ORDER BY vend_name; 执行算术计算 可以使用四则运算符来对字段进行计算。 SELECT prod_id, quantity, item_price, quantity*item_price AS expanded_price FROM OrderItems WHERE order_num = 20008; 函数 SQL 也可以使用函数来处理数据。 SQL 函数所存在的问题 每一个 DBMS 都有特定的函数，只有少数几个函数被主要的 DBMS 等同地支持。虽然所有类型的函数一般都可以在每个 DBMS 中使用，但是各个函数的名称和语法可能极其不同。 大多数 SQL 实现支持以下类型的函数。 用于处理字符串的文本函数。 用于再数值数据上进行算术操作的数值函数。 用于处理日期和时间值并从这些值中提取特定成分的日期和时间函数。 返回 DBMS 正使用的特殊信息的系统函数。 文本处理函数 UPPER()，将字符串转化为大写； LOWER()，将字符串转化为小写； LEFT()，返回字符串左边的字符； RIGHT()，返回字符串右边的字符； LENGTH()，返回字符串长度； LTRIM()； RTRIM()； SOUNDEX()，返回字符串的 SOUNDEX 值。 SOUNDEX用于将任何文本串转换为描述其语音表示的字母数字模式算法。在 Access 和 PostgreSQL 不支持SOUNDEX，在创建 SQLite 是如果使用了SQLITE_SOUNDEX，那么就可以使用，否则不行。 日期和时间处理 日期和时间采取相应的数据类型存储在表中，每种 DBMS 都有自己的特殊形式。日期和时间以特殊格式存储，以便快速高效地排序、过滤，并节省空间。 应用程序一般不使用日期和时间的存储格式，因此日期和时间函数总是用来读取和统计、处理这些值。因此，日期和时间处理函数很重要，但是可移植性最差。 具体的处理函数需要查阅相关文档。 数值处理函数 ABS()，绝对值； COS()，余弦值； EXP()，指数值； PI()，圆周率； SIN()，正弦值； TAN()，正切值； SQRT()，平方根。 聚集函数 有时候我们需要汇总数据而不是实际检索，SQL 提供了五个聚集函数。 AVG()，返回某列的平均值； COUNT()，返回某列的非空行数； MAX()，返回某列最大值； MIN()，返回某列最小值； SUM()，返回某列之和。 使用DISTINCT可以只对不同的值进行计算。 数据分组 创建分组 通过GROUP BY子句可以对数据进行分组。 SELECT vend_id, COUNT(*) AS num_prods FROM Products GROUP BY vend_id; 指定GROUP BY之后就可以对每个分组进行一次计算，输出这一次的计算结果，并按照分组 ID 进行排序。 分组可以嵌套。建立分组时，所有列一起计算。在分组时不能使用别名。GROUP BY子句必须出现在WHERE子句之后，ORDER BY子句之前。 过滤分组 使用HAVING子句来过滤分组，使用方法和WHERE过滤行一致。 可以同时使用WHERE和HAVING关键字。 SELECT vend_id, COUNT(*) AS num_prods FROM Products WHERE prod_price &gt;= 4 GROUP BY vend_id HAVING COUNT(*) &gt;= 2; SELECT 子句顺序 子句 说明 SELECT 要返回的列或表达式 FROM 从中检索数据的表 WHERE 行级过滤 GROUP BY 分组说明 HAVING 组级过滤 ORDER BY 输出排序顺序 子查询 查询是可以嵌套的，可以使用查询的结果作为下一次查询的筛选。 SELECT cust_name, cust_contact FROM Customers WHERE cust_id IN ( SELECT cust_id FROM Orders WHERE order_num IN ( SELECT order_num FROM OrderItems WHERE prod_id = 'RGAN01' ) ) 子查询也可以作为计算字段。 SELECT cust_name, cust_state, ( SELECT COUNT(*) FROM Orders WHERE Orders.cust_id = Customers.cust_id ) AS orders FROM Customers ORDER BY cust_name; 联结表 联结是关系表的基础，可以简化检索。 创建联结 指定要联结的所有表和关联它们的方式即可。 SELECT vend_name, prod_name, prod_price FROM Vendors, Products WHERE Vendors.vend_id = Products.vend_id; 如果直接选中而不使用WHERE创建联结，那么就会返回两个表格的笛卡尔积，这样的结果一般是错误的。 上面的联结称为等值联结，基于两个表直接的相等测试。这种联结也称为内联结。可以使用稍微不同的语法使用这种联结。 SELECT vend_name, prod_name, prod_price FROM Vendors INNER JOIN Products ON Vendors.vend_id = Products.vend_id; 这个语句和上面的结果完全一样，但是使用了INNER JOIN和ON。 表别名 可以给表设置别名。这样可以缩短 SQL 语句，也可以在一条 SELECT 语句中多次使用相同的表。 SELECT cust_name, cust_contact FROM Customers AS C, Orders AS O, OrderItems AS OI WHERE C.cust_id = O.cust_id AND OI.order_num = O.order_num AND prod_id = 'RGAN01'; 其他联结 还有三种其他联结：自联结、自然联结、外联结。 自联结 如果需要搜索出一条信息的某个字段，然后使用这个字段来过滤同一个表中的数据，那么就可以使用到自联结。 -- 不使用自联结 SELECT cust_id, cust_name, cust_contact FROM Customers WHERE cust_name = ( SELECT cust_name FROM Customers WHERE cust_contact = 'Jim Jones' ); -- 使用自联结 SELECT c1.cust_id, c1.cust_name, c1.cust_contact FROM Customers AS c1, Customers AS c2 WHERE c1.cust_name = c2.cust_name AND c2.cust_contact = 'Jim Jones'; 自然联结 SELECT C.*, O.order_num, O.order_date, OI.prod_id, OI.quantity, OI.item_price FROM Customers AS C, Orders AS O, OrderItems AS OI WHERE C.cust_id = O.cust_id AND OI.order_num = O.order_num AND prod_id = 'RGAN01'; 自然联结的意义在于，不返回相同的列。通常，对第一个表使用通配符，其后的表指定列的子集。 外联结 联结是将表的行与行相关联，有时候我们会需要使用那些没有关联的行。 SELECT Customers.cust_id, Orders.order_num FROM Customers LEFT OUTER JOIN Orders ON Customers.cust_id = Orders.cust_id; 这个语句会返回没有订单的顾客。之所以返回的是没有订单的顾客而不是没有顾客的订单，是因为指定了LEFT。LEFT表面主表是Customers。同样可以使用RIGHT。也可以使用FULL，这种称为全外联结。 组合查询 使用UNION操作符可以将多条 SELECT 语句组合成一个结果集合。 SELECT cust_name, cust_contact, cust_email FROM Customers WHERE cust_state IN ('IL','IN','MI') UNION SELECT cust_name, cust_contact, cust_email FROM Customers WHERE cust_name = 'Fun4All'; 这个例子中，使用UNION比使用多个WHERE子句要复杂。 注意每个UNION的查询都需要包含相同的列、表达式或者聚集函数，不过次序可以不同。 UNION默认是去除重复的行的，如果需要显示，需要使用UNION ALL。 如果需要排序，ORDER BY需要放在最后。 插入数据 INSERT，用于将行插入到数据库表中。可以插入完整的行、行的一部分、或者某些查询的结果。 INSERT INTO Customers VALUES( '1000000006', 'Toy Land', '123 Any Street', 'New York', 'NY', '11111', 'USA', NULL, NULL ); 上面这种是一般的插入方法，不过不太推荐，这样不太安全，因为依赖于列的定义次序。 更好的方法是下面这样： INSERT INTO Customers( cust_id, cust_name, cust_address, cust_city, cust_state, cust_zip, cust_country, cust_contact, cust_email ) VALUES( '1000000006', 'Toy Land', '123 Any Street', 'New York', 'NY', '11111', 'USA', NULL, NULL ) 这种方式指定了列名，在插入行时，VALUES 会严格按照指定的列名插入。 同样，可以插入部分行。 INSERT 可以与 SELECT 结合，插入检索出的数据。 INSERT INTO Customers( cust_id, cust_contact, cust_email, cust_name, cust_address, cust_city, cust_state, cust_zip, cust_country ) SELECT cust_id, cust_contact, cust_email, cust_name, cust_address, cust_city, cust_state, cust_zip, cust_country FROM CustNew; 要想将一个表的内容复制的一个全新的表中，可以使用 SELECT INTO 语句。 SELECT * INTO CustCopy FROM Customers; 当然，如果是 MySQL、MariaDB、Oracle、PostgreSQL 和 SQLite 就需要使用另一种语法： CREATE TABLE CustCopy AS SELECT * FROM Customers; 更新和删除数据 使用 UPDATE 时不要省略 WHERE 子句，否则会直接更新表中的所有行。 UPDATE Customers SET cust_contact = 'Sam Roberts', cust_email = 'kim@thetoystore.com' WHERE cust_id = '1000000005'; 如果要删除某一行的某一列，就可以把它修改为 NULL。 UPDATE Customers SET cust_email = NULL WHERE cust_id = '1000000005'; 如果需要删除整行的数据，需要使用 DELETE。和 UPDATA 一样，如果没有筛选，就会删除所有行。 DELETE FROM Customers WHERE cust_id = '1000000006'; 如果需要删除整个表，那么不应该使用 DELETE，应该使用更快的 TRUNCATE TABLE，它不记录数据的变动。 创建和操作表 创建表 使用 CREATE TABLE 可以创建表，必须给出： 新表的名字； 表列的名字和定义； 有的 DBMS 还要求指定表的位置。 CREATE TABLE Products ( prod_id CHAR(10) NOT NULL, vend_id CHAR(10) NOT NULL, prod_name CHAR(254) NOT NULL, prod_price DECIMAL(8,2) NOT NULL, prod_desc VARCHAR(1000) NULL ); 在不同的 DBMS 中，参数有所不同。比如在 MySQL 中，varchar就需要替换为text。 最后一列指定该列是否接受 NULL 值。如果不接受，那么插入行时这一列不能没有值。 如果不设置为 NOT NULL，那么默认是 NULL。 可以对列设置默认值。 CREATE TABLE OrderItems ( order_num INTEGER NOT NULL, order_item INTEGER NOT NULL, prod_id CHAR(10) NOT NULL, quantity INTEGER NOT NULL DEFAULT 1, item_price DECIMAL(8,2) NOT NULL ); 默认值经常用于日期或者时间戳列，比如用系统日期作为默认日期。MySQL 中使用DEFAULT CURRENT_DATE()。获取系统日期的函数在各个 DBMS 中几乎都是不同的。 更新表 需要更新表定义时，使用 ALTER TABLE。有几点需要注意： 理想情况下，不要在表中有数据时对其进行更新； 所有 DBMS 都允许给现有的表增加列，不过对所增加列的数据类型有限制； 许多 DBMS 不允许删除或更改列； 多数 DBMS 允许重新命名表中的列； 许多 DBMS 限制对有数据的列进行更改，对没有数据的列几乎没有限制。 具体内容需要查询具体 DBMS 的文档。 -- 增加列 ALTER TABLE Vendors ADD vend_phone CHAR(20); -- 删除列 ALTER TABLE Vendors DROP COLUMN vend_phone; 删除表和重命名表 删除使用 DROP TABLE 语句即可： DROP TABLE CustCopy; 重命名的语句有所不同，MySQL 使用 RENAME。 视图 视图是虚拟的表。与包含数据的表不同，视图只包含使用时动态检索数据的查询。视图有许多的应用。 简化 SQL 操作，可以方便地重用它而不必知道基本查询细节； 使用表的一部分而不是整个表； 保护数据，授予用户表的特定部分的访问权限，而不是整个表的访问权限； 更改数据格式和表示，视图可以返回与底层表示和格式不同的数据。 创建视图 使用 CREATE VIEW 创建视图。 最常见的视图应用时隐藏复杂的 SQL。 CREATE VIEW ProductCustomers AS SELECT cust_name, cust_contact, prod_id FROM Customers, Orders, OrderItems WHERE Customers.cust_id = Orders.cust_id AND OrderItems.order_num = Orders.order_num; 通过视图，可以将复杂 SQL 的结果保存，多次使用。 存储过程 有时候，完成一件工作需要多次执行多条 SQL 语句。此外，需要执行的具体 SQL 语句及其次序也不是固定的。所以可以用到存储过程。 存储过程类似于自定义的函数。 执行存储过程 存储过程的执行只需要使用 EXECUTE 即可。 管理事务处理 当我们需要执行一段 SQL 指令，并确保它完全执行，否则完全不执行时，可以使用事务处理。它就像是代码管理时所使用的一样，当我们执行指令后，可以回退指令，也可以保存更改。执行指令之后并不是真正的结果。 -- 开始一段事务处理 START TRANSACTION INSERT ...; -- 检查点 SAVEPOINT a; DELETE ...; UPDATE ...; -- 如果没有出错，到这里结束 COMMIT; -- 回退到指定检查点 ROLLBACK TO a; 以上语法适用于 MySQL。 游标 游标就是指针，当我们检索完毕之后，游标停留在最后一个位置，可以从这个位置向下检索。游标一般在存储过程中使用。 使用游标之前，需要声明它。一旦声明，就必须打开游标以便使用。结束使用时，应当关闭游标，可能的话，释放游标。 创建游标 使用 DECLARE 语句创建游标，这条语句在不同的 DBMS 中有所不同。 DECLARE CustCursor CURSOR FOR SELECT * FROM Customers WHERE cust_email IS NULL; 使用游标 使用 OPEN CURSOR 打开游标。 OPEN CustCursor; 关闭游标 CLOSE CustCursor; 高级 SQL 特性 约束 我们会需要保证插入的数据的合法而有意义的，但是如果要自己来检查它会比较耗时费力。所以可以把这个工作交给 DBMS。 主键 这里我们会用到主键。 对于主键，我们可以创建它。 CREATE TABLE Vendors ( vend_id CHAR(10) NOT NULL PRIMARY KEY, vend_name CHAR(50) NOT NULL, vend_address CHAR(50) NULL, vend_city CHAR(50) NULL, vend_state CHAR(5) NULL, vend_zip CHAR(10) NULL, vend_country CHAR(50) NULL ) 其中的vend_id就是主键。 也可以使用 CONSTRAINT 语法添加。 ALTER TABLE Vendors ADD CONSTRAINT PRIMARY KEY (vend_id); 外键 定义外键的意义在于，定义值的合法性。这一列的值必须在另一个表中存在。 CREATE TABLE Orders ( order_num INTEGER NOT NULL PRIMARY KEY, order_date DATETIME NOT NULL, cust_id CHAR(10) NOT NULL REFERENCES Customers(cust_id) ); 也可以在 ALTER TABLE 语句中用 CONSTRAINT 完成。 ALTER TABLE Orders ADD CONSTRAINT FOREIGN KEY (cust_id) REFERENCES Customers (cust_id) 唯一约束 唯一约束用来保证一列（或一组列）中的数据是唯一的。 表可包含多个唯一约束，但每个表只允许一个主键。 唯一约束列可包含 NULL 值。 唯一约束列可修改或更新。 唯一约束列的值可重复使用。 与主键不一样，唯一约束不能用来定义外键。 使用 UNIQUE 定义。 检查约束 检查约束用来保证一列（或一组列）中的数据满足一组指定的条件。 CREATE TABLE OrderItems ( order_num INTEGER NOT NULL, order_item INTEGER NOT NULL, prod_id CHAR(10) NOT NULL, quantity INTEGER NOT NULL CHECK (quantity &gt; 0), item_price MONEY NOT NULL ); 索引 索引可以让 DBMS 保存一个按某个键值排序的列表，改善检索操作的性能。但是这会降低数据插入、修改和删除的性能。 索引用 CREATE INDEX 语句创建。索引必须唯一命名。 CREATE INDEX prod_name_ind ON Products (prod_name); 触发器 触发器是特殊的存储过程，在发生特定的数据库活动时自动执行。 触发器与单个表相关联，具有以下数据的访问权： INSERT 操作中的所有新数据； UPDATE 操作中的所有新数据和旧数据； DELETE 操作中删除的数据。 ","link":"https://wzhzzmzzy.github.io/post/2018-3-7-SQL入门"},{"title":"SQL 练习题（LeetCode）","content":"SQL 练习 - LeetCode 626. Exchange Seats 626. Exchange Seats 自解 SELECT a.id, b.student FROM seat AS a, seat AS b WHERE (a.id % 2 = 1 AND b.id - 1 = a.id) OR (a.id % 2 = 0 AND b.id + 1 = a.id) UNION SELECT id, student FROM seat WHERE id = (SELECT MAX(id) FROM seat) AND id % 2 = 1 ORDER BY id; 更优解 SELECT ( CASE WHEN id % 2 = 1 AND id = (SELECT MAX(id) FROM seat) then id WHEN id % 2 = 1 THEN id + 1 ELSE id - 1 END ) AS id, student from seat ORDER BY id; 175. Combine Two Tables 175. Combine Two Tables 解法 外联结（左连接）。 SELECT FirstName, LastName, City, State FROM Person LEFT JOIN Address ON Person.PersonId = Address.PersonId; 197. Rising Temperature 197. Rising Temperature 解法 有个小坑点，日期直接求差值需要用DATEDIFF()， SELECT a.Id FROM Weather As a, Weather AS b WHERE DATEDIFF(a.date, b.date) = 1 AND a.Temperature &gt; b.Temperature; 596. Classes More Than 5 Students 596. Classes More Than 5 Students 解法 DISTINCT可以用在COUNT里。 SELECT class FROM courses GROUP BY class HAVING COUNT(DISTINCT student) &gt;= 5; 196. Delete Duplicate Emails 196. Delete Duplicate Emails 解法 自联结。 DELETE a FROM Person AS a, Person AS b WHERE a.Email = b.Email AND a.Id &gt; b.Id; 176. Second Highest Salary 176. Second Highest Salary 自解 SELECT MAX(Salary) AS SecondHighestSalary FROM Employee WHERE Salary NOT IN ( SELECT MAX(Salary) FROM Employee ); 更优解 利用LIMIT和ORDER BY。（这种解法会 WA，因为在只有一个字段的表中会返回空，但要求返回 NULL） SELECT Salary AS SecondHighestSalary FROM Employee ORDER BY Salary DESC LIMIT 1 OFFSET 1; 178. Rank Scores 178. Rank Scores 解法 SELECT 语句也可以闭包。 SELECT Score, ( SELECT COUNT(DISTINCT Score)+1 FROM Scores WHERE Score &gt; a.Score ) AS Rank FROM Scores AS a ORDER BY Score DESC; ","link":"https://wzhzzmzzy.github.io/post/2018-3-7-SQL题（Leetcode）"},{"title":"C++ 学习记录（三）—— C++ 中的 OOP","content":"OOP 抽象函数称为虚函数，基类希望派生类自己定义自己的版本。 派生类使用类派生列表来指明继承了哪些类。列表中基类用逗号隔开，基类名前可以有访问说明符。 派生类用override显式地注明用哪个方法重写基类的虚函数。 class Quote { public: virtual double net(int n) const; } class Bulk_Quote : public Quote { public: double net(int) const override; } 使用引用类型接受形参时，基类类型的形参可以接受派生类的参数，编译器根据具体参数来决定使用哪个成员。这个特性称为动态绑定。 void test(const Quote &amp;q, int n) { return q.net(n); } 基类的定义 基类定义时，通常会定义一个虚析构函数。 基类必须将两种成员函数区分开，一种是基类希望派生类重写的函数，另一种是希望派生类不要改变的函数。前者通常定义为虚函数。当使用指针或者引用调用虚函数时，调用将会被动态绑定。根据引用或者指针绑定的对象类型不同，调用执行不同的版本。 任何构造函数之外的非静态函数都可以是虚函数。virtual只能出现在类内部，而不能出现在类外部的函数定义。 如果基类把一个函数声明为虚函数，那么在派生类中隐式地也是虚函数。 对于protected成员，只有派生类可以访问。 派生类的定义 类派生列表接受public，protected，private三种访问说明符。 派生类必须重新声明需要覆盖的成员函数。 因为在派生类对象中含有与基类相应的组成部分，所以能把派生类对象当成基类对象使用，也能将基类指针和引用绑定到派生类对象上，但是只能使用基类部分。 派生类需要使用基类的构造函数来初始化基类部分。派生类只能访问基类的公共和受保护成员。 声明中添加final可以防止继承的发生。 class Test final : Base { /* */ }; 继承与类型转换 一个对象的指针指向的可能是基类实例也可能派生类的实例，这无法确定。所以要将动态类型和静态类型区分开。声明时的类型为静态类型，否则是动态类型。 不存在从基类向派生类的隐式类型转换。在指针和引用之间才会有自动类型转换，类型对象之间没有。 虚函数 使用基类指针或引用调用一个虚成员函数时会执行动态绑定。 使用override来标记重写了的基类中的虚函数，有助于编译器帮助发现错误。 虚函数也可以有默认实参，实参值由调用时的静态类型决定。 可以强行指定需要调用的虚函数而不使用动态绑定。 double ud = bp-&gt;Base::net(42); 抽象基类 对于不想实现的，作为模板的函数，可以声明为纯虚函数。含有纯虚函数的类就是抽象基类。 class Disc_quote : public Quote { public: Disc_quote() = default; double net(int n) const = 0; // 纯虚函数 } 对于一个抽象基类来说，它的意义只在于一个通用的模板，不能创建实例。 纯虚函数可以拥有定义，但是定义必须在类的外部。 访问控制与继承 派生类的成员或者友元只能通过派生类对象来访问基类的受保护成员，不能直接访问。 class Base { protected: int n; } class Hhhh : public Base { friend void f(Hhhh&amp;); friend void f(Base&amp;); } void f(Hhhh &amp;h) { cout &lt;&lt; h.n; } // 正确 void f(Base &amp;b) { cout &lt;&lt; b.n; } // 不能访问 派生访问控制符的目的是控制派生类用户对于基类成员的访问权限，它还可以控制继承自派生类的新类的访问权限。 友元关系不传递也不继承。 使用using声明可以改变继承的某个名字的访问级别。 class Base { public: size_t size() const { return n; } protected: size_t n; } class Derived: private Base { public: using Base::size; protected: using Base::n; } 使用class声明的类的默认继承是private的，而struct是public的。 继承中的类作用域 一个对象、引用或者指针的静态类型决定了该对象的哪些成员是可见的。即使静态类型与动态类型不一致，但是我们能使用哪些成员依然由静态类型决定。 派生类可以重用在基类中使用过的名字，这些名字将会隐藏基类中的名字。即使形参列表不一致，基类中的成员也会被隐藏。 可以使用作用域运算符来指定使用隐藏的成员：::。 构造函数和拷贝控制 虚析构函数 基类通常应该定义一个虚析构函数，这样就能动态分配继承体系中的对象了。定义成虚函数是为了使用动态绑定，能够正确地按照动态类型销毁实例。 继承构造函数 派生类能够直接重用基类的构造函数。using声明没有办法改变构造函数的访问级别。默认、拷贝和移动构造函数不会被继承，这些构造函数按照正常规则被合成。 基类的构造函数含有默认实参时，这些实参不会被继承，但是派生类将会获得多个继承的构造函数。每个构造函数分别省略一个含有默认实参的形参。 容器与继承对象 当我们要在容器中存放继承体系的对象时，为了使用动态类型，最好存放基类类型的指针，最好是动态指针。 由于指针会提升程序的复杂程度，所以有时候会编写辅助类来帮助完成封装，辅助类会将动态内存和指针操作封装起来，避免用户的不当操作引起问题。 模板 函数模板 tamplate &lt;typename T&gt; int cmp(const T &amp;v1, const T &amp;v2) { if (v1 &lt; v2) return -1; if (v2 &lt; v1) return 1; return 0; } 模板定义从关键字template开始，后面跟一个模板参数列表，其中包含一个或者多个模板参数，用逗号分隔。模板参数使用class或者typename。 模板蚕食表示在类或函数定义中用到的类型或者值。当使用模板时，我们显式地指定模板实参。 模板中也可以定义非类型参数，用于表示值而不是类型。 tamplate &lt;unsigned N, unsigned M&gt; int compare(const char (&amp;p1)[N], const char (&amp;p2)[M]) { return strcmp(p1, p2); } 函数模板可以声明为inline或者constexpr，声明位置在模板参数列表之后，返回类型之前。 编译器与答案一个模板定义时，并不生成代码，只有当实例化出模板的一个特定版本时，编译器才会生成代码。这一特性影响了如何组织代码和错误何时会被检测到。 类模板 tamplate &lt;typename T&gt; class test { public: typedef T value_type; T getValue() { return T n; } test(): n(T()) { } test(T t): n(t) { } private: T n; } 可以为类模板定义别名。 template&lt;typename T&gt; using twin = pair&lt;T, T&gt; twin&lt;string&gt; name; // pair&lt;string, string&gt; 转发 有时候需要将函数的一个或多个实参转发给其他函数。此时，需要保持被转发实参的所有性质。 我们需要使用std::forward来处理未知的左值引用和右值引用。 template &lt;typename F, typename T1, typename, T2&gt; void filp(F f, T1 &amp;&amp;t1, T2 &amp;&amp;t2) { f(std::forward&lt;T1&gt;(t1), std::forward&lt;T2&gt;(t2)); } 标准库的其他设施 tuple 类似pair，但tuple可以有任意数量的成员。 tuple之间可以使用运算符来比较，比较遵从字典序。 get&lt;i&gt;(t)可以获取t中的第i个元素的引用。 tuple可以用于返回多个值。 bitset 声明bitset需要指明大小。 bitset&lt;32&gt; a(1U); // 低位 1，高位 0 bitset&lt;32&gt; b(&quot;1100&quot;); // 从 string 或 char[] 初始化 bitset支持常用的二进制串操作，比如查询置位、复位，输出为字符串、转成整数等等。 ","link":"https://wzhzzmzzy.github.io/post/2018-2-10-Cpp学习记录"},{"title":"C++ 学习记录（二）—— 泛型编程入门及智能指针","content":"泛型算法 大多数泛型算法保存在&lt;algorithm&gt; accumulate accumulate(vec.cbegin(), vec.cend(), 0); // 迭代求和，初始值为0 // 通过 + 运算符求和 equal equal(v1.cbegin(), v1.cend(), v2.cbegin()); // 比较输入的迭代器之间的内容是否全部对应相等 // 通过 == 运算符计算 fill fill(vec.begin(), vec.end(), 0); // 在迭代器范围内填充 file_n file_n(vec.begin(), vec.size(), 0) // 在迭代器之后填充固定数量 back_inserter vector&lt;int&gt; vec; auto it = back_inserter(vec); *it = 42; // 每次调用 it 相当于调用 push_back copy int a1[] = {0, 1, 2, 3}; int a2[sizeof(a1)/sizeof(*a1)]; auto ret = copy(begin(a1), end(a1), a2); // copy 返回拷贝之后的位置 unique auto end_unique = unique(words.begin(), words.end()); // unique 返回去重后的尾端 // 需要保证重复位置是连续的 erase words.erase(end_unique, words.end()); // 删除容器迭代器之间的位置 sort sort(words.begin(), words.end()); sort(words.begin(), words.end(), cmp); stable_sort(words.begin(), words.end()); // sort 为不稳定排序 // stable_sort 为稳定排序 transform transform(v.begin(), v.end(), v.begin(), f); // 对前两个迭代器之间的所有元素调用 f // 结果填充到第三个迭代器的位置 find_if auto wc = find_if(words.begin(), words.end(), cmp); // 返回迭代器，指向第一个满足 cmp 的元素 for_each for_each(wc, words_end(), f); // 对迭代器之间的所有元素，调用 f lambda表达式 auto cmp = [](const string &amp;a, const string &amp;b) { return a.size() &lt; b.size(); } bool isShort(const string &amp;a, const string &amp;b) { return a.size() &lt; b.size(); } // 这两个函数等价 lambda表达式包含[捕获列表]，(参数列表)以及{函数体}。 捕获列表意为lambda表达式内部需要使用的外部函数局部变量。如果未捕获，那么表达式内部就无法使用。 一般的捕获为值捕获，即lambda表达式会获取一个变量的值拷贝。同样可以通过引用来获取捕获。当使用流时，会需要使用到引用捕获。 可以直接在lambda表达式中使用变量而不需要在捕获列表中声明。此时需要在捕获列表中说明是值捕获（=）还是引用捕获（&amp;）。隐式捕获和显式捕获可以共存。 [&amp;, c] (const string &amp;s) { os &lt;&lt; s &lt;&lt; c; } [=, &amp;os] (const string &amp;s) { os &lt;&lt; s &lt;&lt; c; } 当混合使用显式捕获和隐式捕获时，捕获列表第一个参数必须是&amp;或者=，它指定了默认捕获方式。 如果要改变捕获的参数值，那么就需要声明mutable。 [v1] () mutable { return ++v1; } 如果一个lambda体包含return之外的语句，那么编译器就假定其返回void。 [] (int i) { return i &lt; 0 ? -i : i; } // 无错误 [] (int i) { if (i &lt; 0) return -i; else return i; } // 报错 [] (int i) -&gt; int { if (i &lt; 0) return -i; else return i; } // 正确 bind bind声明于&lt;placeholders&gt;。 bind接受一个可调用对象和一个参数列表，生成一个新的可调用对象。使用bind函数，可以将函数柯里化。 auto nf = bind(f, _2, _1, arg); 其中的_1，_2是占位符，表示f所需要的第一个、第二个参数。绑定之后，调用nf时会需要两个参数，按照bind的顺序填入占位符当中。也就是说nf(_1, _2)等价于f(_2, _1, arg)。 但是要注意一下，bind直接接受的参数为值传递，如果要传递引用的话需要使用到ref函数。 bind(print, ref(os), _1, ' '); 迭代器 除了每个容器自己的迭代器之外，还定义了额外几种迭代器。 插入迭代器：绑定到容器上，用于插入元素。 流迭代器：绑定到流上，用来遍历所关联的IO流。 反向迭代器：向后而不是向前移动的迭代器，除了forward_list之外的容器都有。 移动迭代器：不用于拷贝元素，而是移动它们。 插入迭代器 插入器是一种迭代器适配器，接受一个容器，生成一个迭代器，能给容器添加元素。当对一个插入迭代器赋值时，这个迭代器调用容器操作来给指定容器的指定位置插入一个元素。 back_inserter，创建一个使用push_back的迭代器。 front_inserter，创建一个使用push_front的迭代器。 inserter，创建一个使用insert的迭代器。这个函数接受第二个参数，插入到给定迭代器所表示的元素之前。 inserter的行为如下。 auto it = inserter(c, iter); *it = val; // 这一行等同于下面两行 it = c.insert(it, val); ++it; front_inserter与inserter完全不同。 list&lt;int&gt; lst = {1, 2, 3, 4}; list&lt;int&gt; lst2, lst3; // 空 copy(lst.cbegin(), lst.cend(), front_inserter(lst2)); copy(lst.cbegin(), lst.cend(), inserter(lst3, lst3.begin())); // lst2 4 3 2 1 // lst3 1 2 3 4 iostream迭代器 istream_iterator&lt;int&gt; int_it(cin); // 从 cin 读取 int istream_iterator&lt;int&gt; int_eof; // 尾后迭代器 ifstream in(&quot;afile&quot;); istream_iterator&lt;string&gt; str_it(in); // 从 afile 读取字符串 while (int_it != int_eof) vec.push_back(*in_iter++); 空的istream_iterator可以作为尾后迭代器来使用。一个绑定到流的迭代器，当遇到EOF或者 IO 错误时，值就与尾后迭代器相等。 使用流迭代器可以构造容器。 istream_iterator&lt;int&gt; in_iter(cin), eof; vector&lt;int&gt; vec(in_iter, eof); istream_iterator允许惰性求值。 我们可以对任何具有输出运算符的类型定义ostream_iterator。当创建时，必须要绑定一个流，不允许空的ostream_iterator。创建时，可以提供可选的第二参数，它是一个 C 风格字符串，每次输出一个元素后都会打印这个字符串。 ostream_iterator&lt;int&gt; out_iter(cout, &quot; &quot;); for (auto e: vec) *out_iter++ = e; cout &lt;&lt; endl; 事实上，*out_iter++完全可以被替换为out_iter，但是保持解引用和自增运算符可以与其他的迭代器使用保持一致，可以更加方便地替换为其他迭代器类型。 反向迭代器 对于反向迭代器，递增（++）会移动到前一个元素，递减（--）会移动到下一个元素。 调用base()可以转换为普通迭代器。 泛型算法结构 任何算法的最基本特征是它要求其迭代器提供那些操作。某些算法，如find，只要求通过迭代器访问元素、递增迭代器以及比较两个迭代器是否相等这些能力。其他算法还要求读、写和随机访问。迭代器按照这些分为五类。 输入迭代器； 输出迭代器； 前向迭代器； 双向迭代器； 随机访问迭代器。 关联容器 关联容器中的元素是按照关键字来保存和访问的。与之相对的，顺序容器中的元素是按照它们在容器中的位置来顺序保存和访问的。 关联容器支持高校的关键字查找和访问。两个主要的关联容器的map和set。map中的元素是一些key-value对， set只包含一个关键字，支持高效的查询操作。 共有八个关联容器，有三个条件。 set或map； 关键字可重复或不可重复，multi； 保存元素按顺序或无序，unordered_。 无序集合是由哈希表构成，有序集合由红黑树构成。 有序集合所使用的类型必须存在比较函数，或者&lt;运算符。如果需要使用比较函数来定义，那么就需要一个函数指针参数。 multiset&lt;className, decltype(cmp)*&gt; mp(cmp); pair pair类型在&lt;utility&gt;中。一个pair保存两个数据成员，类似于容器，pair是一个用来生成特定类型的模板，当创建一个pair时，我们必须提供两个类型名，pair的数据成员将具有对应的类型。 pair&lt;string, int&gt; author{&quot;Amber&quot;, 12}; 与其他标准库类型不同，pair的数据成员是public的，两个成员分别命名为first和second。 对于一个需要返回pair对象的函数，可以对返回值进行列表初始化。 pair&lt;string, int&gt; process(vector&lt;string&gt; &amp;v) { if (!v.empty()) return {v.back(), v.back().size()}; else return pair&lt;string, int&gt;(); } 也可以用make_pair函数来构造pair对象，类型自动判定。 make_pair(v.back(), v.back().size()); 关联容器操作 关联容器定义了几种类型。 key_type，关键字的类型。 mapped_type，值的类型，set中等同于关键字类型。 value_type，在map中为pair&lt;const key_type, mapped_type&gt;，在set中也等同于关键字类型。 迭代器 map&lt;string, int&gt; mp; auto map_it = mp.begin(); // map_it 的类型为 pair&lt;string, int&gt; set&lt;int&gt; iset = {1, 2, 3, 4}; set&lt;int&gt;::iterator set_it = iset.begin(); // set 的迭代器是 const 的 可以使用通常的手段遍历迭代器（begin()，end()）。 插入、删除、查询 对于不可重复容器，插入已存在的元素不会有影响。 插入可以直接使用花括号列表，也可以构造pair对象。 insert或者emplace的返回值是一个pair，first是一个迭代器，指向刚才插入的元素，second是一个bool值，返回是否插入成功。 有三个版本的erase，可以传入迭代器、迭代器对，这两个版本返回void。另一个版本接受一个key_type，返回删除的元素数量。 map和unordered_map提供了下标运算符和一个对应的at函数。set不支持下标，multimap和unordered_multimap也不可以。 map中，下标运算符接受一个关键字，获取与这个关键字相关联的值，与下标运算符不同的是，如果关键字不在map中，会创建一个元素并插入map。但是at运算符只能查询，不能插入。 如果想单纯查询，那么应该使用find方法。 当使用multimap和multiset时，find会返回第一个满足关键字的元素，向后递增就可以获得其他的元素。 查找可以使用lower_bound和upper_bound，这两个方法接受一个关键字，返回一个迭代器。如果关键字存在，那么返回找到的第一个位置和最后一个之后的位置，如果不存在，那么返回插入且不影响排序的位置。 注意lower_bound和upper_bound可能返回尾后迭代器，且只能在有序容器中使用。 equal_range等同于同时调用上面两个函数，它返回pair，first指向第一个与关键字匹配的元素，second指向最后一个元素之后的位置。 无序容器 无序容器不使用比较运算符来组织元素，而是使用哈希函数和关键字类型的==运算符。 无序容器在存储上组织为一组桶，每个桶保存零个或者多个元素。容器使用哈希函数将元素映射到桶，为了访问一个元素，首先计算元素的哈希值，指出应该搜索哪个桶。 因此，无序容器的性能依赖于哈希函数的质量和桶的数量和大小。 对于相同的参数，哈希函数必须总是产生相同的结果。 无序容器提供了一系列的哈希管理操作。 bucket_count()，正在使用的桶数目； max_bucket_count()，容器最多能容纳的桶数目； bucket_size(n)，第n个桶有多少元素； bucket(k)，关键字为k的元素在哪个桶中； local_iterator，桶中元素的迭代器； const_local_iterator； begin(n), end(n)，桶n的迭代器； cbegin(n), cend(n)； load_factor()，桶内元素的平均数量，float类型； max_load_factor()，试图维护的平均桶大小； rehash(n)，暴力重组； reserve(n)，不必rehash地重组。 由于使用哈希，所以会使用hash&lt;key_type&gt;来生成哈希值。当使用自定义类型时，就需要提供hash模板，也可以提交重载函数。 size_t hasher(const Sales_data &amp;sd) { return hash&lt;string&gt;() (sd.isbn()); } bool eqOp(const Salse_data &amp;l, const Salse_data &amp;r) { return l.isbn() == r.isbn(); } unordered_multiset&lt;Sales_data, decltype(hasher)*, decltype(eqOp)*&gt; bookSt(42, hasher, eqOp)&gt;; 动态内存 全局对象在程序启动时分配内存，在程序结束时销毁，局部自动对象在进入代码块时创建，离开时销毁。局部static对象在第一次使用前分配，在程序结束时销毁。 除了自动对象和static对象之外，还支持动态分配对象。 静态内存用于保存局部static对象，类static数据成员，以及定义在任何函数之外的变量。栈内存用来保存定义在函数内的static对象。这两块内存中的对象由编译器自动创建和销毁。 程序还存在一个内存池，称为堆。用于存储动态分配的对象。 动态内存与智能指针 new用于分配空间，返回一个指向这个对象的指针，delete接受一个动态对象的指针，销毁该对象，释放内存。 为了更容易也更安全地使用动态内存，C++11提供了两种智能指针，它们负责自动释放所指向的对象。 shared_ptr允许多个指针指向同一个对象，unique_ptr独占指向的对象。标准库中还有一个weak_ptr，这是一种弱引用，指向shared_ptr所管理的对象。 智能指针的一般操作 shared_ptr&lt;T&gt; sp，空指针； unique_ptr&lt;T&gt; up； *p，解引用p，获取指向的对象； p，用作条件判断； p.get()，获取指针； swap(p, q), p.swap(q)，交换指针。 shared_ptr 智能指针也是模板，所以需要提供类型。 shared_ptr&lt;string&gt; p; 默认初始化的智能指针为nullptr。 使用方式和普通指针相似，解引用时返回指向的对象。 独有操作有以下一些： make_shared&lt;T&gt;(args)，返回一个shared_ptr，指向一个动态分配的类型为T的对象； shared_ptr&lt;T&gt; p(q)，制作一个q的拷贝为p； shared_ptr&lt;T&gt; p(u)，从一个unique_ptr处接管指针； shared_ptr&lt;T&gt; p(q, d)，使用可调用对象d来释放指针； p = q； p.unique()，查看是否p的引用计数为 1； p.use_count()，返回p的引用计数，可能很慢； make_shared 最安全的分配和使用动态内存的方法是使用make_shared函数，这个函数在动态内存中分配一个对象并初始化它，然后返回指向这个对象的shared_ptr。 类似于emplace，make_shared也使用参数来构造给定的对象。如果不传递任何参数，那么就会进行值初始化。 拷贝、赋值、析构 拷贝之后，引用计数会增加，重新赋值或者销毁之后，计数器就会递减。一旦引用计数归零，指针会自动释放所管理的对象。 销毁时会使用到析构函数。类似于构造函数，每个类也会有一个析构函数。析构函数用于释放对象所分配的资源。 动态内存的使用 程序使用动态内存出于以下三种原因之一： 程序不知道自己需要多少对象； 程序不知道所需对象的准确类型； 程序需要在多个对象之间共享数据。 比如容器类，就是因为第一种原因使用动态内存。 但是某些类分配的资源与原对象有相独立的生存期。比如，当一个对象获取另一个对象的拷贝时，希望两个对象共享同一份内存空间中的内容。 直接管理内存 new和delete能够直接管理内存，但是非常容易出错。 int *p = new int; // 默认，值未定义 int *pi = new int(); // 值初始化为 0 string *ps = new string(5, '0'); // 值初始化为&quot;00000&quot; // 可以使用 auto 来创建指针，但是指向必须是单一的初始化器 auto p1 = new auto(obj); // 用 new 分配 const 对象是合法的 const int *pci = new const int(1024); // 当内存耗尽时，会抛出 bad_alloc 异常。可以使用定位 new 来阻止抛出异常 // 定位 new 表达式允许传递额外的参数。nothrow 就是一个标准库中的对象 int *p = new (nothrow) int; // 如果分配失败，会返回一个空指针 delete将动态内存归还给系统。表达式接受一个指针，表示想要释放的对象。 delete p; 当delete之后，指针的值就无效了，但是很多时候指针依然保存着之前的地址，delete之后，指针就变为了空悬指针。所以应该在指针要离开作用域之前释放内存，或者在释放内存之后用nullptr赋予指针。 结合使用shared_ptr和new 我们可以使用new返回的指针来初始化智能函数。 shared_ptr&lt;int&gt; p2(new int(42)); 接受指针参数的智能指针构造函数是explicit的，因此必须使用直接初始化形式来初始化一个智能指针，而不能赋值。出于相同的原因，返回语句中不能隐式转换一个普通指针。 shared_ptr提供了get方法，这个方法返回一个内置指针，用于向不能使用智能指针的代码传递内置指针。使用get方法生成的指针不能被delete，也不能被用于再初始化一个智能指针。 reset可以将shared_ptr指向一个新对象。 unique_ptr 与shared_ptr不同，同一时刻只能有一个unique_ptr指向一个给定对象。当指针被销毁时，指向的对象也被销毁。unique_ptr没有make_shared这样的方法，当定义时，必须绑定一个new返回的指针。 一般操作： unique_ptr&lt;T&gt; u1； unique_ptr&lt;T, D&gt; u2(d)，使用D类型的d来释放指针； u = nullptr； release()，返回指针，放弃指针控制权，置为空； reset()，释放对象； reset(q)，重置指针； reset(nullptr)； 可以拷贝或者赋值一个将要销毁的unique_ptr，一般使用在函数返回值时。 weak_ptr weak_ptr不控制只想对象生存期。它指向一个shared_ptr管理的对象。将一个weak_ptr绑定到一个shared_ptr不会改变引用计数。一旦最后一个指向对象的shared_ptr被销毁，对象就会被释放。 一般操作。 reset()，重置； use_count()，引用计数； expired()，查看是否引用为 0； lock()，返回引用的shared_ptr。 拷贝控制 拷贝构造函数 很多时候编译器会隐式地调用类的拷贝构造函数。 拷贝构造函数的第一个参数必须是引用类型，一般是const的引用。其他的额外参数都有默认值。由于会被隐式调用，所以通常不应该是explicit的。 类类型的成员会使用拷贝构造函数来拷贝，内置类型的成员则直接拷贝。 直接初始化就是直接调用构造函数，拷贝初始化是对一个新定义的对象用赋值符号进行初始化。拷贝初始化一般使用拷贝构造函数，有时也会使用移动构造函数来完成。 除了使用=定义变量时，在以下情况也会发生拷贝初始化。 将一个对象作为实参传递给一个非引用类型的实参； 从一个返回类型为非引用类型的函数返回一个对象； 用花括号列表初始化一个数组中的元素，或者一个聚合类的成员。 某些类类型还会对它们分配的对象使用拷贝初始化，比如insert和push方法，相对的，emplace使用直接初始化。 拷贝赋值运算符 和拷贝构造函数一样，如果类没有定义自己的拷贝赋值运算符，编译器会为它合成一个。 Foo&amp; operator=(const Foo&amp;); // 赋值运算符 析构函数 析构函数的名字由波浪号接类名组成，没有返回值，不接受参数。 ~Foo() { }; 构造函数有一个初始化部分和一个函数体，析构函数也有函数体和析构部分。与构造函数相反，先执行函数体，再进行析构。函数体中执行类的收尾工作。 会执行析构函数的情况有 变量离开作用域时被销毁； 对象被销毁时成员也被销毁； 容器被销毁时，其元素被销毁； 对于动态分配的对象，使用delete时被销毁； 临时对象，创建它的完整表达式结束时被销毁； 类未定义析构函数时，编译器也会为它定义合成析构函数。对于某些类，合成析构函数被用来阻止该类型对象被销毁，否则，合成析构函数函数体为空。 三/五法则 如果一个类需要析构函数，那么一般也会需要一个拷贝构造函数和一个拷贝赋值运算符。当不需要析构函数时，拷贝和赋值操作也是互相需要的。 使用=default 使用=default相当于直接要求编译器生成合成的版本。 class test { public: test() = default; test(const test&amp;) = default; test&amp; operator=(const test &amp;); ~test() = default; } 阻止拷贝 有些时候，拷贝没有合理的意义，所以需要阻止。可以定义删除的函数来阻止拷贝。删除的函数是指，声明了它们，但是不能使用的函数。在函数的参数列表后面加上=delete来指明为删除的函数。 注意，析构函数不能是删除的成员。如果析构函数是删除的，那么这个类型就不能创建任何形式的对象。 如果一个类有数据成员不能默认构造、拷贝、复制或者销毁，那么对应的成员函数将会被定义为删除的。比如存在const、引用成员或是成员的析构函数是private的。 引用计数的工作方式 除了初始化对象之外，每一个构造函数（除了拷贝构造函数）还要创建一个引用计数，用来记录有多少对象与正在创建的对象共享状态。当我们创建对象时，只有一个对象共享状态，因此将计数器初始化为 1。 拷贝构造函数不分配行的计数器，而是拷贝给定对象的数据成员，包括计数器。拷贝构造函数递增共享的计数器。 析构函数递减计数器。如果计数器变为 0，则析构函数释放状态。 拷贝赋值运算符递增右侧的计数器，递减左侧的计数器。如果左侧计数器变为 0，那么就必须销毁状态。 唯一的难题是确定哪里存放引用计数，因为计数器不能直接作为对象的成员。当创建多个拷贝时，无法对之前的拷贝中的计数器进行修改。 可以使用动态内存创建计数器，这样多个拷贝可以指向同一个计数器。 对象移动 右值引用 右值引用通过&amp;&amp;来获取，它只能绑定到一个将要销毁的对象上。因此，可以将一个右值引用的资源移动到另一个对象中。 右值引用用于绑定值，包括要求转换的表达式、字面值常量或者返回右值的表达式。 右值引用只能绑定到临时对象，它所引用的对象将要销毁，而且该对象没有其他用户。使用右值引用的代码可以接管所引用的对象的资源。 std::move 这个函数在&lt;utility&gt;中。 move告诉编译器，有一个左值，但是希望像右值一样处理它。调用move意味着，除了对这个变量赋值或者销毁它之外，将不再使用它。它返回一个右值引用。 对move不使用using声明，直接使用std::move。 移动构造函数和移动赋值运算符 移动构造函数的第一个参数是该类型的一个应用，与拷贝构造函数不同的是，这个引用参数在构造函数中是一个右值引用。其他所有额外参数都需要有默认实参。 StrVec(StrVec &amp;&amp;s) noexcept // 不应抛出任何异常。 : ... { }; 与拷贝构造函数不同，移动构造函数不分配新内存：它接管给定的对象中的内存。接管内存之后，将给定对象中的指针都置为nullptr。这样就完成了从给定对象的移动操作。 由于移动操作不分配资源，所以通常不会抛出异常。对于一个不会抛出异常的操作，应该通知标准库，否则它会做一些额外的工作。通知的方法就是在声明和定义中都指定noexcept。 移动赋值运算符执行与析构函数和移动构造函数相同的工作。 从一个对象移动数据并不会销毁这个对象，但是有时候在操作完成之后，源对象会被销毁。因此，当我们编写一个移动操作时，必须确保源对象进入一个可析构状态。 编译器也会合成移动构造函数和赋值运算符，但是和合成拷贝操作大不一样。如果一个类定义了自己的拷贝构造函数、赋值运算符或者析构函数，那么编译器就不会为它合成移动构造函数和赋值运算符。这时候，就会用拷贝操作代替移动操作。 当同时存在移动和拷贝构造函数时，通过匹配来选择。移动右值，拷贝左值。没有移动构造函数时，右值也会被拷贝。 重载运算与类型转换 重载的运算符是有特殊名字的函数，operator加上要定义的运算符号。 // 以下两个表达式等价 data1 + data2; operator+(data1, data2); 某些运算符不应该被重载：逗号、取址符、逻辑与、逻辑或。 对于运算符应该作为类成员还是非成员，有几条准则帮助做出选择： 赋值、下标、调用、成员访问箭头运算符必须是成员； 复合赋值运算符一般来说必须是成员，但并非必须； 改变对象状态的、与给定类型密切相关的，如递增、递减、解引用，通常来说是成员； 具有对称性的，算数、相等性、关系、位运算符等，一般是非成员函数。 输入输出 输出运算符&lt;&lt;的第一个形参是一个非常量ostream的引用，第二个形参一般是一个常量的引用，这个形参是我们想要打印的对象。返回值一般需要是它的ostream形参。 与&lt;iostream&gt;兼容的输入输出运算符必须是普通的非成员函数，而不是类成员函数，否则左侧运算对象将是类的对象。 X data; data &lt;&lt; cout; // operator&lt;&lt; 是 X 的成员 输入运算符&gt;&gt;的第一个形参是要读取的流的引用，第二个形参是要读入到的对象的引用。 输入很可能发生错误，所以需要检查错误。 istream &amp;operator&gt;&gt;(istream &amp;is, X &amp;item) { is &gt;&gt; X.a &gt;&gt; X.b; if (!is) item = X(); // 如果输入失败，重置对象 return is; } 递增和递减 class X { public: X&amp; operator++(); // 前置 X&amp; operator--(); X&amp; operator++(int); // 后置 X&amp; operator--(int); } 对于后置运算符，会接受一个额外的int类型的形参，使用时，编译器为这个形参提供一个值为 0 的实参。 成员访问运算符 解引用和箭头运算符经常会被迭代器类和智能指针类使用。 解引用运算符与普通函数没什么差别，能完成任何指定的操作，但箭头运算符只能用于获取成员。即是说ptr-&gt;mem必须等价于(*ptr).mem。 lambda的本质 一个lambda表达式相当于产生了一个匿名类的匿名对象。 [](const string &amp;a, const string &amp;b){ return a.size() &lt; b.size(); }; class emm { public: bool operator()(const string &amp;a, const string &amp;b) const { return a.size() &lt; b.size(); } }; [sz](const string &amp;s) { return s.size() &lt; sz; }; class emm { public: emm(size_t n): sz(n) { } bool operator()(const string &amp;s) const { return s.size() &lt; sz; } private: size_t sz; } function 对于不同类型可调用对象，比如重载了()的类、lambda对象、函数，返回值和接受的形参列表可能是相同的，但是类型不同，所以无法统一管理。使用function类可以管理它们。 function&lt;int(int,int)&gt; IntFunc1; function&lt;int(int,int)&gt; IntFunc2(nullptr); function&lt;int(int,int)&gt; IntFunc3([](int a, int b) { return a+b }); int mod(int a, int b) { return a%b; } function&lt;int(int,int)&gt; IntFunc4(mod); function类中定义了一些类型： result_type，返回的类型；； argument_type，唯一参数的类型； first_argument_type，第一个参数的类型； second_argument_type，第二个参数的类型。 类型转换运算符 用于将类的值转换为其他类型。 class emm { public: emm(int i = 0): num(i) { } operator int() const { return num; } // 转换为 int private: int num; } 一般来说，类型转换比较少见，而定义向bool类型的转换倒是比较常见的事。但是这样有一个问题，bool类型是算术类型，如果被转换就会支持很多运算。为了避免这样的异常，可以提供explicit声明，这样就需要强制转换。 class emm { public: // ... explicit operator int() const { return num; } // ... } emm i = 3; static_cast&lt;int&gt;(i); // 3 这个规定有一个例外：当表达式被用作条件判断时，explicit转换也会被隐式调用。 ","link":"https://wzhzzmzzy.github.io/post/2018-2-7-Cpp学习记录"},{"title":"C++ 学习记录（一）—— 从引用开始","content":"引用 一般来说，我们所说的引用都是指“左值引用（lvalue reference）”。引用相当于为对象起了另外一个名字，引用类型是另外一种类型。可以在变量名前面加上&amp;来声明引用。引用必须被初始化，因为无法令引用重新绑定到另外一个对象。 在初始化变量时，初始值会被拷贝到新建的对象当中。但是定义引用的时候，程序把引用和它的初始值绑定在一起，而不是将初始值拷贝到引用。 不能定义引用的引用。 int a = 1; int &amp;b = a; cout &lt;&lt; b &lt;&lt; endl; // 1 指针 指针声明时，需要在变量名的前面加上*来声明。指针需要获取一个变量的地址时，需要使用到取址符&amp;。即，&amp;用在左值上是引用声明，用在右值上是取址。 同样，当在非声明时使用*时，称为解引用符，用于访问该指针所存储地址下的值。 空指针 这里有一个需要特别提出的概念：空指针。 空指针不指向任何对象，在使用一个指针之前，可以首先检查它是否为空。也可以用一些方法来生成一个空指针。 int *p1 = nullptr; // C++11 int *p2 = 0; int *p3 = NULL; // 需要 #include &lt;cstdlib&gt; NULL是一个预处理变量，预处理器会自动将它替换为实际值，NULL的实际值就是0。 void* 这是一种特殊的指针类型，可以用于存放任意对象的地址。要注意我们不能直接操作void*指针所指向的对象，因为我们不知道这个对象到底是什么类型。 我们能做的只有： 那它和其他指针比较； 作为函数的输入或者输出； 赋值给另外一个void*指针。 const const是常量声明符，const对象一旦创建之后值就不能改变，所以必须被初始化。 const对象默认只能在文件内有效果。要在多个文件内使用时，需要多次声明它。 // a.cpp extern const int a = 1; // b.cpp extern const int a; const 引用 const可以使用常量引用去绑定他，但是不能让非常量引用指向他。 const double pi = 3.14159; const double &amp;ppi = pi; // 正确 double &amp;pppi = pi; // 错误 当我们使用常量引用时，我们同样不可以使用一个非常量引用指向常量引用： const int &amp;a = 1; const int &amp;b = a; int &amp;c = a; // 错误 因为当我们为常量引用初始化时，编译器为引用创建了一个临时量。 const 指针 和常量引用相似，指向常量的指针不能用于改变其所指对象的值。 指针是对象，但引用不是，因此允许把指针本身定为常量。常量指针必须被初始化，而且一旦完成，则它的值就不能再改变了。把*放在const关键字之前，用以说明指针是一个常量，但是指向的值不一定是。 int a = 0; int *const cura = &amp;a; const int b = 1; const int *const curb = &amp;b; 我们用**顶层const**表示指针本身是个常量，**底层const**表示指针所指的对象是一个常量。 常量表达式 常量表达式是指值不会改变并且编译过程中就能得到计算结果的表达式。 const int a = NULL; // 是 const int b = random(); // 不是 C++11提供了一个新的类型：constexpr，用于让编译器判断变量的值是不是一个常量表达式。同样也可以声明constexpr函数。 必须指明，如果在constexpr中定义了指针，那么只对指针有效，与所指的对象无关。 处理类型 类型别名 有两种方法定义类型别名： 关键字typedef； 别名声明using。 typedef double db; using db = double; auto 这个说明符让编译器去分析表达式所属的类型。显然，auto定义的变量必须具有初始值。 编译器推断出来的auto类型有时候和初始值的类型并不是完全一样的，编译器会适当地改变结果类型，使其更符合初始化规则。 首先，使用引用其实是使用引用的对象，此时编译器会以引用对象的类型作为auto的类型。其次，auto一般会忽略掉顶层const，同时底层const则会保留下来。如果希望推断出的auto是一个顶层const，那么需要明确指出。 int a = 1; const int x = a, &amp;rx = x; auto a = x; // int auto b = rx; // int auto c = &amp;a // int* auto d = &amp;rx // const int* decltype 这个函数获取参数的类型，返回一个类型。 decltype(f()) test; // 获取 f 的返回值类型 结构体 结构体由结构体名和类体组成，花括号内是一个新的作用域，类内部定义的名字必须唯一，但是可以与外部定义的名字重复。一般来说，最好不要把对象定义和类的定义放在一起。 类定义最后不要忘记分号。 C++11允许为数据成员提供一个类内的初始值，没有初始值的成员会被默认初始化。 编写自己的头文件 头文件通常包含那些只能被定义一次的实体，如类、const和constexpr变量。头文件也经常用到其他头文件的功能。这时，就会多次包含头文件。 确保头文件多次包含仍然能够安全工作的常用技术是预处理器。它由C++从C中继承而来。预处理器是在编译之前执行的一段程序，可以部分地改变我们所写的程序。之前已经用到一项预处理功能#include，当预处理器看到#include时就会用指定的头文件内容替换。 C++还会用到头文件保护符，依赖于预处理变量。预处理变量有两种状态：定义和未定义。#define指令把一个名字设定为预处理变量，#ifdef当已定义时为真，#ifndef当未定义时为真，如果检查到结果为真，执行操作直到遇到#endif为止。 #ifndef hhh #define hhh #include &lt;string&gt; struct hhh_data { // ... }; #endif 名空间 当使用特定名空间中的对象时，会需要首先声明。 using std::cin; std::string string对象的操作 string s1; // 空串 string s2 = s1; // 副本 string s3 = &quot;hiya&quot;; // &quot;hiya&quot; string s4(10, 'c'); // &quot;cccccccccc&quot; 使用等号=实际上是拷贝初始化，如果不使用等号而使用调用运算符，是直接初始化。 os &lt;&lt; s; // 将 s 写到输出流 os 中，返回 os is &gt;&gt; s; // 从 is 中读取字符串赋值给 s，字符串以空白分隔，返回 is getline(is, s); // 从 is 中读取一行赋值给 s，返回 is s.empty(); // s 为空返回 true，否则 false s.size(); // 返回 s 中字符的个数 s[n]; // 返回 s 中第 n 个字符的引用，位置 n 从 0 开始计数 s1 + s2; // 返回 s1 和 s2 连接的结果 s1 = s2; // 用 s2 的副本代替 s1 中原来的内容 s1 == s2; // &lt;, &lt;=, &gt;, &gt;=, != // 如果 s1 和 s2 中所含字符完全一样，那么它们相等，按字典序比较大小 size方法返回的是一个string::size_type类型的值。这是个无符号类型的值，所以要避免与有符号类型、负值使用时可能存在的问题。 函数 返回值 函数的返回值用于初始化调用点的一个临时量。这个临时量就是函数调用的结果。如果函数返回引用，那么这个引用仅仅是它所应用对象的一个别名。 注意，不要返回局部对象的引用或者指针。 C++11允许返回一个花括号的列表值。这个列表值的类型取决于函数的返回值类型。 vector&lt;int&gt; test() { return {1, 2, 3, 4}; } 主函数main可以没有返回语句，编译器会在结尾处隐式地插入一条返回0的return语句。 默认实参和重载 可以在函数声明里为函数指定实参的默认值。一个默认值只能被指定一次。 一个函数可以被多次声明，每次声明使用不同的形参列表。这被称为重载。 函数指针 当我们把函数名作为一个值使用时，函数自动转换为指针。 我们能直接使用指向函数的指针调用这个函数，不需要提前解引用。 bool lenCmp(const string &amp;, const string &amp;); 该函数的类型就是bool(const string &amp;, const string &amp;)。要想声明一个指向这个函数的指针，只需要用指针替换函数名即可。 指向不同类型的函数指针之间没有转换的规则，但是可以指向一个空指针。 对于重载函数的指针，编译器会通过指针类型指定选用的函数。指针类型和重载函数中的一个必须精确匹配。 函数指针同样可以作为函数的形参。 // 这两个声明等价 void hasBig(int test(int, int)); void hasBig(int (*test)(int, int)); 类 首先我们定义一个普通的结构体。 struct Sales_data { std::string isbn() const { return bookNo; } Sales_data&amp; conbine(const Sales_data&amp;); double avg_price() const; std::string bookNo; unsigned units_sold = 0; double revenue = 0.0; }; Sales_data add(const Sales_data&amp;, const Sales_data&amp;); std::ostream &amp;print(std::ostream&amp;, const Sales_data&amp;); std::istream &amp;read(std::istream&amp;, Sales_data&amp;); this 成员函数通过一个名为this的常量指针来访问调用它的那个对象。我们也可以直接使用this。 std::string isbn() const {return this-&gt;bookNo; } 我们也可以在成员函数中返回this指针。 const成员函数 我们还会发现，在一些成员函数的参数列表后面会有一个const，这个const用于指明在这个函数中，this是一个const className *const类型的指针。 在一般情况下，this是一个常量指针，即类型为className *const。这时，this无法指向一个常量对象。指明了const成员函数之后，意味着这个函数中无法对对象的属性进行修改。该对象是一个常量对象。 在类的外部定义成员函数 当我们在类的外部定义成员函数时，定义必须与它的声明匹配。同时，类外部定义的成员名字必须包含它所属的类名。 定义类相关的非成员函数 我们在类的外部定义了一些函数，这些函数从概念上来说属于类的接口的组成部分，但是实际上不属于类本身。 Sales_data add(const Sales_data&amp;, const Sales_data&amp;); ostream &amp;print(std::ostream&amp;, const Sales_data&amp;); istream &amp;read(std::istream&amp;, Sales_data&amp;); istream &amp;read(istream &amp;is, Sales_data &amp;item) { double price = 0; is &gt;&gt; item.bookNo &gt;&gt; item.units_sold &gt;&gt; price; item.revenue = price * item.units_sold; return is; } ostream &amp;print(ostream &amp;os, const Sales_data &amp;item) { os &lt;&lt; item.isbn() &lt;&lt; &quot; &quot; &lt;&lt; item.units_sold &lt;&lt; &quot; &quot; &lt;&lt; item.revenue &lt;&lt; &quot; &quot; &lt;&lt; item.avg_price(); return os; } 构造函数 当未声明构造函数时，编译器会自动生成一个默认构造函数。但是当我们定义了一些其他的构造函数，除非我们定义一个默认的构造函数，否则将会没有默认构造函数。 struct Sales_data { Sales_data() = default; Sales_data(const std::string &amp;s): bookNo(s) { } Sales_data(const std::string &amp;s, unsigned n, double p): bookNo(s), units_sold(n), revenus(p*n) { } Sales_data(std::istream &amp;); // ... } =default用来指定该构造函数与编译器生成的默认构造函数一致。 在其他的构造函数中，冒号和花括号之间的部分是构造函数初始值列表。花括号中是函数体。 访问控制、封装 public成员可以在整个程序内被访问，public成员定义类的接口。 private说明符之后的成员可以被类的成员函数访问，但是不能被使用该类的代码访问，private部分封装了类的实现细节。 class和struct都可以使用访问控制符，唯一的区别是，struct和class的默认访问权限不太一样。 类可以在它的第一个访问说明符之前定义成员，对于这种成员的权限访问依赖于类定义的方式。如果我们使用struct，那么这些成员是public的，否则是private。 友元 类可以允许其他类或者函数访问非公有成员，方法是声明友元。 class Sales_data { friend Sales_data add(const Sales_data, const Salse_data&amp;); friend ostream &amp;print(std::ostream&amp;, const Sales_data&amp;); friend istream &amp;read(std::istream&amp;, Sales_data&amp;); public: //... private: //... } 注意，友元只是指定了访问权限，并不是一个通常意义上的函数声明。如果想要使用这个函数，那么还需要在其他地方声明。 类成员的一些特性 定义成员类型 class Screen { public: typedef std::string::size_type pos; // 等价于 using pos = std::string::size_type; private: pos cursor = 0; pos height = 0, width = 0; std::string contents; } 成员内联函数 可以在类的内部把inline作为声明的一部分显式地声明函数，然后再外部定义函数。 在类内部定义的成员函数默认是内联函数。 可变数据成员 一个可变数据成员永远不会是const，即使是一个常量对象的成员。因此，一个const成员函数可以改变一个可变成员的值。 通过mutable可以声明一个可变数据成员。 IO流 IO头文件有以下三个。 &lt;iostream&gt;定义了用于读写流的基本类型。 &lt;fstream&gt;定义了读写命名文件的类型。 &lt;sstream&gt;定义了读写内存string对象的类型。 其中包含的流有以下一些： &lt;iostream&gt; istream，wistream从流读取数据。 ostream，wostream向流写入数据。 iostream，wiostream读写流。 &lt;fstream&gt; ifstream，wifstream从文件读取数据。 ofstream，wofstream向文件读取数据。 fstream，wfstream读写文件。 &lt;sstream&gt; istringstream，wistringstream从string读取数据。 ostringstream，wostringstream向string读写数据。 stringstream，wstringstream读写string。 其中w表示宽字符类型。 一般来说，&lt;fstream&gt;和&lt;sstream&gt;中的类都继承于&lt;iostream&gt;。所以使用方式是类似的。 IO对象无法拷贝和赋值，所以一般进行IO操作的函数都以引用方式传递和返回流。另外，读写一个IO对象会改变它的状态，因此传递和返回的引用不可以是const的。 条件状态和缓冲区 流的条件状态可以帮助发现错误。 rdstate方法返回一个iostate值，用于获取流的当前状态。clear用于清除错误状态。 flush方法可以清空缓冲区。 文件读写 想要读写文件时，可以定义一个文件流对象，并将对象与文件相关联。 ifstream in(ifile); // 打开即关联 ofstream out; // 打开空流 out.open(ofile); // 打开文件 out.close(); // 关闭文件 打开文件时可以接受 C 风格的字符串，也可以接受std::string。 每个流都有关联的文件模式，用来指出如何使用文件。 in以读的方式打开； out以写的方式打开； app每次写操作前都定位到文件末尾； ate打开文件之后就定位到文件末尾； trunc截断文件； binary以二进制方式进行IO。 ofsteam out(&quot;file&quot;, ofstream::out | ofstream::trunc); string流 sstream(s)生成一个sstream对象，保存string s的一个拷贝。这个构造函数是explicit的。 str()返回流中保存的string的拷贝。 str(s)将string s拷贝到sstream中，返回void。 顺序容器 vector，可变长度数组，支持快速随机访问。 deque，双端队列，支持快速随机访问。 forward_list，单向链表。 list，双向链表。 array，固定长度数组。 string，字符串。 容器的一般操作 swap，交换。 size，容器大小。 insert，插入元素。 emplace，构造一个元素。 erase，删除元素。 clear，清空。 resize，改变容器大小。 迭代器 迭代器begin指向第一个位置，end指向最后一个之后的位置。 auto b = c.begin(); // 返回 iterator auto cb = c.cbegin(); // 返回 const_iterator auto rb = c.rbegin(); // 返回 reverse_iterator auto crb = c.crbegin(); // 返回 const_reverse_iterator 初始化 C c; // 空 C c1(c2); // c1 为 c2 的拷贝 C c1 = c2; C c{a, b, ...}; // 初始化为列表中的值 C c={a, b, ...}; C c(b, e); // b e 为迭代器 C seq(n); // n 为长度值 C seq(n, t); // 重复 n 个 t 对于array有一些特殊，声明时需要指明大小：array&lt;int, 10&gt;。 assign 使用assign可以将相容但不同的类型在容器之间相互转化。 list&lt;string&gt; names; vector&lt;const char*&gt; oldstyle; names.assign(oldstyle.cbegin(), oldstyle.cend()); 添加元素 forward_list有专有的insert和emplace。 push_back； emplace_back； push_front； emplace_front； insert，可以插入单个或多个单一元素，也可以用迭代器指定需要插入的元素范围，第一个参数使用迭代器指定插入位置，返回值为插入后的位置； emplace，插入时调用容器元素的构造函数构造一个对象，减少内存消耗。 删除元素 pop_back； pop_front； erase，删除迭代器指定元素，也可以删除范围； `clear。 forward_list的插入和删除 before_begin，返回首元素之前位置的迭代器； cbefore_begin； insert_after，在迭代器之后的位置插入元素； emplace_after； erase_after，删除迭代器之后的位置的元素。 改变容器大小 resize接受一个或者两个参数，第一个参数指定新的大小，第二个参数指定当空间变大时使用什么值来填充。 容器操作可能使迭代器失效 在容器中插入或者删除元素可能会让容器元素的指针、引用或者迭代器失效。这可能会有很严重的后果。所以当调用insert和erase之后都需要更新迭代器。 不应当保存end()返回的迭代器，因为总是会失效。通常 C++ 标准库的实现中，end()操作都很快。 容器大小的管理 定义容器时，它会分配一定的内存空间，留存一些作为备用。但是当容器变大，之前分配的内存空间即将耗尽时，容器会重新分配内存空间。 有一些用于管理容器容量的成员函数。 shrink_to_fit，将capacity减少为size相同大小。 capacity，返回当前容量。 reserve，重新分配内存大小。 注意，reserve分配无法让空间小于需求。 string 构造string的其他方法 string(cp, n)，cp为字符数组，n为长度； string(s, pos)，拷贝pos下标之后的内容； string(s, pos, len)。 substr 使用下标从string中截取一段内容，注意下标不能超过string的下标范围。 添加、删除、修改 erase； insert； replace； assign； append。 assign、append和replace可以使用args指定内容，args的形式为： str str, pos, len cp cp, len n, c b, e {c1, c2, ...} 搜索 find，查找指定字符串的第一次出现的位置。 rfind，从后面开始查找。 find_first_of，找出指定字符串中出现的字符第一次出现的位置。 find_first_not_of，查找第一个没有在指定字符串中出现的字符。 find_last_of find_last_not_of 数值转换 to_string可以将数值转换为string。 以下一些函数可以将string转换为各种类型的数值。 stoi stol stoul stoll stoull stof stod stold 容器适配器 stack，queue和priority_queue是三个顺序容器适配器。 默认情况下，stack和queue是基于deque实现的，priority_queue是在vector基础上实现的。我们可以在创建一个适配器时将一个命名的顺序容器作为第二个类型参数，来重载默认容器类型。 vector&lt;int&gt; b; stack&lt;int&gt; sta; stack&lt;int, vector&lt;int&gt;&gt; stb(b); ","link":"https://wzhzzmzzy.github.io/post/2018-2-6-Cpp学习记录"},{"title":"Python 函数、装饰器","content":"一等函数 在Python中，整数、字符串、字典等等都是一等对象，没什么特别的。与其他语言不太一样的地方就是，Python中，函数也是对象。当然，接触过JavaScript的同学肯定不会对此感到陌生。 在命令行中测试一下我们就能发现这件事了： &gt;&gt;&gt; def f(n): ... '''return n!''' ... return 1 if n &lt; 2 else n*f(n-1) ... &gt;&gt;&gt; type(f) &lt;class 'function'&gt; &gt;&gt;&gt; f.__doc__ 'return n!' 把函数视作对象 其实我们早就这样做了。在Python的sorted方法中，对于key，这个参数，我们就会传进去一个函数名作为参数，在map中，第一个参数就是一个函数。 &gt;&gt;&gt; fact = f &gt;&gt;&gt; fact(2) 2 接着上面那个样例我们测试了一下，可以把函数赋值给一个变量，然后通过变量来调用函数。 高阶函数 接受函数为参数，或者返回结果是一个函数的函数是高阶函数。map函数就是一个例子。最为人熟知的高阶函数有map、filter、reduce和apply。其中，apply这个函数已经在Py3中被移除了。 函数式语言通常会提供map、filter、reduce这三个高阶函数，有时使用的是不同的名称。在Python3中，map和filter还是内置函数。但是由于引入了列表推导和生成器表达式，它们就变得没那么重要了。Python3中，这两个高阶函数返回生成器，因而和生成器表达式非常相似。Python2中，这两个高阶函数则返回列表。reduce这个函数在Python3中被移到了functools中，这个函数以前常用于求和，但是现在引入了sum函数，更加高效和方便。 匿名函数 lambda关键字可以用于创建匿名函数。一般而言，除了作为参数传给高阶函数之外，很少在Python中实用匿名函数，因为很难在Python中写出优秀的匿名函数。 这个句法只是语法糖，和def一样，这个表达式会创建函数对象。 可调用对象 调用运算符，即函数名后面的()，还可以应用到其他对象上。 用户定义的函数 内置函数 内置方法 方法 类 类的实例 生成器函数 其中生成器函数十分特殊，调用之后返回一个生成器，并且还可以作为协程。 任何Python对象都可以表现得像函数，只需要实现__call__方法即可。 函数内省 除了__doc__，函数对象还有很多属性，使用dir函数可以获取。 常规对象没有而函数有的属性有下面一些： __annotations__，参数和返回值的注解 __call__，实现调用运算符 __closure__，闭包 __code__，编译成字节码的函数元数据和函数运算体 __defaults__，形式参数的默认值 __get__，实现只读描述符协议 __globals__，函数所在模块中的全局变量 __kwdefaults__，仅限关键字形式参数的默认值 __name__，函数名称 __qualname__，函数的限定名称 从定位参数到仅限关键字参数 Python最好的特性之一是提供了灵活的参数处理机制，Python3进一步提供了仅限关键字参数。调用函数时使用*和**展开可迭代对象，映射到单个参数。下面是一个样例： &gt;&gt;&gt; def f(a, *b, **c): ... print('a:', a) ... if b: ... print('b:', b) ... if c: ... print('c:', c) ... &gt;&gt;&gt; f(1, 2, 3, i=4) a: 1 b: (2,3) c: {'i':4} 注意，数量不定的定位参数必须要放在第二或者之后的参数位置。 如果不想支持数量不定的定位参数，就在签名中放一个*，如def f(a, *, b)。 获取关于参数的信息 函数对象有个__defaults__参数，这个参数的值是一个元组，里面保存着定位参数和关键字参数的默认值。仅限关键字形式参数的默认值在__kwdefaults__属性中。然而，参数的名称在__code__属性中，它的值是一个code对象的引用。 关于函数式编程 得益于operator和functools等包的支持，函数式编程风格也可以信手拈来。 operator模块 在函数式编程中，经常需要把算术运算符当作函数来使用。例如，不使用递归计算阶乘。求和可以使用sum函数，但是求积则没有这样的函数。我们可以使用reduce，但是需要一个函数计算序列中两个元素之积。 operator模块为多个算术运算符提供了相对应的函数，从而避免编写lambda a,b:a*b这样平凡的匿名函数。 operator模块中还有一类函数，能替代从序列中取出元素或者读取对象属性的lambda表达式：itemgetter和attrgetter其实会自行构建函数。比如，itemgetter(1,0)就相当于lambda field: (field[1], field[0])。 attrgetter与itemgetter作用类似，它创建的函数根据名称提取对象的属性。如果把多个属性名传给它，它也会返回提取的值构成的远足。此外，如果参数名中包含.，attrgetter会深入嵌套对象，获取指定的属性。 还要一个方法是methodcaller，作用和上面两个类似，会自行创建函数。这个函数创建的函数会在对象上调用参数指定的方法： from operator import methodcaller s = 'The time has come' upcase = methodcaller('upper') upcase(s) 这样就相当于： s = 'The time has come' str.upper(s) 这个方法可以冻结某些参数，与functools.partial函数类似。 使用functools.partial冻结参数 functools中，除了最广为人知的reduce，余下最有用的是partial和其变体partialmethod。 这个高阶函数用于部分应用一个函数。部分应用是指，给予一个函数创建一个新的可调用对象，把原函数的某些参数固定。使用这个参数可以把接受一个或者多个参数的函数改编成需要回调的API，这样参数更少。 装饰器 装饰器的本质 事实上，装饰器是个语法糖。 import time def clock(func): def clocked(*args): t0 = time.perf_counter() resule=func(*args) elapsed = time.perf_counter() - t0 name = func.__name__ arg_str = ', '.join(repr(arg) for arg in args) print('[%0.8fs] %s(%s) -&gt; %r' % (elapsed, name, arg_Str, result)) return result return clocked 上面我们声明了一个装饰器，然后我们来使用一下： @clock def factorial(n): return 1 if n &lt; 2 else n * factorial(n-1) 上面这一段代码就相当于： def factorial(n): return 1 if n &lt; 2 else n * factorial(n-1) factorial = clock(factorial) 通过*args和**kwargs，可以传递未知参数。 但是上面我们写的这个装饰器有一些缺点：不支持关键字参数、遮盖了被装饰函数的__name__和__doc__这两个属性。所以我们来改进一下： import time import functools def clock(func): @functools.wraps(func) def clocked(*args, **kwargs): t0 = time.time() result = func(*args, **kwargs) elapsed = time.time() - t0 name = func.__name__ arg_lst = [] if args: arg_lst.append(', '.join(repr(arg) for arg in args)) if kwargs: pars = ['%s=%r' % (k,w) for k, w in sorted(kwargs.items())] arg_lst.append(', '.join(pairs)) arg_str = ', '.join(arg_lst) print('[%0.8fs] %s(%s) -&gt; %r ' % (elapsed, name, arg_str, result)) return result return clocked @clock def factorial(n): ''' calculate n! ''' return 1 if n &lt; 2 else n * factorial(n-1) if __name__ == '__main__': factorial(6) 这里用到了一个标准库中的装饰器：functools.warps，这个装饰器把相关的属性从func复制到clocked中去。此外，这个新版还能正确处理关键字参数。 下面介绍两个标准库中的装饰器。 标准库中的装饰器 Python内置了三个用于装饰方法的函数：property、classmethod和staticmethod。另外一个常见的装饰器是functools.warps，作用是协助构建行为良好的装饰器。其他装饰器中，最值得关注的两个是lru_cache和全新的singledispatch。 lru_cache 这个装饰器十分使用，实现了备忘功能。和记忆化递归比较相似，都是将耗时的函数结果保存起来，避免传入相同的参数时重复计算。当然，这更适合于函数式编程时的函数，即对于同样的参数，返回值不会有变化的函数。LRU是Least Recently Used，表明缓存是不会无限增长的，有时效性。 举个例子，斐波那契数列的递归求法： @functools.lru_cache() @clock def fibnacci(n): return n if n &lt; 2 else fibnacci(n-1) + fibnacci(n-2) 调用这个函数我们就会发现，添加了functools.lru_cache之后，求每个值的时候只会调用一次函数，需要求的值越大时，速度就越快。 除了优化递归之外，在对付Web这种I/O密集型工作时，lru_cache也很有用处。 特别注意：lru_cache可以使用两个可选的参数来配置。它的签名是：functools.lru_cache(maxsize=128, typed=False)。 第一个参数maxsize指定最大的缓存结果保存量。缓存满了之后，旧结果会被扔掉。为了得到最佳的性能，maxsize应该设置为2的幂次。typed参数如果设置为True，把不同参数累赘得到结果分开保存，即把通常认为相等的浮点数和整数参数区分开来。顺便说一下，因为lru_cache使用字典存储结果，而且键根据调用时传入的定位参数和关键字参数创建，所以被lru_cache装饰的参数需要保证所有参数都是可散列的。 singledispatch 有时候我们会想要根据对象的不同，定制函数的不同行为。但是Python不支持重载方法或者函数，所以我们不能使用不同的签名定义函数变体。一种常见的做法是把函数编程一个分派函数，用一串if/elif/else来根据参数不同调用不同的函数。这样虽然可以解决文档，但是一来不够优美，二来或许这个函数会变得很臃肿。 singledispatch可以把整体方法拆分成多个模块，甚至可以为你无法修改的累提供专门的函数。使用@singledispatch装饰的普通函数会变成泛函数：根据第一个参数的类型，以不同方式执行相同操作的一组函数，可以看如下示例： from functools import singledispatch from collections import abc import numbers import html @singledispatch def htmlize(obj): content = html.escape(repr(obj)) return '&lt;pre&gt;{}&lt;/pre&gt;'.format(content) @htmlize.register(str) def _(text): content = html.excape(text).replace('\\n', '&lt;br&gt;\\n') return '&lt;p&gt;{}&lt;p&gt;'.format(content) @htmlize.register(numbers.Integral) def _(n): return '&lt;per{0} (0x{0:x})&lt;/pre&gt;'.format(n) @htmlize.register(tuple) @htmlize.register(abc.MutableSequence) def _(seq): inner = '&lt;li&gt;\\n&lt;/li&gt;'.join(htmlize(item) for item in seq) return '&lt;ul&gt;\\n&lt;li&gt;' + inner + '&lt;/li&gt;\\n&lt;ul&gt;' 只要可能，注册的专门函数应该处理抽象基类（如numbers.Integral和abc.MutableSequence），不要处理具体实现（如int和list）。这样，代码支持的兼容类型更加广泛。例如，Python扩展可以子类化numbers.Integral，使用固定位数实现int类型。 singledispatch机制的一个显著特种是，你可以在系统的任何地方和任何模块中注册专门函数，如果后来在新的模块中定义了新的类型，可以轻松的添加一个新的专门函数来处理。此外，还可以为布恩那个修改的类添加自定义函数。 关于singledispatch可以查看文档“PEP 443——Single-dispatch generic functions”（https://www.python.org/dev/peps/pep-0443/）。 @singledispatch不是为了把Java的那种方法重载带入Python。在一个类中为一个方法定义多种重载变体，比在一个函数中使用一长串if/elif/else更好，但是也有缺陷。以为你它们让代码单元承担的职责太多。@singlediapatch的优势在于支持模块化扩展：各个模块可以为它支持的各种类型注册一个专门函数。 叠放装饰器 装饰器是函数，因此可以组合起来使用。可以在已经被装饰的函数上应用装饰器。理解了上面所说的装饰器的本质是语法糖，那么就能理解这里了。 参数化装饰器 Python把被装饰的函数作为第一个参数传给装饰器函数。那么怎么让装饰器函数接受其他参数呢？答案是：创建一个装饰器工厂函数，把参数传给它，返回一个装饰器，然后再把它应用到要装饰的函数上。 举个例子： registry = [] def register(func): print('running register(%s)' % func) registry.append(func) return func @register def f1(): print('running f1()') print('running main()') print('registry -&gt;', registry) f1() 这是一个简单的装饰器。 一个参数化的注册装饰器 为了便于启用或者禁用register的函数注册功能，我们提供一个可选的active参数。 registry = set() def register(active=True): def decorate(func): print('running register(active=%s)-&gt;decorate(%s)' % (active, func)) if active: registry.add(func) else: registry.discard(func) return func return decorate 这样我们就能给它添加参数了。 @register(active=True) def f1(): print('running f1()') 这里的关键在于，register()要返回decorate，然后把它应用到被装饰的函数上。 ","link":"https://wzhzzmzzy.github.io/post/2017-11-25-Python学习笔记"},{"title":"React 与 Material-UI-Next","content":"React 这啥玩意 一开始看到这个东西是懵逼的，然后找到了一个中文文档，终于好过了一点。跟着教程做完了一个网页上的Tic Tac Toc井字棋，还行，差不多知道怎么用了。最开始的难关就是配置环境了，整整配置了三遍才好。也是一点办法都没有。 React完全使用了JSX的语法，基本可以说是在JavaScript中重做了HTML、CSS、JavaScript。其他所有的东西如果要在React中使用，都需要相应的插入方式，比如jQuery。React也有可以取代传统AJAX的fetch方法，不需要建立XHR就可以使用。CSS in JS也是个很有趣的东西，不过一向不太喜欢用CSS这类东西，主要是很难画图。美工不好。 Bootstrap也是个很有用的东西，对我来说，它最有用的就是按比例分配页面空间，这样可以适应多终端页面。不过万能的React当然有自己的React-Bootstrap。但是我们也没有用，而是找了一个现成的UI库：material-ui-next，是一个Material Design风格的ReactUI库，之所以用它一来是因为好看，二来是因为它的Grid Layout可以取代Bootstrap。 基本就用了这几样东西，因为初入前端，所以遇到了各种非常奇妙的问题。 React示例 // index.js import React from 'react'; import ReactDOM from 'react-dom'; import App from './App'; ReactDOM.render(&lt;App /&gt;, document.getElementById('root')); // App.js import React, { Component } from 'react'; import logo from './logo.svg'; import './App.css'; class App extends Component { render() { return ( &lt;div className=&quot;App&quot;&gt; &lt;header className=&quot;App-header&quot;&gt; &lt;img src={logo} className=&quot;App-logo&quot; alt=&quot;logo&quot; /&gt; &lt;h1 className=&quot;App-title&quot;&gt;Welcome to React&lt;/h1&gt; &lt;/header&gt; &lt;p className=&quot;App-intro&quot;&gt; To get started, edit &lt;code&gt;src/App.js&lt;/code&gt; and save to reload. &lt;/p&gt; &lt;/div&gt; ); } } export default App; 这是使用create-react-app时创建的最初的代码。在App.js中用export default语法，当引入这个包时，直接获取的就是这个JSX对象。这个对象会用于覆盖id=root的一个HTML元素。这样就通过JS实现网页的渲染。一个JSX示例，只需要是一个class，继承React.Component，然后重写render就行了。 props与state 这是React里两个十分重要的属性。state用于在本组件中存储数据，props用于在组件之间单向传输数据。有一个问题，就是props是不应该被修改的，它理应是一个只读属性。所以我们使用props时应该更加小心。 这就出现了一个奇怪的问题，由于props只会在渲染子组件时传递一次，不会多次更新，这就导致了我不能把父组件中props给子组件的数据当成一个自由变量使用。要么修改子组件的props，其他的方法我也没有想出来。 ","link":"https://wzhzzmzzy.github.io/post/2017-11-18-前端开发笔记"},{"title":"简单爬虫学习笔记（一）","content":"学习资料 主要的资料整理@路人甲都已经做好整理了，在这里：一份Python爬虫电子书。从基础的Python入门，到Python爬虫如何学习，都有。如果能学完一遍，那么简单的网页爬虫应该没什么问题了。 顺便推荐一本《Python网络数据采集》，其中以Wikipedia为例解说爬虫的工作，写得不错。 第一天 —— 糗事百科热点爬虫 成品 这是最简单的一个爬虫，因为糗百几乎没有做任何反爬工作，非常的轻松。Github地址：糗事百科爬虫。 思路 首先明确一下目标，要把糗百热点页面上的每一条消息都存下来，放进一个文本文件里。 那么第一步，先确定网址，https://www.qiushibaike.com/hot/page/。这是默认的第一页，往后翻页就会变成/page/2/。那么我们可以用一个参数指定需要爬几个页面。 第二步，尝试获取一下HTML： request = urllib2.Request(url, headers={'User-Agent': 'Chrome/61.0.3163.91'}) response = urllib2.urlopen(request) pageCode = response.read().decode('utf-8') print pageCode 哇，这个HTML有点迷。我们会发现，这个网页上有些太长的段子会被去掉最后一段，换成...。那么我们要获取完整的段子，就需要进入到更深的页面里。 我们看一下HTML里的&lt;a&gt;标签： &lt;a href=&quot;/article/119564633&quot; target=&quot;_blank&quot; class=&quot;contentHerf&quot; onclick=&quot;_hmt.push(['_trackEvent','web-list-content','chick'])&quot;&gt; ... &lt;/a&gt; 没错，我们要的就是这个/article/119564633！那么我们用一个正则表达式来获取一下： self.urlPattern = re.compile('&lt;div class=&quot;articleGender womenIcon&quot;&gt;\\d*&lt;/div&gt;.*?&lt;/div&gt;.*?&lt;a href=&quot;(.*?)&quot;.*?&lt;div class=&quot;content&quot;&gt;', re.S) 这样我们就拿到了这个后缀。在这个后缀页面里面，我们能获取到作者、头像和内容，不过为了简化，没有获取头像。用BeautifulSoup也能实现相应的筛选，不过我选择了正则表达式。 这样一个糗百爬虫就写完了，非常简单。 第二天 —— 百度贴吧帖子爬虫 成品 百度贴吧爬虫也是随便写的，没有写太多注释和异常处理。Github地址：百度贴吧爬虫。 思路 贴吧页面明显比糗百复杂一点，不过确实差别不大。所以我加入了一个下载帖子中图片的功能。 ","link":"https://wzhzzmzzy.github.io/post/2017-09-24-Python爬虫笔记"},{"title":"简单爬虫学习笔记（二）—— 自制知乎爬虫工具箱","content":"项目简介 这几天在捣鼓爬虫，因为微博和淘宝爬取的难度都比较高，而排版相对比较友好的社交网站里，显然知乎是最有爬的价值的一个。当然也有一些私心，想收集一些自己感兴趣的信息，比如游戏话题、编程话题，之类的。 最开始是想从用户界面开始，用户有粉丝和关注者，即用户与用户之间的关联网，这有应该能覆盖知乎绝大多数的有价值的用户。这些用户的回答、提问、文章、专栏，就是爬取信息的真正目标。那么我想制作的第一个工具箱就是从用户页面中获取我需要的那些信息：回答、提问、文章、专栏、粉丝、关注者，等等。制作这一块的时候是在是在参加微软俱乐部的Hi!Heckthon!的时候，为了输出数据的好看，就去采集了一些其他的信息，比如头像、签名等等。然后就到了问题界面和专栏界面，各有各的小难点，不过总的说来大同小异，所以可以说是个体力活：用BeautifulSoup处理文本几乎是整个最麻烦的部分。 这个半成品被我挂在这里，可以爬取小规模的数据（数据量不到10K），大规模爬取会遇到限流警告。 暂时写个简介，先睡了，以后补。 ","link":"https://wzhzzmzzy.github.io/post/2017-10-20-自制知乎爬虫工具箱"},{"title":"2013长沙ICPC现场赛水题题解","content":" 传送门（Vjudge） HDU - 4791 - 1001 Alice's Print Service 题意 t组样例。每组样例给出n个价格变动点，和m个客户需求。每个价格变动点包括了到达这个点需要的物品数量和这个点的物品单价。对于每个需求求出最小花费。 思路 初中数学应用题。换成代码题，做法应该就是，先求出所有的临界变动点就行，然后二分求出所有临界变动点中最接近需求数量q的小的那个，为tmp。如果这个二分值已经是最后一个数，那么就直接取为q*p[tmp]，否则用下一个值和当前值去比较。 代码 /** * Author: wzhzzmzzy * Question: ZOJ - 3726 * Algorithm: 二分 **/ #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;cstdlib&gt; #include &lt;cmath&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;string&gt; #include &lt;vector&gt; #include &lt;queue&gt; #define REP(i, x, y) for(int i=(int)x;i&lt;=(int)y;++i) #define PER(i, x, y) for(int i=(int)y;i&gt;=(int)x;--i) #define LL long long using namespace std; const int maxn = 1e5+7; const LL INF = 0x3f3f3f3f3f3f; int s[maxn], p[maxn]; LL cnt[maxn]; int main() { int t; scanf(&quot;%d&quot;, &amp;t); while (t--) { int n, m; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); REP(i, 0, n-1) scanf(&quot;%d%d&quot;, s+i, p+i); LL ans = INF; PER(i, 0, n-1) { ans = min(1LL*s[i]*p[i], ans); // 记录最小临界值 cnt[i] = ans; // 记录前 i 个的最小值 } while (m--) { int q; scanf(&quot;%d&quot;, &amp;q); int l = 0, r = n-1, tmp; while (l &lt;= r) { int mid = (l+r)/2; if (s[mid] &lt;= q) { tmp = mid; // 避免直接越界 l = mid + 1; } else { r = mid - 1; } } if (tmp == n-1) // 越界了，直接用最后一个 printf(&quot;%lld\\n&quot;, 1LL*q*p[tmp]); else // 用前一个小的，或者这一个 printf(&quot;%lld\\n&quot;, min(1LL*q*p[tmp], cnt[tmp+1])); } } } HDU - 4793 - 1003 Collision 题意 一个二维平面上有一个半径为R的大圆区域，一个Rm的小圆盘，两圆同心。现在在(x,y)点有一个半径为r的硬币，硬币做匀速直线运动，速度矢量为(Vx,Vy)。如果硬币撞击到圆盘，会原路弹回，速度不变。求硬币某一部分在大圆区域内的时间。 思路 队友一开始执意要用kuangbin的板子，但是后来发现不太现实，还是很难。就直接玄学推了一个公式出来，能过。 有三种情况，轨迹距离圆点距离超过R+r，那么就直接输出0。距离在R+r和Rm+r之间就不会撞击到圆盘。距离小于Rm+r的话就算出撞击圆盘的距离除以速度乘二即可。 代码 /** * Author: wzhzzmzzy * Question: ZOJ - 3728 * Algorithm: 计算几何 **/ #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;cstdlib&gt; #include &lt;cmath&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;string&gt; #include &lt;vector&gt; #include &lt;queue&gt; #define REP(i, x, y) for(int i=(int)x;i&lt;=(int)y;++i) #define PER(i, x, y) for(int i=(int)y;i&gt;=(int)x;--i) using namespace std; double R, Rm, r, x, y, vx, vy; inline double calc(double a, double b) { return sqrt(a*a+b*b); } int main() { while (~scanf(&quot;%lf%lf%lf%lf%lf%lf%lf&quot;, &amp;Rm, &amp;R, &amp;r, &amp;x, &amp;y, &amp;vx, &amp;vy)) { R += r, Rm += r; double v = calc(vx, vy); double d = fabs(vx*y-vy*x)/v; double ans1 = 2*sqrt((R)*(R)-d*d)/v; double ans2 = 2*sqrt((Rm)*(Rm)-d*d)/v; if (d &gt;= R || vx*x+vy*y &gt;= 0) { puts(&quot;0.000&quot;); continue; } if (d &gt;= Rm) { printf(&quot;%.3lf\\n&quot;, ans1); continue; } printf(&quot;%.3lf\\n&quot;, ans1-ans2); } } HDU - 4798 - 1008 Skycity 题意 有一座底面半径为R，顶面半径为r，高为H的圆台。现在要将它分为F层，每层用一块固定面积的玻璃板组成的正多边形竖直围住。求最少要用多少面积的玻璃板去围。 思路 首先分成F层，高为H，算出每段小圆台的底面圆半径差为(R-r)/F，以及每块固定面积的玻璃的长度l。对于每个圆台，已知底面半径为rr，那么外接正多边形周长就能算出来。 代码 /** * Author: wzhzzmzzy * Question: ZOJ - 3733 * Algorithm: 简单几何 **/ #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;cstdlib&gt; #include &lt;cmath&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;string&gt; #include &lt;vector&gt; #include &lt;queue&gt; #define REP(i, x, y) for(int i=(int)x;i&lt;=(int)y;++i) #define PER(i, x, y) for(int i=(int)y;i&gt;=(int)x;--i) #define PI acos(-1.0) using namespace std; double R, r, H, F, S; int main() { while (~scanf(&quot;%lf%lf%lf%lf%lf&quot;, &amp;R, &amp;r, &amp;H, &amp;F, &amp;S)) { double ans = 0; double c = (R-r)/F; // 差值 double h = H/F; double l = S/h; REP(i, 0, F-1) { double rr = r+i*c; // 枚举半径 int t = (int)(PI/(atan(l/(2*rr)))); // 边数 ans += rr*tan(PI/(1.0*t))*2*h*t; // 结果 } printf(&quot;%.3lf\\n&quot;,ans); } } HDU - 4799 - 1009 LIKE vs CANDLE 题意 有一条微博，转发者的赞表示赞，蜡烛表示菜，每个转发者有它的价值，赞为正，菜为负。转发树上，0为根节点，不算进去。每个节点都可以被翻转，未翻转过的节点翻转要支付x的花费，翻转过的节点要支付y的花费。翻转一个节点之后，其自身包括其子树都会被翻转。求能获得的最大价值和。 思路 一看就知道是个树形DP，一次DFS就能解决。用dp[i][0]表示不翻转的累计价值，dp[i][1]表示翻转的累计价值。 代码 /** * Author: wzhzzmzzy * Question: ZOJ - 3734 * Algorithm: 树形DP **/ #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;cstdlib&gt; #include &lt;cmath&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;string&gt; #include &lt;vector&gt; #include &lt;queue&gt; #define REP(i, x, y) for(int i=(int)x;i&lt;=(int)y;++i) #define PER(i, x, y) for(int i=(int)y;i&gt;=(int)x;--i) using namespace std; const int maxn = 50000+7; struct Edge { int v, nxt; } edge[maxn&lt;&lt;1]; int head[maxn], tot; int n, x, y, vis[maxn], st[maxn], val[maxn]; int dp[maxn][2], flag; void init() { tot = 0; memset(head, -1, sizeof head); memset(dp, 0, sizeof dp); memset(vis, 0, sizeof vis); memset(st, 0, sizeof st); memset(val, 0, sizeof val); } void add(int u, int v) { edge[tot] = (Edge) {v, head[u]}; head[u] = tot++; } void dfs(int u, int fa) { if (vis[u]) flag ^= 1; if (flag) val[u] *= -1; dp[u][0] = val[u], dp[u][1] = -val[u]; for(int i = head[u]; ~i; i = edge[i].nxt) { int v = edge[i].v; if (v == fa) continue; dfs(v, u); dp[u][0] += max(dp[v][0], dp[v][1]-(vis[v]?y:x)); dp[u][1] += max(dp[v][1], dp[v][0]-(vis[v]?y:x)); } if (vis[u]) flag ^= 1; } int main() { while (~scanf(&quot;%d%d%d&quot;, &amp;n, &amp;x, &amp;y)) { init(); int v, w; REP(u, 1, n) { scanf(&quot;%d%d%d%d&quot;, &amp;val[u], &amp;v, vis+u, st+u); if (st[u]) val[u] *= -1; add(v, u); } flag = 0; dfs(0, 0); if (dp[0][0] &lt; 0) puts(&quot;HAHAHAOMG&quot;); else printf(&quot;%d\\n&quot;, dp[0][0]); } } HDU - 4800 - 1010 Josephina and RPG 题意 有m个人物，选三个为一支队伍，所以队伍数有 Cm3C_m^3Cm3​。给出一个概率矩阵K，K[i][j]表示i战胜j的概率。给出一个顺序，要求打败这些队伍。当你打败一支队伍，你可以选择将自己的队伍换成这支队伍。求最大的按顺序打败所有队伍的概率。 思路 其实是个贪心思路，因为顺序是固定的，所以只需要贪心每次取最大的即可。但是为了降低复杂度，直接DP就行。dp[i][j]表示当我击败了前i支队伍之后，面对下一只队伍时，我手上的队伍是j。那么递推公式就是dp[i+1][j] = max(dp[i+1][j], dp[i][j]*p[j][a[i+1]])。 代码 /** * Author: wzhzzmzzy * Question: ZOJ - 3735 * Algorithm: 概率DP **/ #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;cstdlib&gt; #include &lt;cmath&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;string&gt; #include &lt;vector&gt; #include &lt;queue&gt; #define REP(i, x, y) for(int i=(int)x;i&lt;=(int)y;++i) #define PER(i, x, y) for(int i=(int)y;i&gt;=(int)x;--i) using namespace std; const int maxn = 150; const int N = 1e4+7; double p[maxn][maxn], dp[N][maxn]; int a[N]; void calc(int m, int n) { REP(i, 0, m) dp[0][i] = 1; REP(i, 0, n-1) REP(j, 0, m-1) dp[i+1][j] = max(dp[i+1][j], dp[i][j]*p[j][a[i+1]]), dp[i+1][a[i+1]] = max(dp[i+1][a[i+1]], dp[i][j]*p[j][a[i+1]]); } int main() { int m; while (~scanf(&quot;%d&quot;, &amp;m)){ memset(dp, 0, sizeof dp); m = m*(m-1)*(m-2)/6; REP(i, 0, m-1) REP(j, 0, m-1) scanf(&quot;%lf&quot;, &amp;p[i][j]); int n; scanf(&quot;%d&quot;, &amp;n); REP(i, 1, n) scanf(&quot;%d&quot;, a+i); calc(m, n); double ans = 0; REP(i, 0, m-1) ans = max(ans, dp[n][i]); printf(&quot;%.6lf\\n&quot;, ans); } } ","link":"https://wzhzzmzzy.github.io/post/2017-09-14-2013长沙现场赛水题题解"},{"title":"Python 科学计算 —— NumPy","content":"NumPy import numpy as npv np.__version__ # 版本号 nbarray 对象 NumPy中用ndarray表示数组，是整个库的核心对象，NumPy中所有函数都是围绕ndarray对象进行处理的。ndarray的结构并不复杂，但是功能十分强大。不但可以用它高效地存储大量的数值元素，从而提高数值计算的运算速度，还能用它与各种扩展库进行数值交换。 创建 创建数组很简单。 a = np.array([1,2,3,4]) b = np.array([[1,2,3,4],[5,6,7,8]]) 数组的形状可以由shape属性获得，是一个描述数组各个轴长度的元组。可以通过修改shape属性值来对数组进行重新划分。 a.shape # (4,) b.shape # (2, 4) a.shape = 2, 2 # a array([[1,2],[3,4]]) b.shape = 4, -1 # b array([[1,2],[3,4],[5,6],[7,8]]) 可以使用数组的reshape()方法，来根据原数组创建新数组。 元素类型 数组的元素类型可以通过dtype属性获得。在前面的例子中，创建数组所用的序列的元素都是整数，因此所创建的数组的元素类型是整形，并且是32位的长整型。dtype.type可以获取type类型的对象。 a.dtype # dtype('int64') a.dtype.type # &lt;type 'numpy.int64'&gt; 可以通过dtype参数在创建数组时指定元素类型，注意float类型是64位的双精度浮点类型，而complex是128位的双精度复数类型，np.int32则是NumPy`定义的新的数据类型——32位符号整数类型： ai32 = np.array([1,2,3,4], dtype=np.int32) af = np.array([1,2,3,4], dtype=float) ac = np.array([1,2,3,4], dtype=complex) NumPy也有自己的浮点数类型：float16，float32，float64，float128。当使用float64作为dtype参数时，效果和内置的float类型相同。 每种元素数值类型都有几种不同的字符串表达方式，字符串和类型之间的对应关系都存储在typeDict字典中，可以通过下面的命令获得对应的所有键值： [key for key, value in np.typeDict.items() if value is np.float64] # [12, 'd', 'float64', 'float_', 'float', 'f8', 'double', 'Float64'] 完整的类型列表可以通过下面的语句得到，它将typeDict字典中的所有制转换为一个集合，从而去除其中的重复项。 set(np.typeDict.values()) 通过NumPy的数值类型也可以创建数值对象，下面创建一个16位的符号整数对象，它与Python的整数对象不同的是，它的范围有限，因此计算200*200会溢出，得到一个负数，这一点与C语言的16位整数相同。 另外值得注意的是，NumPy的数值对象的运算速度比Python内置类型的运算速度慢很多，如果程序中需要大量地对单个数值运算，应当尽量避免使用NumPy的数值对象。下面的命令比较了两者的运算速度： u = 3.14 v = np.float64(u) %timeit u*u %timeit v*v 使用astype()方法可以对数组的元素类型进行转换，下面将浮点数数组t1转换为32为整数数组，将双精度的复数数组t2转换为单精度的复数数组： t1 = np.array([1,2,3,4], dtype=np.float) t2 = np.array([1,2,3,4], dtype=np.complex) t3 = t1.astype(np.int32) t4 = t2.astype(np.complex64) 自动生成数组 前面的例子都是先创建一个Python的序列对象，然后通过np.array()将其转换为数组，这样做显然效率不高。因此NumPy提供了很多专门用于创建数组的函数。下面每一个函数都有一些关键字参数，具体用法参看函数说明。 arange()类似于内置函数range()，通过制定开始值、终值和步长来创建表示等差数列的一维数组，注意所得到的结果不包含终值。例如下面的程序创建开始值为0，终值为1，步长为0.1的等差数组，注意终值1不在数组中。 np.arange(0, 1, 0.1) # array([0. , 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9]) linspace()通过制定初值、终值和元素个数来创建表示等差数列的一维数组。可以通过endpoint参数制定是否包含终值，默认值为True，即包含终值。 np.linspace(0, 1, 10) # 步长 1/9 np.linspace(0, 1, 10, endpoint=False) # 步长 1/10 logspace()和linspace()类似，不过它所创建的数组是等比数列。下面的例子产生从 10010^0100 到 10210^2102，有5个元素的等比数列，注意起始值0代表 10010^0100，而终值2表示 10210^2102： np.logspace(0, 2, 5) # [1. , 3.16227766, 10. , 31.6227766 , 100. ] 基数可以通过base参数确定，其默认值为10。下面通过将base参数设置为2，并设置endpoint参数为False，创建一个比例为 2frac1122^{frac{1}{12}}2frac112 的等比数组，此等比数组的比值啥音乐中相差半音的两个音阶之间的频率比值，因此可以用它计算一个八度中所有半音的频率： np.logspace(0, 1, 12, base=2, endpoint=False) # [ 1. 1.05946309 1.12246205 1.18920712 1.25992105 1.33483985 1.41421356 1.49830708 1.58740105 1.68179283 1.78179744 1.88774863] zeros()、ones()、empty()可以创建指定形状和类型的数组。其中empty()只分配数组所使用的内存，不对数组元素进行初始化操作，因此它的运行速度是最快的。下面的程序创建一个形状为(2, 3)、元素类型为整数的数组，注意其中的元素值没有被初始化： 而zeros()将数组元素初始化为0，ones()将数组元素初始化为1。下面创建一个长度为4，元素类型为整数的一位数组，并且元素全部初始化为0。 np.empty((2,3), np.int) np.zeros(4, np.int) np.full(4, np.pi) # 初始化为指定的值 此外，zeros_like()、ones_like()、empty_like()、full_like()等函数创建与参数数组的形状与类型相同的数组，因此zeros_like(a)和zeros(a.shape, a.dtype)的效果相同。 frombuffer()、fromstring()、fromfile()等函数可以从字节序列或文件创建数组。下面以fromstring()为例介绍它们的用法，先创建8个字符的字符串s，Python的字符串实际上是一个字节序列，每个字符占一个字节。因此如果从字符串s创建一个8为整数数组，所得到的数组是字符串的ASCII编码。 s = &quot;abcedfg&quot; np.fromstring(s, dtype=np.int8) 如果从字符串s创建一个16位整数数组，那么两个相邻的字节就表示一个整数，吧字节98和字节97当作一个16位的整数，他的值就是 98×256+97=2518598\\times 256+97=2518598×256+97=25185。可以看出，16位的整数啥以低位字节在前的方式保存在内存中的。 np.fromstring(s, dtype=np.int16) # array([25185, 25699, 26213, 26727], dtype=int16) 如果把整个字符串转化为一个64位的双精度浮点数数组，那么它的值是： np.fromstring(s, dtype=np.float) # array([8.54088322e+194]) 显然这个结果没有什么意义，但是如果我们用C语言的二进制方式写了一组double类型的数值到某个文件中，那就可以从此文件读取相应的数据，并通过fromstring()将其转换为float64类型的数组，或者直接使用fromfile()从二进制文件读取数据。 fromstring()会对字符串的字节序列进行复制，而使用frombuffer()创建的数组与原始字符串共享内存。由于字符串是只读的，因此无法修改所创建的数组的内容： buf = np.frombutter(s, dtype=np.int16) buf[1] = 10 # ValueError Python中还有一些类型也支持buffer接口，例如bytearray、array.array等。在后面的章节中，我们会介绍如何使用这些对象实现动态数组功能。 还可以先定义一个从下标计算数值的函数，然后用fromfunction()通过此函数创建数组： func = lambda i: i%4+1 np.fromfunction(func, (10,)) # [1., 2., 3., 4., 1., 2., 3., 4., 1., 2.] func = lambda i,j: (i+1)*(j+1) np.fromfunction(func2, (9,9)) # 九九乘法表 # [[ 1. 2. 3. 4. 5. 6. 7. 8. 9.] # [ 2. 4. 6. 8. 10. 12. 14. 16. 18.] # [ 3. 6. 9. 12. 15. 18. 21. 24. 27.] # [ 4. 8. 12. 16. 20. 24. 28. 32. 36.] # [ 5. 10. 15. 20. 25. 30. 35. 40. 45.] # [ 6. 12. 18. 24. 30. 36. 42. 48. 54.] # [ 7. 14. 21. 28. 35. 42. 49. 56. 63.] # [ 8. 16. 24. 32. 40. 48. 56. 64. 72.] # [ 9. 18. 27. 36. 45. 54. 63. 72. 81.]] 存取元素 可以使用和列表相同的方式对数组的元素进行存取： a = np.arange(10) a[5] # 5 a[3:5] # [3, 4] a[:5] # [0, 1, 2, 3, 4] a[:-1] # [0, 1, 2, 3, 4, 5, 6, 7, 8] a[1:-1:2] # [1, 3, 5, 7] a[::-1] # [9, 8, 7, 6, 5, 4, 3, 2, 1, 0] a[5:1:-2] # [5, 3] 和列表不同的是，通过切片获取的新数组的原始数组的一个试图。它与原始数组共享一块数据存储空间。下面的程序将b的第二个元素修改为-10，a的第5个元素也同时被修改为-10，因此它们在内存中的地址相同。 除了使用切片下标存取元素之外，NumPy还提供了整数列表、整数数组和布尔数组等几种高级下标存取方法。 当使用整数列表对数组元素进行存取时，将使用列表中的每个元素作为下标。使用列表作为下标得到的数组不和原始数组共享内存，整数序列下标也可以用来修改元素的值： x = np.arange(10, 1, -1) a = x[[3, 3, 1, 8]] b = x[[3, 3, -3, 8]] x[[3, 5, 1]] = -1, -2, -3 当使用整数数组作为数组下标时，将会得到一个形状和下标数组相同的新数组，新数组的每一个元素都是用下标数组中对应位置的值作为下标从原数组获得的值。当下标数组是一维数组时，结果和用列表作为下标的结果是一样的，而多维数组时，得到的也是多维数组： x = np.aragne(10,1,-1) x[np.array([3,3,1,8])] x[np.array([[3,3,1,8],[3,3,-1,8]])] x[[3,3,1,8,3,3,-1,8]].reshape(2,4) # 和上一句等同 当使用布尔数组b作为下标存取数组x中的元素时，将获得数组x中与数组b中True对应的元素。使用布尔数组作为下标获得的数组不和原始数组共享数据内存，注意这种方式只对应于布尔数组，不能使用布尔列表。 x[np.array([True, False, True, False, False])] x[np.array([True, False, True])] # 等同 布尔数组一般不是手工产生，而是使用布尔运算的ufunc函数产生，关于ufunc函数请参照下一节的介绍。下面我们举一些简单的例子说明布尔数组下标的用法： x = np.random.randint(0, 10, 6) # 产生一个长度为6，元素值为0到9的随机整数数组 x[x&gt;5] # 生成一个布尔数组，收集x中所有大于5的数 多维数组 多维数组的存取和一维数组类似，因为多维数组有多个轴，所以它的下标需要用多个值来表示。NumPy采用元组作为数组的下标，元祖中的每个元素和数组的每个轴对应。 为什么用元组作为下标？Python的下标语法本身不支持多维，但可以使用任何对象作为下标，因此，NumPy使用元组作为下标存取数组中的元素，使用元组可以很方便地表示多个轴的下标。虽然在Python程序中经常用圆括号将元组的元素括起来，但是事实上元组的语法只需要用逗号隔开元素即可，例如，x,y=y,x就是用元组交换变量值的一个例子。因此，a[1,2]和a[(1,2)]完全相同，都是使用元组(1,2)作为数组a的下标。 可以通过arange相加可以获取需要的二维数组，这样构成的数组，第0个元素与数组的纵轴对应，而第1个元素和横轴对应： a = np.arange(0, 60, 10).reshape(-1, 1) + np.aragne(0, 6) a[0] # [0 1 2 3 4 5] a[1] # [10 11 12 13 14 15] a[:, 2] # [2 12 22 32 42 52] a[2::2, ::2] # [[20 22 24] [40 42 44]] 如果下标元组中只包含整数和切片，那么得到的数组和原始数组共享数据，它是原数组的视图。下面的例子中，数组b是a的视图，它们共享数据，因此修改b[0]时，数组a中对应的元素也被修改。 b = a[0, 3:5] b[0] = -b[0] a[0, 3:5] # array([-3, 4]) 因为数组的下标是一个元组，所以我们可以将下标元组保存起来，用同一个元组存取多个数组。在下面的例子中，a[idx]和a[::2,2:]相同，a[idx][idx]和a[::2,2:][::2,2:]。 idx = slice(None, None, 2), slice(2, None) 切片对象。根据Python的语法，在[]中可以使用以冒号隔开的两个或三个整数表示切片，但是单独生成切片对象时需要使用slice()来创建。它由三个参数，分别为开始值、终值和步长，当这些值需要省略时可以使用None。 用Python的内置函数slice()创建下标比较麻烦，因此NumPy提供一个s_对象来帮助我们创建数组下标，请注意s_实际上是IndexExpression类的一个对象： np.s_[::2, 2:] # (slice(None, None, 2), slice(2, None, None)) s_为什么不是函数？根据Python的语法，只有在中括号[]中才能使用以冒号隔开的切片语法，如果s_是函数，那么这些切片必须使用slice()创建。类似的对象还有mgrid和ogrid等，后面我们会学习它们的用法。Python的下标语法实际上会调用__getitem__()方法，因此我们可以很容易自己实现s_对象的功能： class S(object): def __getitem__(self, index): return index 在多维数组的下标元组中，也可以使用整数元祖或列表、整数数组和布尔数组。当下标使用这些对象时，所获得的数字是原始数据的副本，因此修改结果数组不会改变原始数组。 结构数组 在C语言中我们可以通过struct关键字定义结构类型，结构中的字段占据连续的内存空间。类型相同的两个结构所占用的内存大小相同，因此可以很容易定义结构数组。和C语言一样，在NumPy中也很容易对这种结构数组进行操作。只要NumPy中的结构定义和C语言中的结构定义相同，就可以很方便地读取C语言的结构数组的二进制数据，将其转换为NumPy的结构数组。 假设我们需要定义一个结构数组，它的每个元素都有name、age和weight字段。在NumPy中可以如下定义： persontype = np.dtype({ 'names':['name', 'age', 'weight'], 'formats':['S30', 'i', 'f']}, align=True) a = np.array([(&quot;Zhang&quot;, 32, 75.5), (&quot;Wang&quot;, 24, 65.2)], dtype=persontype) 我们先创建一个dtype对象persontype，它的参数是一个描述结构类型的各个字段的字典，字典有两个键：'names'和'formats'。每个键对应的值都是一个列表。'names'定义结构中每个字段的名称，而'formats'则定义每个字段的类型。这里我们使用类型字符串定义字段类型。 'S30': 长度为30字节的字符串类型，由于结构中每个元素大小必须固定，因此需要制定字符串的长度。 'i'：32位整数，相当于np.int32。 'f'：32位单精度浮点数类型，相当于np.float32。 然后我们调用array()以创建数组，通过dtype参数指定所创建的数组的元素类型为persontype。下面查看数组a的元素类型： a.dtype # dtype({'names':['name','age','weight'], 'formats':['S30','&lt;i4','&lt;f4'], 'offsets':[0,32,36], 'itemsize':40, 'aligned':True}) 还可以用包含多个元组的列表来描述结构的类型： dtype([('name', '|S30'), ('age', '&lt;i4'), ('weight', '&lt;f4')]) 其中形如“（字段名，类型描述）”的元组描述了结构中的每个字段。类型字符串前面的'I'、'&lt;'、'&gt;'等字符表示字段值的字节顺序： 'I'：忽视字节顺序。 '&lt;'：低位字节在前，即小端模式。 '&gt;'：高位字节在前，即大端模式。 结构数组的存取方式和一般数组相同，通过下标能够取得其中的元素，注意元素的值看上去像是数组，实际上是结构： print a[0] a[0].dtype # ('Zhang', 32, 75.5) # dtype({'names':['name','age','weight'], 'formats':['S30','&lt;i4','&lt;f4'], 'offsets':[0,32,36], 'itemsize':40, 'aligned':True}) 我们可以使用字段名作为下标获取对应的字段值： a[0]['name'] # 'Zhang' a[0]是一个结构元素，它和数组a共享内存，因此可以通过修改它的字段改变原始数组中对应元素的字段。我们不但可以获得结构元素的某个字段，而且可以直接获得结构数组的字段，返回的是原始数组的视图，因此可以通过修改b[0]来改变a[0]['age']。 通过a.tostring()或a.tofile()方法，可以将数组a以二进制的方式转换成字符串或者写入文件： a.tofile('test.bin') 利用下面的C语言程序可以将test.bin文件中的数据读取出来。 vc struct person { char name[30]; int age; float weight; } p[3]; int main() { FILE *fp = fopen(&quot;test.bin&quot;, &quot;rb&quot;); fread(p, sizeof person, 2, fp); fclose(fp); for(int i = 0; i &lt; 2; ++i) printf(&quot;%s %d %f\\n&quot;, p[i].name, p[i].age, p[i].weight); } ufunc函数 ufunc相当于Python的map，能对数组的每一个元素执行运算。区别在于返回了一个新数组，并没有改变原数组的值。也可以通过out参数来指定保存计算结果的数组。另一个区别是NumPy的这些ufunc函数都是用C语言实现的，所以比Py2自带的函数用map去实现这样的功能要快十倍以上。 这些函数也支持单个数值的运算，但是在单个数值时会比math库中的函数慢很多。此外，对于单个数值的计算，np.sin()和math.sin返回值类型不同，NumPy的返回值是float64类型。通过下标运算获取的数组元素的类型为NumPy中定义的类型，将其转换为Python的标准类型还需要花费额外的事件。数组提供了item()方法来解决这个问题，用来获取数组中的单个元素，并且直接返回为标准的Python数据类型。 x = np.linspace(0, 2*np.pi, 10) y = np.sin(x, out = x) y is x # True 四则运算、比较运算和布尔运算 NumPy提供了很多ufunc函数，比如计算两个数组之和的add()函数，还有subtract，multiply等等。 使用==、&gt;等比较运算符对两个数组进行比较，将返回一个布尔数组，它的每个元素值都是两个数组对应元素的比较结果。由于Python中布尔运算使用and、or、not等关键字，无法被重载，因此数组的布尔运算只能通过相应的ufunc函数进行。这些函数名以logical_开头。 np.logical_or(a==b, a&gt;b) # 等同于 a &gt;= b 可以使用数组的any()和all()函数，和Python内置的函数相同。 bitwise_开头的是位运算函数。对于布尔数组来说，位运算和布尔运算结果相同，但是使用时位运算的优先级高于布尔运算。整数位运算和C语言位运算相同，注意元素类型的符号。 自定义ufunc函数 通过NumPy提供的标准ufunc函数，可以组合出复杂的表达式，在C语言级别对数组的每个元素进行计算。但是有时候这种表达式不易编写，而对每个元素进行计算的程序却很容易用Python实现，这是可以用frompyfunc()将计算单个元素的函数转换成ufunc函数，这样就可以方便地用所产生的ufunc函数对数组进行计算了。 下面是一个计算三角波上某点的Y坐标的函数。 def triangle_wave(x, c, c0, hc): x = x - int(x) if x &gt;= c: r = 0.0 elif x &lt; c0: r = x / c0 * hc else: r = (c-x) / (c-c0) * hc return r 通过frompyfunc()可以将计算单个值的函数转换为能对数组的每个元素进行计算的ufunc函数。值得注意的是，转化之后的函数返回值类型是object，需要用astype方法把它转化为双精度浮点数组。 frompyfunc(func, nin, nout) # 函数 传参个数 返回值个数 trignle_wave_ufunc = np.frompyfunc(triagnle_wave, 4, 1) 广播 当使用ufunc函数对两个数组进行计算时，ufunc函数会对这两个数组的对应元素进行计算，因此它要求这两个数组的形状相同。如果形状不同，会进行如下广播处理： 让所有输入数组都向维数最多的数组看起，不足部分通过加1补齐。 输出数组的shape属性是输入数组的shape属性的各个轴上的最大值。 如果输入数组的某个轴的长为1或与输出数组的对应轴长度相同，这个数组就能够用来计算，否则会报错。 当输入数组的某个轴长度为1时，沿着此轴运算时，都用此轴的第一组值。 ","link":"https://wzhzzmzzy.github.io/post/2017-09-08-Python科学计算"},{"title":"2017 CCPC网络赛记录","content":" 2017CCPC网络赛传送门 差不多整场都靠奚政巨和高书记，1005的找规律居然数据水到一队少加了1还能AC，要是能Hack我就涨分了（逃。但是其实无所谓的啦。1001赛后听刘博遥讲了奚政巨的思路，果然比我的要更精妙一点。扩展KMP也其实很水，只不过当时卡在别的题，没有去细想。真是亏啊。不过还是熟悉了一些东西，有收获就好了。 值得一补的题目 HDU 6150 - Vertex Cover 思维题。 HDU 6152 - Friend-Graph 思维题 + 暴力搜索。 HDU 6153 - A Secret E-KMP。 HDU 6153 - CaoHaha's staff 找规律。 HDU 6156 - Palindrome Function 数位DP，可以打表水过。 HDU - 6150 - 1001 Vertex Cover 题意 最小点覆盖是一个NP完全问题，现在小M找出了一个贪心法求最大点覆盖的算法。这个方法优先选择度数最大的点去覆盖。显然这个方法是错的，所以现在需要给出反例。这个反例需要让正解和小M的解法相差三倍或以上。程序输出这个反例即可。 思路 我的方法和奚政巨的方法类似，就是将点集分为两部分，一部分是交给贪心法去覆盖的点，称为点集A，一部分是正解需要删的点，称为点集B。如何建图呢？大概就是，点集A中的第一个点连接B中的前n-1个点，第二个点连接B中的前n-2个点，第n/2个点连接前n/2个点，第n/2+1个点连接后n/2个点，以此类推。这样，正解需要删除20个点时，就能满足题目的三倍要求。奚政巨的方法比我更好一些。我需要删的B集合中的点的度数是无法保证最大的，如果最大的话就能让点数再次减少，最优解只需要11个点。 比赛时很神奇的最后过了这道题，感觉还是美滋滋。赛中的写法不优美，赛后改良了一下。 代码 /** * Author: wzhzzmzzy * Question: HDU - 6150 * Algorithm: 找规律 **/ #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;cstdlib&gt; #include &lt;cmath&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;string&gt; #include &lt;vector&gt; #include &lt;queue&gt; using namespace std; #define REP(i,a,b) for(int i=a;i&lt;(b);++i) #define PER(i,a,b) for(int i=(b)-1;i&gt;=(a);--i) const int maxn = 100; void oup(int n) { int mp[maxn][maxn] = {}; vector&lt;int&gt; oup[maxn]; int cur = n+1, cnt = 0; PER(k, 1, n) REP(i, 0, n/k) { REP(j, 1+i*k, (i+1)*k+1) mp[cur][j] = 1; ++cur; } REP(i, n+1, cur) REP(j, 1, n+1) if(mp[i][j]) { ++cnt; oup[i].push_back(j); } printf(&quot;%d %d\\n&quot;, cur-1, cnt); REP(i, n+1, cur) for(auto j: oup[i]) printf(&quot;%d %d\\n&quot;, i, j); printf(&quot;%d\\n&quot;, n); REP(i, 1, 21) printf(&quot;%d\\n&quot;, i); } int main() { oup(20); } HDU - 6152 - 1003 Friend-Graph 题意 思路 代码 /** * Author: wzhzzmzzy * Question: HDU - 6152 * Algorithm: 水 **/ #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;cstdlib&gt; #include &lt;cmath&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;string&gt; #include &lt;vector&gt; #include &lt;queue&gt; #define REP(i, x, y) for(int i=(int)x;i&lt;=(int)y;++i) #define PER(i, x, y) for(int i=(int)y;i&gt;=(int)x;--i) using namespace std; int mp[10][10]; int main() { int t; scanf(&quot;%d&quot;, &amp;t); while (t--) { int n, flag = 0, x; scanf(&quot;%d&quot;, &amp;n); if (n &gt;= 6) flag = 1; if (flag) { REP(i, 1, n-1) REP(j, 1, n-i) scanf(&quot;%d&quot;, &amp;x); puts(&quot;Bad Team!&quot;); continue; } REP(i, 1, n-1) REP(j, 1, n-i) { scanf(&quot;%d&quot;, &amp;mp[i][i+j]); mp[i+j][i] = mp[i][i+j]; } REP(i, 1, n-2) REP(j, i+1, n-1) REP(k, j+1, n) { if (mp[i][j] &amp;&amp; mp[j][k] &amp;&amp; mp[i][k]) flag = 1; else if (!mp[i][j] &amp;&amp; !mp[j][k] &amp;&amp; !mp[i][k]) flag = 1; if (flag) break; } puts(flag ? &quot;Bad Team!&quot; : &quot;Great Team!&quot;); } } ","link":"https://wzhzzmzzy.github.io/post/2017-08-19-2017CCPC网络赛记录"},{"title":"2017多校第八场补题记录","content":" HDU多校训练赛第八场传送门 本来赛场上是提供了PDF版本的题面的，不过忘记存了，现在就看不见了。 值得一补的题目 HDU 6133 - Army Formations 二叉树启发式合并，用树状数组或者线段树加速。难度中等。已补。 HDU 6134 - Battlestation Operational 莫比乌斯反演或容斥。难度较高。已过，未证明。 HDU 6136 - Death Podracing 模拟，优先队列简化。难度中等。 HDU 6138 - Fleet of the Eternal Throne AC自动机。难度较高。 HDU 6143 - Killer Names DP找规律。简单。已过。 HDU - 6133 - 1001 Army Formations 题意 士兵们通过信息树上传消息。每个人拥有一个直属上级和最多两个直属下级。每个人都需要上传自己和自己子树的所有消息。上传消息有罚时，罚时计算方法为上传完成一条消息的最后时间。每个人有一条消息，上传需要时间为num[i]。 思路 赛中想到可以树DP，但是仔细想一想发现不是单纯的DFS可以解决，因为需要优先上传时间短的信息，所以需要排序和合并。通过树状数组的方法，可以很方便地求前缀和和合并子树。 代码 /** * Author: wzhzzmzzy * Question: HDU - 6133 * Algorithm: 树状数组 + 启发式合并 **/ #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;cstdlib&gt; #include &lt;cmath&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;string&gt; #include &lt;vector&gt; #include &lt;queue&gt; using namespace std; #define LL long long const int maxn = 1e5+7; struct Edge { int v, next; } edge[maxn&lt;&lt;1]; int head[maxn], tot, n; LL m, cnt; LL vis[maxn], sum[maxn]; int lson[maxn], rson[maxn], size[maxn]; int num[maxn], id[maxn], b[maxn]; LL ans[maxn]; void init() { tot = cnt = 0; memset(head, -1, sizeof head); memset(vis, 0, sizeof vis); memset(sum, 0, sizeof sum); memset(rson, -1, sizeof rson); memset(lson, -1, sizeof lson); memset(ans, 0, sizeof ans); } void add_edge(int u, int v) { edge[tot] = (Edge) { v, head[u] }; head[u] = tot++; } int lowbit(int x) { return x &amp; (-x); } bool cmp(int x, int y) { if (num[x] == num[y]) return x &lt; y; return num[x] &lt; num[y]; } void update(LL f[], int u, int w) { while (u &lt;= m) { f[u] += w; u += lowbit(u); } } LL query(LL f[], int u) { LL rt = 0; while (u) { rt += f[u]; u -= lowbit(u); } return rt; } void add_node(int u) { cnt += (query(vis, m) - query(vis, b[u])) * num[u]; cnt += query(sum, b[u]) + num[u]; update(vis, b[u], 1); update(sum, b[u], num[u]); } void delete_node(int u) { cnt -= (query(vis, m) - query(vis, b[u])) * num[u]; cnt -= query(sum, b[u]); update(vis, b[u], -1); update(sum, b[u], -num[u]); } void add_tree(int u) { add_node(u); if (~lson[u]) add_tree(lson[u]); if (~rson[u]) add_tree(rson[u]); } void delete_tree(int u) { delete_node(u); if (~lson[u]) delete_tree(lson[u]); if (~rson[u]) delete_tree(rson[u]); } void dfs_son(int u, int fa) { size[u] = 1; for (int i = head[u]; ~i; i = edge[i].next) { int v = edge[i].v; if (v == fa) continue; dfs_son(v, u); size[u] += size[v]; if (rson[u] == -1) rson[u] = v; else if (size[v] &gt; size[rson[u]]) lson[u] = rson[u], rson[u] = v; else lson[u] = v; } } void dfs(int u) { if (lson[u] == -1) { if (rson[u] == -1) { add_node(u); ans[u] = cnt; return; } dfs(rson[u]); add_node(u); ans[u] = cnt; return; } dfs(lson[u]); delete_tree(lson[u]); dfs(rson[u]); add_tree(lson[u]); add_node(u); ans[u] = cnt; } int main() { int t; scanf(&quot;%d&quot;, &amp;t); while (t--) { init(); scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; ++i) { scanf(&quot;%d&quot;, num+i); id[i] = i; } sort(id+1, id+1+n, cmp); b[id[1]] = 1; for (int i = 2; i &lt;= n; ++i) b[id[i]] = b[id[i-1]] + (num[i] == num[i-1] ? 0 : 1); m = b[id[n]]; for (int i = 1; i &lt; n; ++i) { int u, v; scanf(&quot;%d%d&quot;, &amp;u, &amp;v); add_edge(u, v); add_edge(v, u); } dfs_son(1, -1); dfs(1); for (int i = 1; i &lt;= n; ++i) printf(&quot;%lld &quot;, ans[i]); puts(&quot;&quot;); } return 0; } HDU - 6134 - 1002 Battlestation Operational 题意 给出 nnn，求 f(n)=∑i=1n∑j=1i⌈ij⌉[(i,j)=1]f(n)=\\sum_{i=1}^{n}\\sum_{j=1}^{i} \\left\\lceil \\frac{i}{j} \\right\\rceil \\left[ (i, j) = 1\\right]f(n)=∑i=1n​∑j=1i​⌈ji​⌉[(i,j)=1]。其中，[(i,j)=1]\\left[ (i, j) = 1\\right][(i,j)=1] 表示 gcd(i,j)=1gcd(i,j) = 1gcd(i,j)=1 时为 111，否则为 000。 思路 首先欧拉筛，求出 1⋯1061 \\cdots 10^61⋯106 中所有数的因数个数。然后求得因数个数的前缀和，筛去重复，就得到了结果。 代码 /** * Author: wzhzzmzzy * Question: 1002 * Algorithm: 容斥 **/ #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;cstdlib&gt; #include &lt;cmath&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;string&gt; #include &lt;vector&gt; #include &lt;queue&gt; using namespace std; #define LL long long const int N = 1000000; const LL maxn = N + 5; const LL MOD = 1e9 + 7; LL cnt[maxn], a[maxn], s[maxn], ans[maxn]; // cnt[i] -&gt; 1~N 中 i 的因数个数 void init() { fill(cnt, cnt + maxn, 0); for(int i = 1; i &lt;= N; i++) for(int j = i; j &lt;= N; j += i) ++cnt[j]; // 筛 a[1] = s[1] = ans[1] = 1; for(int i = 2; i &lt;= N; i++) { a[i] = a[i-1] + cnt[i-1] + 1; // 因数 s[i] = a[i]; } for(int i = 1; i &lt;= N; i++) for(int j = i&lt;&lt;1; j &lt;= N; j += i) s[j] -= s[i]; // 反筛 for(int i = 2; i &lt;= N; i++) ans[i] = ans[i-1] + s[i]; } int main() { init(); int n; while(~scanf(&quot;%d&quot;, &amp;n)) printf(&quot;%lld\\n&quot;, ans[n] % MOD); return 0; } HDU - 6143 - 1011 Killer Names 题意 要求用m个字符组成两个n长度的串，允许在一个串中出现相同字符，但是两个串之间不能有相同字符，求有多少种组成方法。 思路 一开始想了公式，但是发现公式不管怎么改都会有重复，换成DP递推的思路就过了。 代码 /** * Author: wzhzzmzzy * Question: 1011 * Algorithm: 瞎搞 **/ #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;cstdlib&gt; #include &lt;cmath&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;string&gt; #include &lt;vector&gt; #include &lt;queue&gt; using namespace std; #define LL long long const int maxn = 2000+7; const LL mod = 1e9+7; LL fac[maxn], power[maxn], dp[maxn][maxn]; LL quick_pow(LL a,LL b) { LL ans = 1; while (b &gt; 0) { if (b &amp; 1) ans = ans * a % mod; b &gt;&gt;= 1; a = a * a % mod; } return ans; } LL times(int x, int y) { return fac[x] * power[x - y] % mod; // x! / (x-y)! } void init() { memset(dp, 0, sizeof dp); fac[0] = dp[0][0] = 1; for (int i = 1; i &lt;= 2000; ++i) // i! fac[i] = fac[i-1] * i % mod; power[2000] = quick_pow(fac[2000], mod-2); // 逆元 for (int i = 2000; i &gt;= 1; --i) power[i-1] = power[i] * i % mod; // (i!)^(-1) for (int i = 1; i &lt;= 2000; ++i) for (int j = 1; j &lt;= 2000; ++j) dp[i][j] = (dp[i-1][j] * j + dp[i-1][j-1]) % mod; } int main() { init(); int t; scanf(&quot;%d&quot;, &amp;t); while (t--) { int n, m; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); LL ans = 0; for (int i = 2; i &lt;= m; ++i) for (int j = 1; j &lt; i; ++j) ans = (ans + dp[n][j] * dp[n][i-j] % mod * times(m, i)) %mod; printf(&quot;%lld\\n&quot;, ans); } } ","link":"https://wzhzzmzzy.github.io/post/2017-08-18-2017多校第八场补题记录"},{"title":"2017多校第六场补题记录","content":" HDU多校训练赛第六场传送门 HDU - 6096 - 1001 String 题意 Bob有一本字典，其中有N个单词，此时给你M个前后缀对，对于每个前后缀对，求出其能匹配多少个字典中的单词。对于每组样例，N,Q≤100000N,Q \\le 100000N,Q≤100000，∑Si+Pi≤500000\\sum{S_i+P_i} \\le 500000∑Si​+Pi​≤500000，∑Wi≤500000\\sum{W_i} \\le 500000∑Wi​≤500000。 思路 赛中交了一发Hash_Set，一发AC自动机，一发AC+Trie，都TLE了。看出题人的题解说Hash可以过，那应该是 O(n2)O(n^2)O(n2) + Set时间复杂度过高了。 赛后百度了一发题解，发现大神居然可以直接用Trie直接过，很神奇的解法。 首先对于模式串 WiW_iWi​，重构成前后缀交叉的字符串 ststst，是原串的两倍长度。 st[0] = w[0], st[1] = w[-1], st[2] = w[1], st[3] = w[-2]，以此类推。将字符串 ststst 插入字典树时，对于每个节点，更新经过当前节点的模式串数量（ed[i]），并储存这些串的长度（G[i]）。nxt数组用于跳转到该节点的最后一个字符串的下一个字符长度处。 然后对于每一对前后缀 Pi,SiP_i, S_iPi​,Si​，如上将其重构成新的字符串 ststst，不足之处用'*'补全。匹配时使用两个队列，q[0]遍历前缀，q[1]遍历后缀。从根节点开始遍历。双队列转移之后，用lower_bound获取该点所有字符串长度中不超过前后缀长度和（rt）的部分。 代码 /** * Author: wzhzzmzzy * Question: HDU - 6096 * Algorithm: Trie **/ #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;cstdlib&gt; #include &lt;cmath&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;string&gt; #include &lt;vector&gt; #include &lt;queue&gt; using namespace std; const int maxn = 5e5+7; char s[maxn], t[maxn], st[maxn&lt;&lt;1]; int n, q; struct Trie { // 模板 int L, root, nxt[maxn&lt;&lt;1][26], ed[maxn&lt;&lt;1]; vector&lt;int&gt; G[maxn&lt;&lt;1]; int newNode() { // new a trie node for (int i = 0; i &lt; 26; ++i) nxt[L][i] = -1; ed[L] = 0; return L++; } void init() { // refresh trie L = 0; for (int i = 0; i &lt; maxn*2; ++i) G[i].clear(); root = newNode(); } void build(char s[], int len) { // insert a word int now = root, slen = strlen(s); for (int i = 0; i &lt; slen; ++i) { int id = s[i] - 'a'; // s[i]'s value if (nxt[now][id] == -1) nxt[now][id] = newNode(); now = nxt[now][id]; G[now].push_back(len); ++ed[now]; } } void dfs(int x) { // init all vector sort(G[x].begin(), G[x].end()); for (int i = 0; i &lt; 26; ++i) if (!~nxt[x][i]) dfs(nxt[x][i]); } } trie; int main() { // freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); int T; scanf(&quot;%d&quot;, &amp;T); while (T--) { // init &amp; input trie.init(); scanf(&quot;%d%d&quot;, &amp;n, &amp;q); for (int i = 1; i &lt;= n; ++i) { scanf(&quot;%s&quot;, s); int len = strlen(s); for (int i = 0; s[i]; ++i) st[i&lt;&lt;1] = s[i], // 前缀 st[i*2+1] = s[len-1-i]; // 后缀 st[len&lt;&lt;1] = '\\0'; // 前后缀混合串 trie.build(st, len); } trie.dfs(0); // solve for (int i = 1; i &lt;= q; ++i) { scanf(&quot;%s%s&quot;, s, t); // s -&gt; prefix , t -&gt; suffix int len1 = strlen(s), len2 = strlen(t); int rt = len1 + len2, len = max(len1, len2); for (int j = 0; j &lt; len; ++j) { st[j&lt;&lt;1] = j &lt; len1 ? s[j] : '*'; st[j*2+1] = j &lt; len2 ? t[len2-1-j] : '*'; } len *= 2, st[len] = '\\0'; // 前后缀混合串 queue&lt;int&gt; q[2]; q[0].push(0); // 前缀队列 0， 后缀队列 1 int tmp = 0, ans = 0; for (int j = 0; j &lt; len; ++j) { tmp ^= 1; // tmp -&gt; push 的队列 int id = st[j] - 'a'; // st[j]'s value while (!q[tmp^1].empty()) { int now = q[tmp^1].front(); q[tmp^1].pop(); if (st[j] == '*') { for (int k = 0; k &lt; 26; ++k) if (~trie.nxt[now][k]) q[tmp].push(trie.nxt[now][k]); } else if (~trie.nxt[now][id]) q[tmp].push(trie.nxt[now][id]); } } while (!q[tmp].empty()) { int now = q[tmp].front(); q[tmp].pop(); int cnt = lower_bound(trie.G[now].begin(), trie.G[now].end(), rt) - trie.G[now].begin(); ans -= cnt; // 去掉重叠部分 ans += trie.ed[now]; } printf(&quot;%d\\n&quot;, ans); } } return 0; } HDU - 6098 - 1003 Inversion 题意 给出一个数列 AAA，求一个数列 BBB，数列 BBB 满足 Bi=max⁡i∤jAjB_{i}= \\max\\limits_{i\\nmid j}A_{j}Bi​=i∤jmax​Aj​。 思路 其实暴力筛选是可以的，不过用Set可以优化一下。记录 AiA_iAi​ 的值和下标，然后按值排序，按下标用Set查找即可。 代码 /** * Author: BOSON * Question: HDU - 6098 * Algorithm: Set 暴力瞎搞 **/ #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;cstdlib&gt; #include &lt;cmath&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;string&gt; #include &lt;vector&gt; #include &lt;queue&gt; #include &lt;set&gt; using namespace std; const int maxn = 100000+7; struct node { int x, y; bool operator &lt; (const node &amp;rhs) const { return y &gt; rhs.y; } } a[maxn]; int ans[maxn]; set&lt;int&gt; s; int main() { int t; scanf(&quot;%d&quot;, &amp;t); while (t--) { int n; scanf(&quot;%d&quot;, &amp;n); s.clear(); for (int i = 1; i &lt;= n; ++i) { scanf(&quot;%d&quot;, &amp;a[i].y), ans[i] = 0, a[i].x = i; if (i != 1) s.insert(i); } sort(a + 1, a + 1 + n); for (int i = 1; i &lt;= n; ++i) { int x = a[i].x, y = a[i].y; for (set&lt;int&gt;::iterator it = s.begin(); it != s.end();) { if (x % (*it) != 0 ) { ans[*it] = y; s.erase(it++); if (s.empty()) break; } else ++it; } if (s.empty()) break; } for (int i = 2; i &lt;= n; ++i) printf(&quot;%d%c&quot;, ans[i], i == n ? '\\n':' '); } return 0; } HDU - 6103 - 1008 题意 Bob有一个字符串 SSS，要求求出 SSS 中最长的两个子串，且这两个子串 A,BA,BA,B 满足 $$dis_{A,B} = \\sum\\limits_{i=0}^{n-1}|A_{i}-B_{n-1-i}| \\le m$$。对于每组样例，2≤∥S∥≤50002 \\leq \\|S\\| \\leq 50002≤∥S∥≤5000。 思路 一开始有一个二分的思路，但是算了一下发现是 O(n3)O(n^3)O(n3)，后来灵机一动，想到一个尺取法，也就是双指针。因为有两个限制条件，一个是子串，一个是 mmm，子串限制了连续，而 mmm 限制了子串长度，所以可以用双指针优化遍历，复杂度 O(n2)O(n^2)O(n2)。 代码 /** * Author: wzhzzmzzy * Question: HDU - 6103 * Algorithm: 双指针优化遍历 **/ #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;cstdlib&gt; #include &lt;cmath&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;string&gt; #include &lt;vector&gt; #include &lt;queue&gt; using namespace std; const int maxn = 5000+7; int a[maxn], ans, m; char s[maxn]; void calc(int p, int q){ int l = 0, r = 0, sum = 0; while(q-r &gt; p+r){ sum += abs(s[p+r] - s[q-r]), ++r; if(q-l*2-p+1 &lt;= 2*ans) break; while(sum &gt; m) sum -= abs(s[p+l]-s[q-l]), ++l; if(ans &lt; r-l) ans = r - l; } } int main() { int n, t; scanf(&quot;%d&quot;, &amp;t); while (t--) { scanf(&quot;%d%s&quot;,&amp;m, s); n = strlen(s), ans = 0; for(int i = n-1; i; --i) calc(0, i); for(int i = 1; i &lt; n-1; ++i) calc(i, n-1); printf(&quot;%d\\n&quot;, ans); } return 0; } HDU - 6105 - 1010 Gameia 题意 Bob和Alice在一起玩游戏，棋盘是一棵树，Alice先手。Alice的回合，她可以任选一个点放上白子，下一回合，Bob可以任选一个点放上黑子，黑子相邻的所有点都会被染黑。Bob还有一个特权，他可以在任意时间，将一条边剪断。特权可以使用K次。 思路 一开始觉得是博弈，后来发现完全就是个思维题。首先，树的大小如果是奇数，那么Alice必胜。如果Bob的次数无法把树切成K+1个两两匹配，那Alice也必胜。如果树本身就无法分为两两匹配，那么Alice也必胜。否则Bob胜。 代码 /** * Author: wzhzzmzzy * Question: HDU - 6105 * Algorithm: 思维 **/ #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;cstdlib&gt; #include &lt;cmath&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;string&gt; #include &lt;vector&gt; #include &lt;queue&gt; using namespace std; const int N = 5000+7; const int M = 1000+7; char st[N]; typedef pair&lt;int,int&gt; P; int main() { int T; scanf(&quot;%d&quot;, &amp;T); while (T--) { // init int n, k, t = 1; scanf(&quot;%d%d&quot;, &amp;n, &amp;k); if (n%2 || k &lt; n/2-1) t = 0; // 奇数 Alice 必胜，偶数并且 Bob 无法分为匹配 Alice 也必胜 vector&lt;int&gt; a[M]; int vis[M] = {}, cnt[M] = {}, fa[M] = {}; P p[M]; for (int i = 1; i &lt;= n; ++i) a[i].clear(), p[i].first = 0, p[i].second = i; // first -&gt; 相连的点的数量，second -&gt; 点编号 // solve // add edge for (int i = 2; i &lt;= n; ++i) { scanf(&quot;%d&quot;, fa+i); a[i].push_back(fa[i]); a[fa[i]].push_back(i); ++p[i].first, ++p[fa[i]].first; ++cnt[i], ++cnt[fa[i]]; } // calc match // 对于每个叶子节点，在树中删去它父节点为根的子树 // 如果删去过程中， for (int i = 1; i &lt; n; i += 2) { sort(p+i, p+n+1); // 找到叶子节点或者根节点 // for (int j = i; j &lt;= n; ++j) // cout &lt;&lt; p[j].first &lt;&lt; &quot; &quot; &lt;&lt; p[j].second &lt;&lt; endl; // cout &lt;&lt; endl; if (p[i].first != 1) { t = 0; break; } int v = p[i].second, u; for (int j = 0; j &lt; a[v].size(); ++j) if (!vis[a[v][j]]) { // 找到唯一指定节点 u = a[v][j]; break; } // cout &lt;&lt; &quot;v: &quot; &lt;&lt; v &lt;&lt; &quot; u: &quot; &lt;&lt; u &lt;&lt; endl; for (int k = i+2; k &lt;= n; ++k) if (u == p[k].second) { // 避免遍历到这个节点 swap(p[k], p[i+1]); break; } for (int j = 0; j &lt; a[u].size(); ++j) for (int k = i+2; k &lt;= n; ++k) if (a[u][j] == p[k].second) { // cout &lt;&lt; &quot;delete edge: &quot; &lt;&lt; u &lt;&lt; &quot;-&gt;&quot; &lt;&lt; p[k].second &lt;&lt; endl; --p[k].first; break; // 消去 v 节点的影响 } vis[v] = vis[u] = 1; } puts(t? &quot;Bob&quot; : &quot;Alice&quot;); } } HDU - 6106 - 1011 Classes 思路 签到题就不写题意了，小坑在于判断是否是无效数据。 代码 /** * Author: wzhzzmzzy * Question: HDU - 6106 * Algorithm: 签到 **/ #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;cstdlib&gt; #include &lt;cmath&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;string&gt; #include &lt;vector&gt; #include &lt;queue&gt; #define BRK(a) if (a&lt;0) continue; using namespace std; void solve() { int n; scanf(&quot;%d&quot;, &amp;n); int ans = 0; while (n--) { int a, b, c, ab, bc, ac, abc; scanf(&quot;%d%d%d%d%d%d%d&quot;, &amp;a, &amp;b, &amp;c, &amp;ab, &amp;bc, &amp;ac, &amp;abc); int A = a - ab - ac + abc; BRK(A); int B = b - ab - bc + abc; BRK(B); int C = c - ac - bc + abc; BRK(C); int AB = ab - abc; BRK(AB); int AC = ac - abc; BRK(AC); int BC = bc - abc; BRK(BC); int sum = A+B+C+AB+AC+BC+abc; ans = max(ans, sum); } printf(&quot;%d\\n&quot;, ans); } int main() { int t; scanf(&quot;%d&quot;, &amp;t); while (t--) solve(); } ","link":"https://wzhzzmzzy.github.io/post/2017-08-11-2017多校第六场补题记录"},{"title":"树形DP入门专题题解","content":" Vjudge 树形DP入门专题 专题中题目名称取自Android OS版本名。 所谓树形DP 一般的树形DP题，都是给出一张树形图，然后用DFS去深搜，获取每个节点多个状态的值。最简单的入门题如POJ-2342，只需要一遍DFS，用子节点回溯更新父节点即可。一道经典题是HDU-2196，这道题用了分别深搜求每个节点的父节点状态值和子节点状态值，最后求和的方法，复杂度 O(n2)O(n^2)O(n2) 。这是树形DP的经典方法，大多数树形DP题都是通过这种方法求解。 入门部分 POJ - 2342 - Anniversary party 题意 给出每个节点的权值，以及一棵有向边组成的树，有向边 (u,v)(u, v)(u,v) 表示 vvv 是 uuu 的直属上级，直属上下级不能同时被选中，要求如何选择节点可以使节点总和最大。 思路 用dp[i][0/1]表示i节点没有被选中或被选中时，以其为根的子树总和。POJ这道题可以直接用fa数组存边，DFS回溯时用子节点v权值更新父节点u。 转移方程： dp[u][1] += dp[v][0], dp[u][0] += max(dp[v][1], dp[v][0]) 代码 /** * Author: wzhzzmzzy * Question: POJ - 2342 * Algorithm: 树形 DP 入门 **/ #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; using namespace std; //#define LOCAL const int maxn = 6000+7; int n, fa[maxn], dp[maxn][2]; bool vis[maxn]; int init() { int root, u, v; memset(fa, 0, sizeof fa); memset(vis, 0, sizeof vis); for (int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, dp[i]+1); root = 1; while (scanf(&quot;%d%d&quot;, &amp;u, &amp;v), u) fa[u] = v; while (fa[root]) root = fa[root]; return root; } void solve(int u) { vis[u] = 1; for (int v = 1; v &lt;= n; ++v) if (!vis[v] &amp;&amp; fa[v] == u) { solve(v); dp[u][1] += dp[v][0]; dp[u][0] += max(dp[v][1], dp[v][0]); } } int main(){ #ifdef LOCAL freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); #endif while (~scanf(&quot;%d&quot;, &amp;n)) { int root = init(); solve(root); int ans = max(dp[root][0], dp[root][1]); printf(&quot;%d\\n&quot;, ans); } return 0; } HDU - 1520 - Anniversary party 题意 题意同上一题。 思路 虽然题面完全一样，但是这道题有不少坑。所以用了一种更好的方法来写。链式前向星存边。注意一个文件只有一个样例。 代码 /** * Author: wzhzzmzzy * Question: HDU - 1520 * Algorithm: 树形 DP 入门 **/ #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; using namespace std; const int maxn = 6000+7; struct node { int son, fa, bro, now, temp; int max() { return now &gt; temp ? now : temp; } void init() { son = fa = bro = temp = 0; } } tree[maxn]; void dfs(int root) { int son = tree[root].son; while (son) { dfs(son); tree[root].now += tree[son].temp; tree[root].temp += tree[son].max(); son = tree[son].bro; } } int main() { int n, k, l; while (~scanf(&quot;%d&quot;, &amp;n) &amp;&amp; n) { for (int i = 1; i &lt;= n; ++i) { scanf(&quot;%d&quot;, &amp;tree[i].now); tree[i].init(); } while (scanf(&quot;%d%d&quot;, &amp;l, &amp;k) &amp;&amp; l+k) { tree[l].fa = k; tree[l].bro = tree[k].son; tree[k].son = l; } for (int i = 1; i &lt;= n; ++i) if (!tree[i].fa) { dfs(i); printf(&quot;%d\\n&quot;, tree[i].max()); break; } } return 0; } HDU - 2196 - Computer 题意 有一棵计算机网络树，每条边有权值，求每个结点到树上最远结点的距离。 思路 用dp[i][0/1/2]分别记录i结点子树最大/子树次大/父节点最大距离。第一遍dfs_son用子节点回溯更新父节点的子树最大、次大距离，第二遍dfs_fa用父节点更新子节点向上走的最大距离，此时需要判断该子树是否是父节点的最大距离子树。 代码 /** * Author: wzhzzmzzy * Question: HDU - 2196 * Algorithm: 树形 DP 入门 **/ #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; using namespace std; const int maxn = 10000+7; struct Edge { int v, w, next; } edge[maxn&lt;&lt;1]; int head[maxn], tot; int dp[maxn][3], lson[maxn]; // 0 子节点最大 1 子节点次大 2 父节点最大 void init() { memset(dp, 0, sizeof dp); memset(head, -1, sizeof head); memset(lson, 0, sizeof lson); tot = 0; } void add_edge(int u, int v, int w) { edge[tot] = (Edge) { v, w, head[u] }; head[u] = tot++; } void dfs_son(int u, int fa) { for (int i = head[u]; ~i; i = edge[i].next) { int v = edge[i].v, w = edge[i].w; if (v == fa) continue; dfs_son(v, u); if (dp[v][0]+w &gt; dp[u][0]) { lson[u] = v; dp[u][1] = dp[u][0]; dp[u][0] = dp[v][0] + w; } else dp[u][1] = max(dp[v][0] + w, dp[u][1]); } } void dfs_fa(int u, int fa) { for (int i = head[u]; ~i; i = edge[i].next) { int v = edge[i].v, w = edge[i].w; if (v == fa) continue; v == lson[u]? dp[v][2] = max(dp[u][1], dp[u][2]) + w: dp[v][2] = max(dp[u][0], dp[u][2]) + w; dfs_fa(v, u); } } int main() { int n; while (~scanf(&quot;%d&quot;, &amp;n) &amp;&amp; n) { init(); for (int v = 2; v &lt;= n; ++v) { int u, w; scanf(&quot;%d%d&quot;, &amp;u, &amp;w); add_edge(u, v, w); add_edge(v, u, w); } dfs_son(1, -1); dfs_fa(1, -1); for (int i = 1; i &lt;= n; ++i) printf(&quot;%d\\n&quot;, max(dp[i][0], dp[i][2])); } return 0; } 简单题（套路题） 下面这些题基本都可以用 HDU-2196 的套路来轻松解决。 CodeForces - 219D - Choosing Capital for Treeland 题意 有一棵有向边树，找出一个点，让其可以到达所有其他点。这需要翻转某几条有向边。要求找出最小的翻转数目，和满足这个翻转数目的点。 思路 存边时将正向赋值为0，反向赋值为1。对于子树，回溯更新到达子树上每个点需要翻转的边数。对于父节点，直接取父节点的值减去当前子树即可。注意这里有一个小问题，减去当前子树时，是要把最终结果赋值给子树根节点的，也就是说要将父节点到子节点的边减去，然后加上子节点到父节点的边。 代码 /** * Author: wzhzzmzzy * Question: CodeForces - 219D * Algorithm: 树形 DP **/ #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; #include &lt;vector&gt; using namespace std; //#define LOCAL const int maxn = 2e5+7; struct Edge { int v, w, next; } edge[maxn&lt;&lt;1]; int head[maxn], tot; int dp[maxn][2]; void init() { tot = 0; memset(head, -1, sizeof head); memset(dp, 0, sizeof dp); } void add_edge(int u, int v, int w) { edge[tot] = (Edge) { v, w, head[u] }; head[u] =tot++; } void dfs_son(int u, int fa) { for (int i = head[u]; ~i; i = edge[i].next) { int v = edge[i].v, w = edge[i].w; if (v == fa) continue; dfs_son(v, u); dp[u][0] += dp[v][0] + w; } } void dfs_fa(int u, int fa) { for (int i = head[u]; ~i; i = edge[i].next) { int v = edge[i].v, w = edge[i].w, wo = edge[i^1].w; if (v == fa) continue; dp[v][1] += dp[u][0]-dp[v][0]+dp[u][1]-w+wo; dfs_fa(v, u); } } int main() { #ifdef LOCAL freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); #endif int n; scanf(&quot;%d&quot;, &amp;n); init(); for (int i = 2; i &lt;= n; ++i) { int u, v; scanf(&quot;%d%d&quot;, &amp;u, &amp;v); add_edge(u, v, 0); add_edge(v, u, 1); } dfs_son(1, -1); dfs_fa(1, -1); int mi = 0x3f3f3f3f; for (int i = 1; i &lt;= n; ++i) mi = min(mi, dp[i][0]+dp[i][1]); vector&lt;int&gt; ans; for (int i = 1; i &lt;= n; ++i) if (dp[i][1]+dp[i][0] == mi) ans.push_back(i); printf(&quot;%d\\n&quot;, mi); for (int i = 0; i &lt; (int)ans.size()-1; ++i) printf(&quot;%d &quot;, ans[i]); printf(&quot;%d&quot;, ans.back()); return 0; } POJ - 3107 - Godfather 题意 要求去掉树上的一个节点，使得树的剩余最大部分最小。 思路 在对于子树DFS的过程中，需要回溯更新所有子树的结点数，和最大子树结点数。对于父节点，只需要 O(n)O(n)O(n) 更新即可。 代码 /** * Author: wzhzzmzzy * Question: POJ - 3107 * Algorithm: 树形 DP **/ #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; #include &lt;vector&gt; using namespace std; //#define LOCAL const int maxn = 50000+7; struct Edge { int v, w, next; } edge[maxn &lt;&lt; 1]; int head[maxn], tot; int dp[maxn][3]; void init() { memset(head, -1, sizeof head); memset(dp, 0, sizeof dp); tot = 0; } void add_edge(int u, int v, int w) { edge[tot] = (Edge) { v, w, head[u] }; head[u] = tot++; } void dfs_son(int u, int fa) { for (int i = head[u]; ~i; i = edge[i].next) { int v = edge[i].v; if (v == fa) continue; dfs_son(v, u); dp[u][0] += dp[v][0] + 1; // sum of son tree dp[u][1] = max(dp[v][0] + 1, dp[u][1]); // max of son tree } } int main() { #ifdef LOCAL freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); #endif int n; while (~scanf(&quot;%d&quot;, &amp;n) &amp;&amp; n) { // input init(); for (int i = 1; i &lt; n; ++i) { int u, v; scanf(&quot;%d%d&quot;, &amp;u, &amp;v); add_edge(u, v, 1); add_edge(v, u, 1); } dfs_son(1, -1); for (int u = 1; u &lt;= n; ++u) { dp[u][0] = n - dp[u][0] - 1; dp[u][2] = max(dp[u][1], dp[u][0]); } int mi = 0x3f3f3f3f, i; vector&lt;int&gt; ans; for (int u = 1; u &lt;= n; ++u) mi = min(mi, dp[u][2]); for (int u = 1; u &lt;= n; ++u) if (dp[u][2] == mi) ans.push_back(u); for (i = 0; i &lt; (int)ans.size()-1; ++i) printf(&quot;%d &quot;, ans[i]); printf(&quot;%d\\n&quot;, ans[i]); } return 0; } POJ - 2378 - Tree Cutting 题意 题意和上一题类似。也是去掉一个树上的节点，使得树的最大分块节点数不到总结点数的一半。 思路 和上一题相似。 代码 /** * Author: wzhzzmzzy * Question: POJ - 2378 * Algorithm: 树形 DP **/ #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; #include &lt;vector&gt; using namespace std; //#define LOCAL const int maxn = 10000+7; struct Edge { int v, w, next; } edge[maxn&lt;&lt;1]; int head[maxn], tot; int dp[maxn][3]; void init() { memset(head, -1, sizeof head); memset(dp, 0, sizeof dp); tot = 0; } void add_edge(int u, int v, int w) { edge[tot] = (Edge) { v, w, head[u] }; head[u] = tot++; } void dfs(int u, int fa) { for (int i = head[u]; ~i; i = edge[i].next) { int v = edge[i].v; if (v == fa) continue; dfs(v, u); dp[u][0] += dp[v][0] + 1; dp[u][1] = max(dp[u][1], dp[v][0]+1); } } int main() { #ifdef LOCAL freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); #endif int n; while (~scanf(&quot;%d&quot;, &amp;n) &amp;&amp; n) { int mid = n &gt;&gt; 1; init(); for (int i = 1; i &lt; n; ++i) { int u, v; scanf(&quot;%d%d&quot;, &amp;u, &amp;v); add_edge(u, v, 1); add_edge(v, u, 1); } dfs(1, -1); for (int i = 1; i &lt;= n; ++i) dp[i][0] = n - dp[i][0] - 1; for (int i = 1; i &lt;= n; ++i) dp[i][2] = max(dp[i][0], dp[i][1]); vector&lt;int&gt; ans; for (int i = 1; i &lt;= n; ++i) if (dp[i][2] &lt;= mid) ans.push_back(i); if (!ans.size()) puts(&quot;NONE&quot;); else for (int i = 0; i &lt; (int)ans.size(); ++i) printf(&quot;%d\\n&quot;, ans[i]); } return 0; } POJ - 3140 - Contestants Division 题意 在树上去掉一条边，使树两边的节点权值总和差最小。 思路 一开始没读懂题意。DFS统计所有子树的权值，然后只需要 O(n)O(n)O(n) 遍历，比较一遍即可。注意会爆int，需要把更大的INF。 代码 /** * Author: wzhzzmzzy * Question: POJ - 3140 * Algorithm: 树形 DP **/ #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; using namespace std; //#define LOCAL #define LL long long const int maxn = 100000+7; struct Edge { int v, w, next; } edge[maxn&lt;&lt;1]; int head[maxn], tot; LL dp[maxn][3], sum; void init() { memset(head, -1, sizeof head); memset(dp, 0, sizeof dp); tot = sum = 0; } void add_edge(int u, int v, int w) { edge[tot] = (Edge) { v, w, head[u] }; head[u] = tot++; } void dfs(int u, int fa) { for (int i = head[u]; ~i; i = edge[i].next) { int v = edge[i].v; if (v == fa) continue; dfs(v, u); dp[u][0] += dp[v][0]; } } LL _abs(LL x) { return x &gt;= 0 ? x : -x; } int main() { #ifdef LOCAL freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); #endif int n, m, cas = 1; while (~scanf(&quot;%d%d&quot;, &amp;n, &amp;m) &amp;&amp; n+m) { init(); for (int i = 1; i &lt;= n; ++i) { scanf(&quot;%lld&quot;, dp[i]); sum += dp[i][0]; } for (int i = 1; i &lt; n; ++i) { int u, v; scanf(&quot;%d%d&quot;, &amp;u, &amp;v); add_edge(u, v, 0); add_edge(v, u, 0); } dfs(1, -1); LL mi = 21474836470000000; for (int i = 1; i &lt;= n; ++i) { dp[i][1] = sum - dp[i][0]; dp[i][2] = _abs(dp[i][1] - dp[i][0]); mi = min(dp[i][2], mi); } printf(&quot;Case %d: %lld\\n&quot;, cas++, mi); } return 0; } 难题 HDU - 5834 - Magic boy Bi Luo with his excited tree 题意 有一棵树，点和边都有权值。到达一个点加上点权，经过一条边减去边权。多次经过边多次计算，但是点权只能加一次。求能获得的最大权值。 思路 可以算是比较复杂的树形DP了，主要是数据处理相当麻烦。首先对于i点有四种情况，f[i][0]表示从i出发，经过子树后又回到i点的最大权值，f[i][1]就表示停留在子树当中的最大权值。g[i][0]表示向父节点走回到i点能获得的最大权值，g[i][1]表示不回到i点的最大权值。 最终答案就是max(f[i][1]+g[i][0], f[i][0]+g[i][1])。 具体解法看代码注释。 代码 /** * Author: wzhzzmzzy * Question: HDU - 5834 * Algorithm: 树形 DP **/ #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; using namespace std; //#define LOCAL const int maxn = 1e5+7; struct Edge { int v, w, next; } edge[maxn&lt;&lt;1]; int head[maxn], tot; int f[maxn][2], g[maxn][2], val[maxn]; // f i 1/0 -&gt; i 子树不回/回 // g i 1/0 -&gt; i 祖先不回/回 void init() { memset(head, -1, sizeof head); tot = 0; } void add_edge(int u, int v, int w) { edge[tot] = (Edge) { v, w, head[u] }; head[u] = tot++; } void dfs_son(int u, int fa) { f[u][1] = f[u][0] = val[u]; for (int i = head[u]; ~i; i = edge[i].next) { int v = edge[i].v, w = edge[i].w; if (v == fa) continue; dfs_son(v, u); f[u][0] += max(0, f[v][0]-w*2); } int mx = 0; for (int i = head[u]; ~i; i = edge[i].next) { int v = edge[i].v, w = edge[i].w; if (v == fa) continue; mx = max(mx, f[v][1]-w-max(0, f[v][0]-w*2)); } f[u][1] = f[u][0] + mx; } void dfs_fa(int u, int fa) { int mx = 0, nmx = 0, temp; // 最大 次大 for (int i = head[u]; ~i; i = edge[i].next) { // 求出一个可以最大化收益的不回头子节点，以及其次的节点 int v = edge[i].v, w = edge[i].w; if (v == fa) continue; temp = f[v][1] - w - max(0, f[v][0]-w*2); if (temp &gt; mx) nmx = mx, mx = temp; else nmx = max(nmx, temp); } for (int i = head[u]; ~i; i = edge[i].next) { int v = edge[i].v, w = edge[i].w; if (v == fa) continue; temp = f[u][0] - max(0, f[v][0]-w*2); int mmx = max(temp, g[u][0]) - w*2; // 只走子节点和只走父节点哪个更大一点？ mmx = max(mmx, g[u][0]+temp-w*2-val[u]); // 上述最大的和父子节点都走哪个更大？ g[v][0] = val[v] + max(0, mmx); // 更新子节点 int t = 0; // 求消去v影响后的u子树不回头值 if (f[v][0] - w*2 &gt; 0) { // 这个子节点回头可以走的话 if (mx == f[v][1] - w - f[v][0] + w*2) // 这个子节点是收益最大化点吗？ t = f[u][1] - f[v][1] + w + nmx; // 是的话消去影响（取次大） else t = f[u][1] - f[v][0] + w*2; // 否则直接取 } else if (f[v][1] - w &gt; 0) { // 子节点可以作为最后终点的话同上 if (mx == f[v][1] - w) t = f[u][1] - f[v][1] + w + nmx; else t = f[u][1]; } else t = f[u][1]; // 不能走直接取 mmx = max(g[u][1], t) - w; // 只走父节点和子树中取最大 mmx = max(mmx, max(g[u][0]+t, g[u][1]+temp) - w - val[u]); // 上述最大和父子节点都走取最大 g[v][1] = val[v] + max(0, mmx); dfs_fa(v, u); } } int main() { #ifdef LOCAL freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); #endif int t, cas = 1; scanf(&quot;%d&quot;, &amp;t); while (t--) { init(); int n; scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, val+i); for (int i = 2; i &lt;= n; ++i) { int u, v, w; scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w); add_edge(u, v, w); add_edge(v, u, w); } dfs_son(1, -1); g[1][0] = g[1][1] = val[1]; dfs_fa(1, -1); printf(&quot;Case #%d:\\n&quot;, cas++); for (int i = 1; i &lt;= n; ++i) printf(&quot;%d\\n&quot;, max(g[i][0]+f[i][1], g[i][1]+f[i][0])-val[i]); } } POJ - 2152 - Fire 题意 一棵城市树上，选择一些节点修建消防站。在i点修消防站需要花费w[i]，并且最终图上的每个点，在d[i]范围内必须要有一座消防站。 思路 国家集训队06年陈启峰论文上的一道题。很难做。 首先对于每个点，我们都需要遍历过它的所有子节点才能更新它的值。我们用dp[i][j]表示j节点修建消防站，作为i节点的负责站时，i为根的子树都拥有负责站的最小权值，用ans[i]表示这些点中的最优情况。 那么只需要一遍DFS，回溯遍历所有的节点，对于所有在d[i]范围内的点j都更新一下dp[i][j]，更新时需要遍历i的所有子节点v，判断是否可以直接将j作为负责站，如果不可以，就需要加上ans[v]。 代码 /** * Author: wzhzzmzzy * Question: POJ - 2152 * Algorithm: 树形 DP **/ #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; using namespace std; //#define LOCAL const int maxn = 1000+7; const int INF = 0x3f3f3f3f; struct Edge { int v, w, next; } edge[maxn&lt;&lt;1]; int head[maxn], tot; int w[maxn], d[maxn], dis[maxn]; // 建站价格 最大距离 某点到所有点的距离 int dp[maxn][maxn], ans[maxn], n; // dp[i][j] -&gt; j 点建站向 i 点负责，且 i 子树所有点已经保全的最小价格 // ans[i] -&gt; i 点及其子树保全的最小价格 void init() { memset(head, -1, sizeof head); tot = 0; } void add_edge(int u, int v, int w) { edge[tot] = (Edge) { v, w, head[u] }; head[u] = tot++; } void dfs_dis(int u) { // 求 u 到所有点的距离 for (int i = head[u]; ~i; i = edge[i].next) { int v = edge[i].v, w = edge[i].w; if (~dis[v]) continue; dis[v] = dis[u] + w; dfs_dis(v); } } void dfs_ans(int u, int fa) { for (int i = head[u]; ~i; i = edge[i].next) { int v = edge[i].v; if (v == fa) continue; dfs_ans(v, u); // 搜索过所有子节点之后才更新父节点 } // init memset(dis, -1, sizeof dis); dis[u] = 0; dfs_dis(u); ans[u] = INF; for (int i = 1; i &lt;= n; ++i) dp[u][i] = INF; // 遍历所有可能的点 for (int i = 1; i &lt;= n; ++i) if (dis[i] &lt;= d[u]) { dp[u][i] = w[i]; // 遍历子树 for (int j = head[u]; ~j; j = edge[j].next) { int v = edge[j].v; if (v == fa) continue; dp[u][i] += min(ans[v], dp[v][i]-w[i]); } ans[u] = min(ans[u], dp[u][i]); } } int main() { #ifdef LOCAL freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); #endif int t; scanf(&quot;%d&quot;, &amp;t); while (t--) { init(); scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, w+i); for (int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, d+i); for (int i = 1; i &lt; n; ++i) { int u, v, w; scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w); add_edge(u, v, w); add_edge(v, u, w); } dfs_ans(1, -1); printf(&quot;%d\\n&quot;, ans[1]); } return 0; } 其他好题 这些题不一定难，但是都是在对于树形DP的扩展，值得一做。 HDU - 3586 - Information Disturbing 题意 一棵关系树，你有一个工具可以切断其中的边。每切断一条边需要消耗等同于边权的生命值，并且边权不能超过你工具的攻击力。需要求出一个最小的攻击力。 思路 仔细想一想，这是一个判定性问题，最小的攻击力上限以上的攻击力都是满足条件的，所以我们可以通过二分来解决。这样的复杂度就是 O(n2logw)O(n^2logw)O(n2logw)，w为最大边权。 对于每一个攻击力，我们只需要回溯更新求在当前攻击力限制下所需要的生命值，如果超出上限，就向右二分，否则向左。 代码 /** * Author: wzhzzmzzy * Question: HDU - 3586 * Algorithm: 树形 DP + 二分 **/ #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;string&gt; #include &lt;algorithm&gt; using namespace std; //#define LOCAL const int maxn = 1000+7; const int INF = 1000000+7; struct Edge { int v, w, next; } edge[maxn]; int head[maxn], tot; int dp[maxn], mx; void init() { memset(head, -1, sizeof head); memset(dp, 0, sizeof dp); tot = mx = 0; } void add_edge(int u, int v, int w) { edge[tot] = (Edge) { v, w, head[u] }; head[u] = tot++; } void dfs(int u, int fa, int lim) { int isLeaf = 1; // 标记叶子节点 for (int i = head[u]; ~i; i = edge[i].next) { int v = edge[i].v, w = edge[i].w; if (v == fa) continue; isLeaf = 0; dfs(v, u, lim); lim &gt;= w ? dp[u] += min(dp[v], w): dp[u] += dp[v]; } if (isLeaf) dp[u] = INF; } int main() { #ifdef LOCAL freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); #endif int n, m; while (~scanf(&quot;%d%d&quot;, &amp;n, &amp;m) &amp;&amp; n+m) { init(); for (int i = 1; i &lt; n; ++i) { int u, v, w; scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w); add_edge(u, v, w); add_edge(v, u, w); mx = max(mx, w); } int l = 1, r = mx, ans = -1; while (l &lt;= r) { int mid = (l+r) &gt;&gt; 1; memset(dp, 0, sizeof dp); dfs(1, -1, mid); if (dp[1] &lt;= m) ans = mid, r = mid-1; else l = mid+1; } printf(&quot;%d\\n&quot;, ans); } } ZOJ - 3201 - Tree of Tree 题意 在树上选出一棵大小为k的子树，要求子树的权值和最大。 思路 树上的01背包，很简单。 代码 /****************************** *File name: zoj3201.cpp *Author: wzhzzmzzy *Created Time: 一 8/ 7 16:07:58 2017 *TODO: 树形DP+01背包 ******************************/ #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; using namespace std; const int maxn = 500+7; struct Edge { int v, next; } edge[maxn&lt;&lt;1]; int head[maxn], tot; int dp[maxn][maxn], n, m; void init() { memset(head, -1, sizeof head); memset(dp, 0, sizeof dp); tot = 0; } void add_edge(int u, int v) { edge[tot] = (Edge) { v, head[u] }; head[u] = tot++; } void dfs(int u, int fa) { for (int i = head[u]; ~i; i = edge[i].next) { int v = edge[i].v; if (v == fa) continue; dfs(v, u); for (int j = m; j &gt; 1; --j) for (int k = 1; k &lt; j; ++k) dp[u][j] = max(dp[u][j], dp[u][j-k]+dp[v][k]); } } int main() { #ifdef LOCAL freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); #endif while (~scanf(&quot;%d%d&quot;, &amp;n, &amp;m)) { init(); for (int i = 0; i &lt; n; ++i) scanf(&quot;%d&quot;, &amp;dp[i][1]); for (int i = 1; i &lt; n; ++i) { int u, v; scanf(&quot;%d%d&quot;, &amp;u, &amp;v); add_edge(u, v); add_edge(v, u); } dfs(0, -1); int ans = 0; for (int i = 0; i &lt; n; ++i) ans = max(ans, dp[i][m]); printf(&quot;%d\\n&quot;, ans); } } ","link":"https://wzhzzmzzy.github.io/post/2017-08-07-树形DP入门"},{"title":"Let's Do It","content":"初心 一直都很茫然 之前的一年里，和很多人说起过未来这个话题。问我将来想做什么的时候，我只有一个回答，写代码。可能他们觉得这就是答案了，可是我也不知道未来我会做什么，我希望未来的我做什么。 仿佛回到了高三那时候。虽然现在很懊悔那时候浪费了多少时光。 下一年，学药的孩子们待在试剂之间和实验室里，外国语的依然早起背单词，商总是捉摸不透的东西，而恺要去美国了。我呢，还是能睡懒觉就睡，学着写一些有意思的代码，做一些希望做到的东西。大学真好啊，没人理会的自由是多美好的东西。于是就会有点茫然，以后我会在哪里。 悠然过去的上一个学年，总是和以前一样，不如人意也没法回头。科协、引航、GPA、ACM、项目。主题也不过就是这几件事，或许大学三年也就这几件事。一直以来的目标都是，想有不错的GPA，刷过两千道题、至少有个银牌水平，在学生会有一席之地，在GitHub有五六千行的工程代码。一切都可以用努力去争取，可是很多时候又静不下心来学、做。蒙混过关很容易，但是还是别蒙骗自己的好。 这些目标里漏了什么？一开始我也没意识到，直到有一天和驱蚊说到，好久没读书写字看电影了。这才想起来，这么浮躁的自己只是在一点点腐朽而已。 之前那一个月，写了半个月的Day One，Things却是闲置了，因为甚少碰手机，所以意义不大。清清淡淡过了生日，收到了三份礼物，算得上是惊喜。移动电源是刚需，万事屋还没有拼，Deemo的原声碟也没有机会听。不过总算还是很开心。 去了一趟上海，说不出，有一些略微的失望。其实并没有什么差别吧，只是一个更大的城市而已。以后想去冒险的话，还是希望能去更不一样的地方，没有那么多人，但是有一些值得向往的东西。 还是要学习 一直想学Git，但是Windows上的Git真心不怎么好用，Git Bash的伪命令行比Ubuntu差太远了。开始捣鼓GitHub Pages才发现了Github Desktop这么个更加完善的GUI工具，还行，比Bash好看多了。 之所以不常用Ubuntu，一是因为Bash的字体被我改得很丑，而且改不回Ubuntu Mono，很气啊，二是因为Ubuntu上的Git命令还并不习惯。而之前为了装Ubuntu还重装了一遍Win，非常麻烦啊，又不想重新装，很纠结。 从简书转向GitHub Pages，主要是因为在简书上很难自定义样式，虽说简洁，但是并不足够。不说图表，简书没有对Html和MathJex的支持，社区环境也不够好，只能作为一个较为私密的空间来使用。陆续写了一些学习记录，但是其实用处不大，只当做自己的云端资料库，需要时查看一下。 顺道在廖雪峰老师的博客上学了一些JavaScript，这门语言真是__“博大精深”__，不花点时间学不会。 希望 继续写 之前在简书上写过不少东西，但是很多都并没有太深刻的理解。比如Android，比如JavaScript。说起来Android要开始用kotlin了，而我甚至没有入门Java。至于iOS开发，其实也是有心无力。毕竟那台2012年的mba已经快要到头了，而我也没有太好的去开发这些东西的想法。 除此以外的就是一些ACM Note：刷题记录、比赛题解、算法模板等等。算法方面还有很大块的空白要填补。 仔细想想，没必要在简书和GitHub发一样的文章，这样的话，以后简书就会更少地发一些代码，更多地写一些生活。 如果我是星星，就不必害怕黑暗。如果我自己是那么美好，那么一些恐惧就可以烟消云散。 即使我总会遇到无能为力的事，我也希望能让自己变得更好一些。 ","link":"https://wzhzzmzzy.github.io/post/2017-08-04-Let-s-Do-It"},{"title":"博弈论学习","content":"学习资料 总结 巴什博奕 威佐夫博弈 尼姆博弈 博弈问题与SG值 巴什博奕（Bash Game） 博弈原题 最简单的巴什博奕题大概就是抢三十了，两个人分别报数，每人一次可以报1~4个数，先报数到30的人赢。 这个游戏是典型的后手必胜游戏。首先，当一个人报数到了25，那么他必然会赢，因为不论下一个人报数多少，他都能凑足30。既然25 -&gt; 30是这样，那么20 -&gt; 25也是这样，凡是报数到20的人下一回合都能报数到25。以此类推，我们发现，后手必然能够报数到5，然后是10，15，20，25。 这样就得到了是后手必胜。 博弈原理 我们分析一下其中的原理，为什么是5？因为 5=4+15=4+15=4+1 。那么我们就得到了巴什博奕完善的表达形式： 有一堆n个石子，两人在自己的回合可以任意取1~m个石子，先取完者胜。那么如果 n=k×(m+1)n=k\\times(m+1)n=k×(m+1) ，后手必胜，否则先手必胜。 威佐夫博弈（Wythoff Game） 博弈原理 有两堆石子，两人可以在自己的回合取某一堆中任意数量的石子，也可以同时从两堆中任意取相同数量的石子，先取完者胜。 推导过程看不懂。但大体过程是这样的： 用(a, b)表示两堆石子数目，第一必败态毋庸置疑是(0, 0)；第二必败态是(1, 2)，因为先手无论如何取，后手下一步都能取完所有石子。 然后是第三必败态(3, 5)，因为无论先手如何取，后手都能走到下一个必胜态。以此类推可以得到： 序号 必败态 0 (a, b) 1 (0, 0) 2 (1, 2) 3 (3, 5) 4 (4, 7) 5 (6, 10) 6 (8, 13) 7 (9, 15) 8 (11, 18) 观察样例，很难得出结论，但是样例数很多之后我们发现了其中的规律： a=5+12×(b−a)a = \\frac{\\sqrt{5}+1}{2}\\times (b-a) a=25​+1​×(b−a) 博弈应用 判断先\\后手输赢 很好解决，直接判断a，b就可以了。 求先手输赢，输出第一次取法 先考虑两堆同时取，这样差值是不变的。如果只能取一堆，那么枚举差值即可。 尼姆博奕（Nimm Game） 博弈原题 有三堆石子，两人可以在自己的回合取某一堆中任意数量的石子，先取完者胜。 我们依然用(a, b, c)表示当前状态。首先我们知道(0, 0, 0)是必败态。第二种必败态是(0, n, n)，这种状态，无论先手那多少，后手都可以从另一堆中拿同样数量。 然后直接给出规律吧……完全看不出来的。 必败态的充要条件是a ^ b ^ c = 0。 博弈推广 现在有n堆石子，其他规则不变。这样的博弈依然服从尼姆博弈的规律。 我们把满足所有值的异或值是0的状态称为平衡状态，平衡状态为必败态。并且平衡状态只能转化为非平衡状态，非平衡状态可以转化为平衡状态。 那么我们把博弈规则改一改，改为先取完者负。 这样初看很复杂，但是实际依然存在规律。首先依然按照尼姆博弈的规律取，直到有某一堆物品数量大于1，其他堆全部为1的状态，将这堆取空或者取为1，使数量为1的堆的数目变为奇数即可。因为操作需要满足平衡状态，所以不会面对这种情况，这样就可以判断胜负了。 例题（HDU 1850） 思路 求尼姆博弈先手是否能胜，如果能，第一步有几种走法。 思路很简单，只要看当前是否是非平衡状态，下一步哪个堆可以转化为平衡状态即可。 代码 #include &lt;bits/stdc++.h&gt; using namespace std; int main(){ int n, num[100+7]; while (scanf(&quot;%d&quot;, &amp;n), n) { int sum = 0, cnt = 0; for (int i = 0; i &lt; n; ++i) { scanf(&quot;%d&quot;, num+i); sum ^= num[i]; } for (int i = 0; i &lt; n; ++i) if (num[i] &gt; (sum^num[i])) ++cnt; printf(&quot;%d\\n&quot;, cnt); } return 0; } 反尼姆博奕例题（HDU 1905） 思路 与正常的尼姆博弈几乎相同，只是要特判奇数个1和偶数个1的情况。 代码 #include &lt;bits/stdc++.h&gt; using namespace std; int n, num[50]; void solve() { int sum = 0, odd = 0, even = 0; scanf(&quot;%d&quot;, &amp;n); for (int i = 0; i &lt; n; ++i) { scanf(&quot;%d&quot;, num+i); sum ^= num[i]; num[i] &lt; 2 ? ++odd : ++even; } if ((sum &amp;&amp; even) || (!sum &amp;&amp; !even)) puts(&quot;John&quot;); else puts(&quot;Brother&quot;); } int main(){ int t; scanf(&quot;%d&quot;, &amp;t); while (t--) solve(); return 0; } ","link":"https://wzhzzmzzy.github.io/post/2017-07-29-博弈论专题整理"},{"title":"AC自动机模板整理及入门例题","content":"参考资料 字典树（讲解+模版） AC自动机算法 AC自动机算法详解 hdu 2222 ac自动机入门题 HDU 2222 Keywords Search 题意 给出一些模式串和一个主串，求主串中能匹配到的模式串数量。 思路 AC自动机裸题。 代码 #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;malloc.h&gt; #include &lt;queue&gt; using namespace std; struct node { int count; struct node *next[26]; struct node *fail; void init() { for(int i=0; i &lt; 26; ++i) next[i] = NULL; count = 0; fail = NULL; } } *root; void insert(char str[]) { node *p = root; int len = strlen(str); for(int k=0; k &lt; len; ++k) { int pos = str[k]-'a'; if(p-&gt;next[pos] == NULL) { p-&gt;next[pos] = new node; p-&gt;next[pos]-&gt;init(); p = p-&gt;next[pos]; } else p = p-&gt;next[pos]; } p-&gt;count++; } void getfail() { node *p = root, *son, *temp; queue&lt;node*&gt; que; que.push(p); while(!que.empty()){ temp = que.front(); que.pop(); for(int i=0; i &lt; 26; ++i){ son = temp-&gt;next[i]; if(son != NULL){ if(temp == root) son-&gt;fail = root; else{ p = temp-&gt;fail; while(p){ if(p-&gt;next[i]){ son-&gt;fail=p-&gt;next[i]; break; } p = p-&gt;fail; } if(!p) son-&gt;fail = root; } que.push(son); } } } } void query(char str[]) { int len = strlen(str), cnt=0; node *p,*temp; p = root; for (int i=0; i &lt; len; ++i) { int pos = str[i]-'a'; while(!p-&gt;next[pos] &amp;&amp; p!=root) p = p-&gt;fail; p = p-&gt;next[pos]; if(!p) p = root; temp = p; while (temp != root) { if(temp-&gt;count &gt;= 0) { cnt += temp-&gt;count; temp-&gt;count = -1; } else break; temp = temp-&gt;fail; } } printf(&quot;%d\\n&quot;, cnt); } char str[1000000+100]; int main() { int cas,n; scanf(&quot;%d&quot;,&amp;cas); while(cas--) { root=new node; root-&gt;init(); root-&gt;fail = NULL; scanf(&quot;%d&quot;,&amp;n); int i; for(i=0;i&lt;n;i++) { scanf(&quot;%s&quot;, str); insert(str); } getfail(); scanf(&quot;%s&quot;, str); query(str); } return 0; } HDU 2896 病毒侵袭 题意 给出一些模式串，再给出一些主串，求每个主串中能匹配到的模式串的编号，以及能匹配到模式串的主串数量。 思路 本来是想用上面 HDU 2222 的模板改的，发现会MLE，就重新找了一个模板。 这个模板是开一个node数组，通过next和fail都通过下标来指示位置， 数据量一定时节省空间但是不能根据数据量自动拓展。 代码 #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;cmath&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;queue&gt; using namespace std; const int kind = 128; const int s_maxn = 200+7; const int t_maxn = 10000+7; const int maxn = 500+7; struct node { int fail, flag, next[kind]; void init() { for(int i=0; i &lt; kind; ++i) next[i] = 0; fail = -1, flag = 0; } } tb[100007]; int web_cnt, n, m, cur; char s[s_maxn], t[t_maxn]; void insert(const char str[], int id) { int temp = 0; for(int k=0; str[k]; ++k) { int pos = str[k]; if(tb[temp].next[pos] == 0) { tb[++cur].init(); tb[temp].next[pos] = cur; } temp = tb[temp].next[pos]; } tb[temp].flag = id; } void getfail() { int p, son; queue&lt;int&gt; que; que.push(0); while(!que.empty()){ int temp = que.front(); que.pop(); for(int i=0; i &lt; kind; ++i){ son = tb[temp].next[i]; if (!son) continue; p = tb[temp].fail; while (~p &amp;&amp; !tb[p].next[i]) p = tb[p].fail; if (!~p) tb[son].fail = 0; else tb[son].fail = tb[p].next[i]; que.push(son); } } } void query(char str[], int id) { int ans[maxn] = {}, cnt = 0; int p = 0, temp; for (int i=0; str[i]; ++i) { int pos = str[i]; if (tb[p].next[pos]) p = tb[p].next[pos]; else { temp = tb[p].fail; while (~temp &amp;&amp; !tb[temp].next[pos]) temp = tb[temp].fail; if (p == -1) p = 0; else p = tb[temp].next[pos]; } if(tb[p].flag) { ans[tb[p].flag] = 1; ++cnt; temp = tb[p].fail; while (temp &amp;&amp; !ans[tb[temp].flag]) { ans[tb[temp].flag] = 1; temp = tb[temp].fail; ++cnt; } } } if (cnt == 0) return; ++web_cnt; printf(&quot;web %d:&quot;, id); for (int i = 1; i &lt;= n; ++i) if (ans[i]) printf(&quot; %d&quot;, i); puts(&quot;&quot;); } void solve() { web_cnt = cur = 0; tb[0].init(); for (int i = 1; i &lt;= n; ++i) { scanf(&quot;%s&quot;, s); insert(s, i); } getfail(); int m; scanf(&quot;%d&quot;, &amp;m); for (int i = 1; i &lt;= m; ++i) { scanf(&quot;%s&quot;, t); query(t, i); } printf(&quot;total: %d\\n&quot;, web_cnt); } int main(){ #ifdef LOCAL freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); #endif while (~scanf(&quot;%d&quot;, &amp;n)) solve(); return 0; } ","link":"https://wzhzzmzzy.github.io/post/2017-07-03-AC-Automachion"},{"title":"字符串小算法总结","content":" kuangbin专题十六——KMP KMP 学习总结 朴素 KMP 算法 void getNext(const char s[]){ int cur = 0, k = -1; nxt[cur] = k; while (cur &lt; m) { if (k == -1 || s[cur] == s[k]) nxt[++cur] = ++k; else k = nxt[k]; } } int kmp(const char a[], const char b[]){ int i = 0, j = 0; while (i &lt; n) { if (j == -1 || a[i] == b[j]) ++i, ++j; else j = nxt[j]; if (j == m) return i; } return -1; } 拓展 KMP 算法（Extend-KMP） void getNext(const char T[]){ int len=strlen(T), a=0; nxt[0] = len; while(a&lt;len-1 &amp;&amp; T[a]==T[a+1]) ++a; nxt[1] = a, a = 1；// a-&gt;适配最远位置的起始点 for(int k=2; k&lt;len; ++k){ int p = a+nxt[a]-1; // p-&gt;之前适配可达到的最远处 int L = nxt[k-a]; // L-&gt;a到k这一段的适配长度 if(k-1+L &gt;= p){ // 如果超过了 p 适配到的位置 int j = (p-k+1)&gt;0?(p-k+1):0; // s[k,p]的长度 while(k+j&lt;len &amp;&amp; T[k+j]==T[j]) ++j; // 向后匹配 nxt[k] = j, a = k; } else nxt[k]=L; // 没有超过就直接用 } } void getExtend(const char S[],const char T[]){ getNext(T); int slen = strlen(S), tlen = strlen(T), a = 0; int minLen = min(slen, tlen); while(a&lt;minLen &amp;&amp; S[a]==T[a]) ++a; extend[0] = a; a=0; for(int k=1; k&lt;slen; ++k){ int p = a+extend[a]-1, L = nxt[k-a]; if(k-1+L &gt;= p){ int j = max(p-k+1, 0); while(k+j&lt;slen &amp;&amp; j&lt;tlen &amp;&amp; S[k+j]==T[j]) ++j; extend[k] = j; a=k; } else extend[k] = L; } } 最大最小表示法 int getMinOrMax(char str[], bool flag) { // true -&gt; Max \\ false -&gt; Min int p1 = 0, p2 = 1, k = 0; while (p1&lt;len &amp;&amp; p2&lt;len &amp;&amp; k&lt;len) { int cur = str[(p1+k)%len] - str[(p2+k)%len]; if (cur &gt; 0) flag ? p2+=k+1 : p1+=k+1; if (cur &lt; 0) flag ? p1+=k+1 : p2+=k+1; if (p1 == p2) ++p2; !cur ? ++k : k=0; } return min(p1, p2); } 最长回文子串（Manacher） void init(char str[], int len) { for (int i = len; i &gt;= 0; --i) { str[(i&lt;&lt;1)+2] = str[i]; str[(i&lt;&lt;1)+1] = '#'; } str[0] = '@'; } int manacher(char str[]) { int len = strlen(str), id = 0, maxi = 0; int p[maxn&lt;&lt;1] = {}; init(str, len); for (int i = 2; i &lt; (len&lt;&lt;1)+1; ++i) { p[i] = (p[id]+id &gt; i? min(p[(id&lt;&lt;1)-i], p[id]+id-i) : 1); while (str[i-p[i]] == str[i+p[i]]) ++p[i]; // 向外延伸 if (id+p[id] &lt; i+p[i]) id = i; // 更新 id maxi = max(maxi, p[i]); } return maxi-1; // 最长回文子串长度 } 学习资料 深入讲解next数组的求解 扩展KMP算法 最大最小表示法 HDU3068+Manacher HDU 1711 Number Sequence 题意 给出t组样例和两串数列，在a串中求出b串所在位置。 思路 KMP裸题，根据b串求出匹配序列next之后依次匹配即可。 代码 #include &lt;cstdio&gt; using namespace std; #define LOCAL const int maxn = 1e6+7; int a[maxn], b[maxn], next[maxn], n, m; void getNext(){ int cur = 0, k = -1; next[cur] = k; while (cur &lt; m) { if (k == -1 || b[cur] == b[k]) next[++cur] = ++k; else k = next[k]; } } int kmp(){ int i = 0, j = 0; while (i &lt; n) { if (j == -1 || a[i] == b[j]) ++i, ++j; else j = next[j]; if (j == m) return i; } return -1; } int main(){ #ifdef LOCAL freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); #endif int t; scanf(&quot;%d&quot;, &amp;t); while (t--) { scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for (int i = 0; i &lt; n; ++i) scanf(&quot;%d&quot;, a+i); for (int i = 0; i &lt; m; ++i) scanf(&quot;%d&quot;, b+i); getNext(); if (kmp()==-1) printf(&quot;-1\\n&quot;); else printf(&quot;%d\\n&quot;, kmp()-m+1); } return 0; } HDU 1686 Oulipo 题意 给出t组样例，每组样例有两个字符串。要求在b串中能找到多少个a串，每个a串有可能重叠。 思路 简单KMP。由于对KMP理解不深，在匹配的时候选择了回到开始位置，这样会导致重复匹配，可以回到结尾位置对应的前缀位置，这样可以提高效率。 代码 #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;cmath&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; //#define LOCAL int cas, nxt[10005], m, n; char s[10005]; char t[1000007]; void getNext() { int cur = 0, k = -1; nxt[0] = -1; while(cur &lt; m) { if (k == -1 || s[cur] == s[k]) nxt[++cur] = ++k; else k = nxt[k]; } } int kmp() { int i = 0, j = 0, ans = 0; while (i &lt; n) { if (j == -1 || t[i] == s[j]) ++i, ++j; else j = nxt[j]; if (j == m) { ++ans; j = nxt[j]; } } return ans; } int main(){ #ifdef LOCAL freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); #endif scanf(&quot;%d&quot;, &amp;cas); while (cas--) { scanf(&quot;%s%s&quot;, s, t); m = strlen(s), n = strlen(t); getNext(); printf(&quot;%d\\n&quot;, kmp()); } return 0; } HDU 2087 题意 有多组样例，读入到#时终止。 每组样例有两个字符串，求能在a串中找到多少个b串。 思路 KMP匹配即可，匹配完成之后小串指针归零。 代码 #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;cmath&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; #define LOCAL char a[1005], b[1005]; int m, n, nxt[1005]; void getNext(){ int cur = 0, k = -1; nxt[0] = -1; while (cur &lt; m) { if (k == -1 || b[cur] == b[k]) nxt[++cur] = ++k; else k = nxt[k]; } } int kmp(){ int i = 0, j = 0, cnt = 0; while (i &lt; n) { if (j == -1 || a[i] == b[j]){ ++i, ++j; } else j = nxt[j]; if (j == m) ++cnt, j = 0; } return cnt; } int main(){ #ifdef LOCAL freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); #endif while (~scanf(&quot;%s&quot;, a) &amp;&amp; a[0] != '#') { scanf(&quot;%s&quot;, b); n = strlen(a), m = strlen(b); getNext(); printf(&quot;%d\\n&quot;, kmp()); } return 0; } HDU 3746 Cyclic Nacklace 题意 有t组样例。每组样例给出一个字符串，要求要在两端补上多少个字符才能让其变为多个完全相同的字符串合并成的字符串。 思路 KMP。根据题意发现，两端添加字符其实和一端是一样的。 那么我们只要根据匹配序列，获得字符串尾端的最长公共前后缀长度nxt[len]，这样可以求出最短的子序列长度为xlen = len-nxt[len]。 如果len%xlen==0那么这个字符串本身就已经是多个相同的字符串组合而成的了。 否则的话，需要增添的字符数量就是xlen-nxt[len]%xlen。 代码 #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;cmath&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; #define LOCAL char s[100007]; int m, n, nxt[100007]; void getNext(){ int cur = 0, k = -1; nxt[0] = -1; while (cur &lt; m) { if (k == -1 || s[cur] == s[k]) nxt[++cur] = ++k; else k = nxt[k]; } } int main(){ #ifdef LOCAL freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); #endif int t; scanf(&quot;%d&quot;, &amp;t); while (t--) { scanf(&quot;%s&quot;, s); m = strlen(s); getNext(); n = m - nxt[m]; if (n != m &amp;&amp; !(m%n)) printf(&quot;0\\n&quot;); else printf(&quot;%d\\n&quot;, n - nxt[m]%n); } return 0; } HDU 1358 题意 有多组样例，读到0时结束。每组样例是一个字符串，要求字符串的每个长度大于二的子串是否是一个由不少于一个相同的字符串连接成的串。 思路 一开始想了很久，后来才知道这居然是一个性质：i%(i-next[i])==0，那么这个长度为i的串就是一个重复串，并且循环节长度为i-next[i]。 代码 #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;cmath&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; #define LOCAL int nxt[1000007], n; char s[1000007]; void getNext() { int cur = 0, k = -1; nxt[0] = -1; while (cur &lt; n) { if (k == -1 || s[cur] == s[k]){ nxt[++cur] = ++k; } else k = nxt[k]; } } int main(){ #ifdef LOCAL freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); #endif int cas = 0; while (scanf(&quot;%d&quot;, &amp;n), n) { scanf(&quot;%s&quot;, s); getNext(); printf(&quot;Test case #%d\\n&quot;, ++cas); for (int i = 2; i &lt;= n; ++i){ if (i%(i-nxt[i]) == 0 &amp;&amp; nxt[i]) printf(&quot;%d %d\\n&quot;, i, i/(i-nxt[i])); } printf(&quot;\\n&quot;); } return 0; } POJ 3080 Blue Jeans 题意 给出多个长度为60的字符串，求出字典序最大的最长公共子串。 思路 因为数据范围不大，所以暴力枚举第一个串的所有子串，然后KMP匹配即可。 代码 #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;cmath&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; #define LOCAL char s[12][67], ans[67], now[67]; int nxt[67], len, len_ans, flag; void getNext(const char s[]) { int cur = 0, k = -1; nxt[0] = -1; while (s[cur]) { if (k == -1 || s[cur] == s[k]) nxt[++cur] = ++k; else k = nxt[k]; } } int kmp(const char s[]) { int i = 0, j = 0; while (s[i]) { if (j == -1 || s[i] == now[j]) ++i, ++j; else j = nxt[j]; if (j == len) return 1; } return 0; } bool check() { //printf(&quot;_%s %s\\n&quot;, ans, now); if (len &gt; len_ans) return true; int cur = -1; return strcmp(ans, now) &gt; 0; } int main(){ #ifdef LOCAL freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); #endif int t; scanf(&quot;%d&quot;, &amp;t); while (t--) { int m; scanf(&quot;%d&quot;, &amp;m); for (int i = 0; i &lt; m; ++i) scanf(&quot;%s&quot;, s[i]); for (len = 1, len_ans = 0; len &lt;= 60; ++len) { for (int cur = 0, flag = 1; cur &lt;= 60-len; ++cur, flag = 1) { for (int i = 0; i &lt; len; ++i) now[i] = s[0][cur+i]; now[len] = '\\0'; getNext(now); for (int i = 1; i &lt; m; ++i) if (!kmp(s[i])) { flag = 0; break; } if (flag &amp;&amp; check()){ strcpy(ans, now); len_ans = len; } } } if (len_ans &lt; 3) printf(&quot;%s\\n&quot;, &quot;no significant commonalities&quot;); else printf(&quot;%s\\n&quot;, ans); } return 0; } HDU 3336 Count the string 题意 给出一个字符串，求这个字符串的每个前缀在字符串中出现的次数总和。 思路 KMP。依然是考对next数组的理解程度。 next数组表示当前位置的最大公共前后缀长度，那么这个最大的公共前后缀长度中包含的就是前缀中的每个小前缀的数量。也就是说，next数组在这道题目中就可以用来表示当前位置的后缀中出现了的重复前缀数量，可以直接加入计数器当中。 代码 #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;cmath&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; const int mod = 10007; int n, nxt[200007]; char s[200007]; void getNext() { int cur = 0, k = -1; nxt[0] = -1; while (s[cur]) { if (k == -1 || s[cur] == s[k]) nxt[++cur] = ++k; else k = nxt[k]; } } int main(){ #ifdef LOCAL freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); #endif int t; scanf(&quot;%d&quot;, &amp;t); while (t--) { scanf(&quot;%d%s&quot;, &amp;n, s); getNext(); int ans = (nxt[n] + n)%mod; for (int i = 0; i &lt; n; ++i) if (nxt[i] &amp;&amp; nxt[i+1] != nxt[i]+1) ans += nxt[i]; printf(&quot;%d\\n&quot;, ans%mod); } return 0; } HDU 4300 Clairewd’s message 题意 给出若干样例，每个样例有两个字符串。第一个字符串是26个英文字母对应的密码表，第二个字符串是密文和明文连接成的，其中的明文可能不全，可能没有。求补完明文串。 思路 数据较弱，可以暴力。 用朴素KMP完成，将字符串的前一半翻译为明文，后一半不变，然后生成next数组，看最后一位的大小就知道密文的长度。 用拓展KMP完成，将字符串整个翻译为明文，原串为模式串，新串为主串，生成extend，遍历extend找第一个完全匹配的点（这个点后面的字符都能和主串的前缀匹配），就知道密文的长度了。 代码 \\\\ 朴素KMP #include &lt;cstdio&gt; using namespace std; char a[27]; char s1[100007]; char s2[100007]; int nxt[100007]; void getNext(char s[]) { int cur = 0, k = -1; nxt[0] = -1; while (s[cur]) { if (k == -1 || s[cur] == s[k]) nxt[++cur] = ++k; else k = nxt[k]; } } int main(){ int t; scanf(&quot;%d&quot;, &amp;t); while (t--) { scanf(&quot;%s%s&quot;, a+1, s1); char b[27]; for (int i = 1; i &lt;= 26; ++i) b[a[i]-'a'] = i+'a'-1; int len = strlen(s1); int k = len; for (int i = 0; i &lt; (len+1)&gt;&gt;1; ++i) s2[i] = b[s1[i]-'a']; for (int i = (len+1)&gt;&gt;1; i &lt;= len; ++i) s2[i] = s1[i]; getNext(s2); while (nxt[k] &gt; len&gt;&gt;1) k = nxt[k]; printf(s1); for (int i = nxt[k]; i &lt; len-nxt[k]; ++i) printf(&quot;%c&quot;, b[s1[i]-'a']); printf(&quot;\\n&quot;); } return 0; } \\\\ 拓展KMP #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; using namespace std; const int maxn = 100000+7; char s1[maxn], s2[maxn]; int nxt[maxn], extend[maxn]; void getNext(const char T[]){ int len=strlen(T), a=0; nxt[0] = len; while(a&lt;len-1 &amp;&amp; T[a]==T[a+1]) ++a; nxt[1] = a; a=1; for(int k=2; k&lt;len; ++k){ int p=a+nxt[a]-1, L=nxt[k-a]; if(k-1+L &gt;= p){ int j = (p-k+1)&gt;0?(p-k+1):0; while(k+j&lt;len &amp;&amp; T[k+j]==T[j]) ++j; nxt[k] = j; a=k; } else nxt[k]=L; } } void getExtend(const char S[],const char T[]){ getNext(T); int slen = strlen(S), tlen = strlen(T), a = 0; int minLen = min(slen, tlen); while(a&lt;minLen &amp;&amp; S[a]==T[a]) ++a; extend[0] = a; a=0; for(int k=1; k&lt;slen; ++k){ int p = a+extend[a]-1, L = nxt[k-a]; if(k-1+L &gt;= p){ int j = max(p-k+1, 0); while(k+j&lt;slen &amp;&amp; j&lt;tlen &amp;&amp; S[k+j]==T[j]) ++j; extend[k] = j; a=k; } else extend[k] = L; } } int main(){ int t; scanf(&quot;%d&quot;, &amp;t); while (t--) { char table[30], b[200]; scanf(&quot;%s%s&quot;, table, s1); for (int i = 0; table[i]; ++i) b[table[i]] = i+'a'; for (int i = 0; s1[i]; ++i) s2[i] = b[s1[i]]; getExtend(s1, s2); int n = strlen(s1), cur = n; for (int i = 0; s1[i]; ++i) if (i+extend[i] &gt;= n &amp;&amp; i &gt;= extend[i]) { cur = i; break; } char ans[maxn*2]; for (int i = 0; i &lt; cur; ++i){ ans[i] = s1[i]; ans[cur+i] = s2[i]; } ans[cur*2] = '\\0'; printf(&quot;%s\\n&quot;, ans); } return 0; } HDU 2328 Corporate Identity 题意 找多个字符串的公共子串。 思路 暴力枚举+KMP，没什么好说的。 代码 #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;cmath&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; int nxt[203], len, len_ans; char s[4003][203], now[203], ans[203]; void getNext(const char s[]) { int cur = 0, k = -1; nxt[0] = -1; while (s[cur]) { if (k == -1 || s[cur] == s[k]) nxt[++cur] = ++k; else k = nxt[k]; } } int kmp(const char s[]) { int i = 0, j = 0; while (s[i]) { if (j == -1 || s[i] == now[j]) ++i, ++j; else j = nxt[j]; if (j == len) return 1; } return 0; } bool check() { if (len &gt; len_ans) return true; return strcmp(ans, now) &gt; 0; } int main(){ int n; while (scanf(&quot;%d&quot;, &amp;n), n) { for (int i = 0; i &lt; n; ++i) scanf(&quot;%s&quot;, s[i]); int mi = strlen(s[0]); for (len = 1, len_ans = 0; len &lt;= mi; ++len) { for (int i = 0, flag = 1; i &lt;= mi-len; ++i, flag = 1) { for (int j = 0; j &lt; len; ++j) now[j] = s[0][i+j]; now[len] = '\\0'; getNext(now); for (int j = 1; j &lt; n; ++j) if (!kmp(s[j])) { flag = 0; break; } if (flag &amp;&amp; check()) { strcpy(ans, now); len_ans = len; } } } if (len_ans == 0) printf(&quot;IDENTITY LOST\\n&quot;); else printf(&quot;%s\\n&quot;, ans); } return 0; } HDU 3374 String Problem 题意 求一个串每一位依次向前滚动一位，生成的每一个串中字典序最大和最小的字符串。并输出个数。 思路 KMP+字符串最大最小表示法。 最大最小表示法确实是第一次接触。就是通过不断滚动字符串，得到字符串中字典序最大的一串。 最小表示法：取两个指针p=0和q=1，以及一个辅助变量k，从头开始遍历字符串， 如果str[p+k]==str[q+k]，则++k， 如果str[p+k]&lt;str[q+k]，则q+=k+1,k=0， 如果str[p+k]&gt;str[q+k]，则p+=k+1,k=0。 如果p==q，则++q。 代码 #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;cmath&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; const int maxn = 1000000+7; int nxt[maxn]; char s[maxn]; int getMinOrMax(char str[], bool flag) { // true -&gt; Max \\ false -&gt; Min int p1 = 0, p2 = 1; int k = 0, len = strlen(str); while (p1&lt;len &amp;&amp; p2&lt;len &amp;&amp; k&lt;len) { int cur = str[(p1+k)%len] - str[(p2+k)%len]; if (cur &gt; 0) flag ? p2+=k+1 : p1+=k+1; if (cur &lt; 0) flag ? p1+=k+1 : p2+=k+1; if (p1 == p2) ++p2; !cur ? ++k : k=0; } return min(p1, p2); } void getNext(const char str[]){ int cur = 0, k = -1; nxt[cur] = k; while (str[cur]) { if (k == -1 || str[cur] == str[k]) nxt[++cur] = ++k; else k = nxt[k]; } } int main(){ while (~scanf(&quot;%s&quot;, s)) { getNext(s); int len = strlen(s), xlen = len-nxt[len], times = 1; if (!(len%xlen)) times = len/xlen; int mi = getMinOrMax(s, 0); int ma = getMinOrMax(s, 1); printf(&quot;%d %d %d %d\\n&quot;, mi+1, times, ma+1, times); } return 0; } HDU 2609 题意 给出一列01串，求有多少滚动后依然不同的串。 思路 滚动后相同的串的最小表示是相同的，所以用最小表示法可以过。 一开始用了三次strcpy，结果TLE了，发现人家用set和memcpy就可以稳过，还是没学过C的问题。 代码 #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;cmath&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;set&gt; using namespace std; const int maxn = 100+7; set&lt;string&gt; ans; char s[maxn*2]; int len; int getMinOrMax(char str[], bool flag) { // true -&gt; Max \\ false -&gt; Min int p1 = 0, p2 = 1, k = 0; while (p1&lt;len &amp;&amp; p2&lt;len &amp;&amp; k&lt;len) { int cur = str[(p1+k)%len] - str[(p2+k)%len]; if (cur &gt; 0) flag ? p2+=k+1 : p1+=k+1; if (cur &lt; 0) flag ? p1+=k+1 : p2+=k+1; if (p1 == p2) ++p2; !cur ? ++k : k=0; } return min(p1, p2); } void getMinString(char *str){ str[len/2] = '\\0'; ans.insert(str); } int main(){ int n; while (~scanf(&quot;%d&quot;, &amp;n)) { ans.clear(); for (int i = 0; i &lt; n; ++i) { scanf(&quot;%s&quot;, s); char temp[maxn*2]; memcpy(temp, s, sizeof s); strcat(s, temp); len = strlen(s); int k = getMinOrMax(s, 0); getMinString(s+k); } printf(&quot;%d\\n&quot;, ans.size()); } return 0; } FZU 1901 题意 求公共前后缀的长度p。 思路 用next数组，从最后一位递归遍历至首，输出。 代码 #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;cmath&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;vector&gt; using namespace std; const int maxn = 1000000+7; int nxt[maxn]; void getNext(const char s[]){ int cur = 0, k = -1; nxt[cur] = k; while (s[cur]) { if (k == -1 || s[cur] == s[k]) nxt[++cur] = ++k; else k = nxt[k]; } } int main(){ int n, cas = 0; scanf(&quot;%d&quot;, &amp;n); while (n--) { char s[maxn]; scanf(&quot;%s&quot;, s); getNext(s); int cnt = 1; int len = strlen(s); for (int i = nxt[len]; i; i = nxt[i]) ++cnt; printf(&quot;Case #%d: %d\\n&quot;, ++cas, cnt); for (int i = nxt[len]; i; i = nxt[i]) printf(&quot;%d &quot;, len-i); printf(&quot;%d\\n&quot;, strlen(s)); } return 0; } HDU - 3068 题意 求一个字符串的最大回文子串的长度。 思路 Manacher的入门模板题。 设p[i]为i位置的回文串半径。那么从前往后遍历字符串，求出p[0...len]即可。 首先，因为我们是以每个字符为中点向两侧延伸来计算回文串，所以无法判别aa这样的串，这需要对原串进行一次扩展。扩展方式就是，在字符串的每一个字符之间，和首尾，添加一个字符串中没有出现的字符，比如#，然后再给字符串首加上另一个，比如@。 然后就是计算p[i]了。如何提高效率？用id来记录 可以延伸到最远处的回文串中点，如果当前遍历到j&gt;id+p[id]，那么直接向外延伸。但是如果j&lt;=id+p[id]，就可以直接更新p[j]=min(p[id*2-j],p[id]+id-j)。 这里我们来分析一下p[j]=min(p[id*2-j],p[id]+id-j)这个式子。 p[id*2-j]表示什么？表示j关于id对称的点。id*2-j的半径如果超出了p[id]-id的范围，那么p[j]=p[id]+id-j，id范围外不可能还有回文串；如果p[id*2-j]&gt;p[id]-id，那么p[j]=p[id*2-j]，id*2-j范围外也不会有回文串。如果两者相等，就继续向外延伸。 代码 #include &lt;bits/stdc++.h&gt; using namespace std; const int maxn = 110000+7; void init(char str[], int len) { for (int i = len; i &gt;= 0; --i) { str[(i&lt;&lt;1)+2] = str[i]; str[(i&lt;&lt;1)+1] = '#'; } str[0] = '@'; } int manacher(char str[]) { int len = strlen(str), id = 0, maxi = 0; int p[maxn&lt;&lt;1] = {}; init(str, len); for (int i = 2; i &lt; (len&lt;&lt;1)+1; ++i) { p[i] = (p[id]+id &gt; i? min(p[(id&lt;&lt;1)-i], p[id]+id-i) : 1); while (str[i-p[i]] == str[i+p[i]]) ++p[i]; // 向外延伸 if (id+p[id] &lt; i+p[i]) id = i; // 更新 id maxi = max(maxi, p[i]); } return maxi-1; // 最长回文子串长度 } int main(){ #ifdef LOCAL freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); #endif char s[maxn&lt;&lt;1]; while (~scanf(&quot;%s&quot;, s)) printf(&quot;%d\\n&quot;, manacher(s)); return 0; } ","link":"https://wzhzzmzzy.github.io/post/2017-07-03-KMP-zhuan-ti-zheng-li"},{"title":"最短路算法模板整理及题集","content":"模板 Dijkstra 模板一（map 数组模拟邻接表） 处理小图速度相对较快。 内存占用较小，对重边优化较差。 #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cmath&gt; #include&lt;cstring&gt; using namespace std; const int INF = 0x3f3f3f3f; const int maxn = 1000; int map[maxn][maxn]; int pre[maxn],dis[maxn]; bool vis[maxn]; int n,m; void Dijkstra(int s) { memset(dis,0x3f,sizeof(dis)); memset(pre,-1,sizeof(pre)); memset(vis,false,sizeof(vis)); for(int i=1;i&lt;=n;++i) { dis[i]=map[s][i]; pre[i]=s; } dis[s]=0; vis[s]=true; for(int i=2;i&lt;=n;++i) { int mindist=INF; int u=s; for(int j=1;j&lt;=n;++j) if((!vis[j])&amp;&amp;dis[j]&lt;mindist) { u=j; mindist=dis[j]; } vis[u] = true; for(int j=1;j&lt;=n;++j) if((!vis[j]) &amp;&amp; map[u][j] &lt; INF){ if(map[u][j] + dis[u] &lt; dis[j]){ dis[j] = map[u][j] + dis[u]; pre[j] = u; } } } } 模板二（链式前向星+优先队列优化） 主要优化在重边。因为使用了STL所以占用内存和速度相对较慢。 #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cmath&gt; #include&lt;cstring&gt; #include&lt;queue&gt; using namespace std; const int INF=0x3f3f3f3f; struct node { int d,u; friend bool operator&lt;(node a,node b) { return a.d&gt;b.d; } node(int dist,int point):d(dist),u(point){} }; struct Edge { int to,next; int dist; }edge[maxm]; int head[maxn],tot; int pre[maxn],dis[maxn]; void init() { memset(head,-1,sizeof(head)); tot=0; } void addedge(int u,int v,int d) { edge[tot].to=v; edge[tot].dist=d; edge[tot].next=head[u]; head[u]=tot++; } void Dijkstra(int s) { priority_queue&lt;node&gt; q; memset(dis,0x3f,sizeof(dis)); memset(pre,-1,sizeof(pre)); dis[s]=0; while(!q.empty()) q.pop(); node a(0,s); q.push(a); //起点入队列 while(!q.empty()) { node x=q.top(); q.pop(); if(dis[x.u]&lt;x.d) //最短路已找到 continue; for(int i=head[x.u];i!=-1;i=edge[i].next) { int v=edge[i].to; if(dis[v]&gt;dis[x.u]+edge[i].dist) { dis[v]=dis[x.u]+edge[i].dist; pre[v]=x.u; q.push(node(dis[v],v)); } } } } 模板三（结构体内置方法） 因为使用了链式前向星所以不担心重边。 其中还使用了快读方法，所以很快。 #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;queue&gt; #include &lt;algorithm&gt; #include &lt;utility&gt; using namespace std; const int N = 1005; const int M = 1005; const int INF = 0x3f3f3f3f struct Graph{ struct Edge{ int v, w, next; }edge[M]; int ehead[N]; void init(){ memset(ehead, -1, sizeof(ehead)) } inline void addedge(int u, int v, int w){ edge[ecnt] = {v, w, ehead[u]}; ehead[u] = ecnt++; } int dist[N]; bool vis[N]; void Dijkstra(int s){ memset(dist, INF, sizeof(dist)); memset(vis, 0, sizeof(vis)); priority_queue&lt;pair&lt;int, int&gt; &gt; q; q.push(make_pair(-(dist[s] = 0), s)); while(q.size()){ int u = q.top().second; q.pop(); if (vis[u]) continue; vis[u] = true; for (int i = ehead[u]; ~i; i = edge[i].next){ int v = edge[i].v; if (vis[v]) continue; int ndist = dist[u] + edge[i].w; if (ndist &lt; dist[v]) q.push(make_pair(-(dist[v] = ndist), v)); } } } }g1, g2; int Input(){ char c; for (c = getchar(); c&lt;'0' || c&gt;'9'; c = getchar()); int a = c - '0'; for (c = getchar(); c &gt;= '0' &amp;&amp; c &lt;= '9'; c = getchar()) a = a*10 + c - '0'; return a; } Floyd 代码很短，时间复杂度很高（O(n^3)）。 void floyd(){ for(int k=1; k&lt;=n; ++k) for(int i=1; i&lt;=n; ++i) for(int j=1; j&lt;=n; ++j) if (map[i][j] &gt; map[i][k] + map[k][j]) //松弛 map[i][j] = map[i][k] + map[k][j]; } Bellman-Ford 模板一（链式前向星） #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cmath&gt; #include&lt;cstring&gt; using namespace std; struct Edge{ int u, v; double r, c; }edge[maxn*2]; double mostMoney[maxn]; int n, m, s; double v; int tot; void addedge(int u, int v, double r, double c){ edge[tot].u = u; edge[tot].v = v; edge[tot].r = r; edge[tot++].c = c; } bool relax(int n){ double temp = (mostMoney[edge[n].u] - edge[n].c)*edge[n].r; if (temp &gt; mostMoney[edge[n].v]){ mostMoney[edge[n].v] = temp; return true; } return false; } bool bellman_ford(){ bool flag; for (int i=0; i&lt;n; i++) mostMoney[i] = 0.0; mostMoney[s] = v; for (int i=0; i&lt;n-1; ++i){ flag = false; for (int j=0; j&lt;tot; ++j) if (relax(j)) flag = true; if (mostMoney[s] &gt; v) return true; if (!flag) return false; } for (int i=0; i&lt;tot; ++i){ if (relax(i)) return true; } return false; } 模板二 #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cmath&gt; #include&lt;cstring&gt; using namespace std; const int INF=0x3f3f3f3f; struct Edge{ int u,v; //起点、终点 int dist; //长度 }edge[maxn]; int dis[maxn]; //最短距离数组 int n, m; //结点数、边数 bool Bellman_ford(int s){ memset(dis, INF, sizeof(dis)); dis[s]=0; for(int k=1; k&lt;n; ++k){ //迭代n-1次 for(int i=0; i&lt;m; ++i){ //检查每条边 int x = edge[i].u, y = edge[i].v; if(dis[x] &lt; INF) dis[y] = min(dis[y], dis[x] + edge[i].dist); } } bool flag=1; for(int i=0; i&lt;m; ++i){ //判断是否有负环 int x = edge[i].u, y = edge[i].v; if(d[y] &gt; d[x] + edge[i].dist){ flag = 0; break; } } return flag; } SPFA 模板一 #include &lt;cstdio&gt; #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;queue&gt; #define maxn 1000005 using namespace std; const long long INF = 0xffffffff; int Input(){ char c; for (c = getchar(); c&lt;'0' || c&gt;'9'; c = getchar()); int a = c - '0'; for (c = getchar(); c&gt;='0' &amp;&amp; c&lt;='9'; c = getchar()) a = a * 10 + c - '0'; return a; } int n, m; struct edge{ int e, next, w; }edge[2][maxn]; long long dis[maxn], ans; int head[2][maxn], vis[maxn]; inline void spfa(int x){ for (int i=1; i&lt;=n; i++){ dis[i] = 0xffffffff; //cout &lt;&lt; dis[i] &lt;&lt; endl; } memset(vis, 0, sizeof(vis)); queue&lt;int&gt; q; int a, b; q.push(1); vis[1] = 1; dis[1] = 0; while(!q.empty()){ a = q.front(); q.pop(); vis[a] = 1; for (int i=head[x][a]; i != -1; i=edge[x][i].next){ b = edge[x][i].e; if (dis[b] &gt; dis[a] + edge[x][i].w){ dis[b] = dis[a] + edge[x][i].w; if (!vis[b]) { q.push(b); vis[b] = 1; } } } } } 模板二 邻接矩阵 void spfa(int s){ for(int i=0; i&lt;=n; i++) dis[i]=99999999; //初始化每点到s的距离 dis[s]=0; vis[s]=1; q[1]=s; //队列初始化,s为起点 int i, v, head=0, tail=1; while (head&lt;tail){ //队列非空 head++; v=q[head]; //取队首元素 vis[v]=0; //释放队首结点，因为这节点可能下次用来松弛其它节点，重新入队 for(i=0; i&lt;=n; i++) //对所有顶点 if (a[v][i]&gt;0 &amp;&amp; dis[i]&gt;dis[v]+a[v][i]){ dis[i] = dis[v]+a[v][i]; //修改最短路 if (vis[i]==0){ //如果扩展结点i不在队列中，入队 tail++; q[tail]=i; vis[i]=1; } } } } 模板三 DFS优化 void spfa(int s){ for(int i=1; i&lt;=b[s][0]; i++) //b[s,0]是从顶点s发出的边的条数 if (dis[b[s][i]&gt;dis[s]+a[s][b[s][i]]){ //b[s,i]是从s发出的第i条边的另一个顶点 dis[b[s][i]=dis[s]+a[s][b[s][i]]; spfa(b[s][i]); } } A - Til the Cows Come Home（POJ 2387） 题意 给出n个点和m条边，求从1到n的最短路。 思路分析 最短路裸题。如果用邻接表Dijkstra的话需要判重边。 Floyd和Bellman-ford不需要。 我用的是链式前向星+Dijkstra，所以也可以不判重。 代码 #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #include &lt;queue&gt; using namespace std; const int maxn = 4005; int T,N; struct node { int d,u; friend bool operator &lt; (node a, node b) { return a.d &gt; b.d; } node(int dist, int point): d(dist), u(point){} }; struct Edge { int to,next; int dist; } edge[maxn]; int head[maxn], tot; int pre[maxn], dis[maxn]; void init() { memset(head, -1, sizeof(head)); tot=0; } void addedge(int u,int v,int d) { edge[tot].to = v; edge[tot].dist = d; edge[tot].next = head[u]; head[u]=tot++; } void Dijkstra(int s) { priority_queue&lt;node&gt; q; memset(dis, 0x3f, sizeof(dis)); memset(pre, -1, sizeof(pre)); dis[s]=0; while(!q.empty()) q.pop(); node a(0,s); q.push(a); while(!q.empty()) { node x = q.top(); q.pop(); if(dis[x.u] &lt; x.d) continue; for(int i = head[x.u]; i != -1; i = edge[i].next) { int v = edge[i].to; if (dis[v] &gt; dis[x.u] + edge[i].dist) { dis[v] = dis[x.u] + edge[i].dist; pre[v] = x.u; q.push(node(dis[v], v)); } } } } int main(){ init(); cin &gt;&gt; T &gt;&gt; N; while (T--){ int u, v, d; cin &gt;&gt; u &gt;&gt; v &gt;&gt; d; addedge(u, v, d); addedge(v, u, d); } Dijkstra(1); cout &lt;&lt; dis[N] &lt;&lt; endl; return 0; } B - Heavy Transportation（POJ 1797） 题意 给出从1城到n城的每条路的最大载重量，求最大运货量。 思路分析 最短路的变形题，只需要改一下松弛操作就可以了。 F - 地铁 CSU - 1808 题意 最短路。 给出n个地铁站，m条边，给出每条边的首尾地铁站a、b，和这条边所属的地铁线c，以及这条边的边权d。 地铁线之间需要换乘，换乘时间为abs(ci-cj)。 因为多了一个换乘时间，所以需要拆点。 用链式前向星存边，用map&lt;int,int&gt;拆点，用vector存当前点所在的地铁。 思路 首先读边。用map[u][x]来表示u地铁站在x号线上，存储一个标记值cnt，代表这个点是第几个点（重新编号）。然后取出这个点。v点同样。最后addedge两遍。 遍历所有点。对每个点下的vector排个序，这样就可以避免取绝对值。对每个点遍历vector，对于vector中的每条地铁线，将这个点取出添边。 制图之后就按照模板跑Dijkstra，注意最后获取结果的时候要跑一遍n点的vector找最小值。 代码 /****************************** *File name: csu1808.cpp *Author: wzhzzmzzy *Created Time: 一 4/17 20:54:29 2017 *TODO: CSU 1808 最短路 ******************************/ #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; #include &lt;vector&gt; #include &lt;queue&gt; #include &lt;map&gt; using namespace std; const int maxn = 300005; const int inf = 0x3f3f3f3f; int n, m; struct Edge{ int to, next; int w; }edge[maxn&lt;&lt;1]; int head[maxn], tot; void init(){ memset(head, -1, sizeof(head)); tot = 0; } void addedge(int u, int v, int w){ edge[tot].to = v; edge[tot].w = w; edge[tot].next = head[u]; head[u] = tot++; } vector&lt;int&gt; num[maxn]; //某站所属的线路 map&lt;int,int&gt; mmp[maxn]; //某站是记录的第几个地铁站（拆点） int dis[maxn], cnt; struct node{ int now, c; node(int _n=0, int _c=0):now(_n), c(_c){} friend bool operator &lt;(node a, node r){ return a.c &gt; r.c; } }; void Dijkstra(){ priority_queue&lt;node&gt; q; while (!q.empty()) q.pop(); for (int i = 1; i &lt; cnt; ++i) dis[i] = inf; for (int i = 0; i &lt; num[1].size(); ++i){ int st = mmp[1][num[1][i]]; dis[st] = 0; q.push(node(st, 0)); } node temp; while (!q.empty()){ temp = q.top(); q.pop(); int u = temp.now; int cost = temp.c; if (cost &gt; dis[u]) continue; for (int i = head[u]; ~i; i=edge[i].next){ int v = edge[i].to; int w = edge[i].w; if (dis[v] &gt; cost+w){ dis[v] = cost + w; q.push(node(v, dis[v])); } } } } int main(){ int u, v, x, w; while (~scanf(&quot;%d%d&quot;, &amp;n, &amp;m)){ init(); cnt = 1; for (int i = 1; i &lt;= n; ++i){ num[i].clear(); mmp[i].clear(); } for (int i = 0; i &lt; m; ++i){ scanf(&quot;%d%d%d%d&quot;, &amp;u, &amp;v, &amp;x, &amp;w); if (!mmp[u][x]){ mmp[u][x] = cnt++; num[u].push_back(x); } u = mmp[u][x]; if (!mmp[v][x]){ mmp[v][x] = cnt++; num[v].push_back(x); } v = mmp[v][x]; addedge(u, v, w); addedge(v, u, w); } for(int i = 1; i &lt;= n; ++i){ sort(num[i].begin(), num[i].end()); for(int j = 0; j &lt; num[i].size()-1; ++j){ u = mmp[i][num[i][j]]; v = mmp[i][num[i][j+1]]; w = num[i][j+1] - num[i][j]; //同一站点不同线路的拆点之间的差值 addedge(u, v, w); addedge(v, u, w); } } Dijkstra(); int ans = inf; for (int i = 0; i &lt; num[n].size(); ++i){ u = mmp[n][num[n][i]]; ans = min(ans, dis[u]); } printf(&quot;%d\\n&quot;, ans); } return 0; } ","link":"https://wzhzzmzzy.github.io/post/2017-03-20-最短路专题整理"}]}