<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8" />
<title>
    拭微
</title>
<meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport" />
<meta http-equiv="x-dns-prefetch-control" content="on">
<link rel="dns-prefetch" href="https://wzhzzmzzy.github.io">
<link rel="dns-prefetch" href="https://cdn.bootcss.com">
<link rel="dns-prefetch" href="https://cdn.jsdelivr.net">
<meta name="author" content="Amber">
<meta name="description" content="一直尝试变得更有趣的阿宅">
<meta name="keywords" content="">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/itjoker233/Gridea-theme-Chic@latest/assets/media/css/style.min.css" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/itjoker233/Gridea-theme-Chic@latest/cdn/main.css" />
<!--<link rel="stylesheet" href="https://wzhzzmzzy.github.io/media/css/style.min.css" />
<link rel="stylesheet" href="https://wzhzzmzzy.github.io/styles/main.css" />-->
<link href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.css" rel="stylesheet">

    <script src="https://cdn.jsdelivr.net/npm/aplayer@1.10.0/dist/APlayer.min.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10.0/dist/APlayer.min.css">
    
        <script type="text/javascript" src="https://apps.bdimg.com/libs/jquery/1.7.1/jquery.min.js"></script>
        <script src="https://cdn.jsdelivr.net/gh/itjoker233/Gridea-theme-Chic@latest/assets/media/script/tocbot.min.js"></script>
        <script src="https://cdn.jsdelivr.net/gh/itjoker233/Gridea-theme-Chic@latest/assets/media/script/script.min.js"></script>
        <script src="https://cdn.jsdelivr.net/gh/itjoker233/Gridea-theme-Chic@latest/assets/media/script/icon.min.js"></script>
        <!--<script src="https://wzhzzmzzy.github.io/media/script/tocbot.min.js"></script>
        <script src="https://wzhzzmzzy.github.io/media/script/script.min.js"></script>
        <script src="https://wzhzzmzzy.github.io/media/script/icon.min.js"></script>-->
        <script src="https://cdn.bootcss.com/highlight.js/9.13.1/highlight.min.js"></script>
        <link href="https://cdn.bootcss.com/highlight.js/9.13.1/styles/atelier-estuary-dark.min.css" rel="stylesheet">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.1/dist/katex.min.css">
        <script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.1/dist/katex.min.js"></script>
        
            <script>
                (function() {
                    var bp = document.createElement('script');
                    var curProtocol = window.location.protocol.split(':')[0];
                    if (curProtocol === 'https') {
                        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
                    } else {
                        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
                    }
                    var s = document.getElementsByTagName("script")[0];
                    s.parentNode.insertBefore(bp, s);
                })();
            </script>
            
                
</head>

<body>
    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo">
                <a href="https://wzhzzmzzy.github.io">
                    拭微
                </a>
            </div>

            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/">
                        首页
                    </a>
                    
                    <a class="menu-item" href="/archives">
                        归档
                    </a>
                    
                    <a class="menu-item" href="/tags">
                        标签
                    </a>
                    
                    <a class="menu-item" href="/post/about">
                        关于
                    </a>
                    
                        <input id="switch_default" type="checkbox" class="switch_default">
                        <label for="switch_default" class="toggleBtn"></label>
            </div>
            <form id="gridea-search-form" data-update="1579927857513" action="/search/index.html">
                <input class="search-input" autocomplete="off" spellcheck="false" name="q" autofocus="true" placeholder="Search...">
            </form>
        </div>
    </nav>

    
        <nav class="navbar-mobile" id="nav-mobile">
            <div class="container">
                <div class="navbar-header">
                    <div>
                        <a href="https://wzhzzmzzy.github.io">
                            拭微
                        </a>
                        <!--en-->
                        <a id="mobile-toggle-theme-en" class="a en">&nbsp;Dark</a>
                        <!--zh-->
                        <a id="mobile-toggle-theme-zh" class="a zh">&nbsp;\u6697\u9ED1</a>
                    </div>
                    <form id="gridea-search-form" data-update="1579927857513" action="/search/index.html">
                        <input class="search-input" autocomplete="off" spellcheck="false" name="q" autofocus="true" placeholder="Search...">
                    </form>
                    <!--en-->
                    <div class="menu-toggle" id="menu-toggle-en" onclick="mobileBtn()">&#9776; Menu</div>
                    <!--zh-->
                    <div class="menu-toggle" id="menu-toggle-zh" onclick="mobileBtn()">&#9776; &#x83DC;&#x5355;</div>

                </div>
                <div class="menu" id="mobile-menu">
                    
                        <a class="menu-item" href="/">
                            首页
                        </a>
                        
                        <a class="menu-item" href="/archives">
                            归档
                        </a>
                        
                        <a class="menu-item" href="/tags">
                            标签
                        </a>
                        
                        <a class="menu-item" href="/post/about">
                            关于
                        </a>
                        
                </div>
            </div>
        </nav>
</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementById("menu-toggle-en");
        var toggleMenu_zh = document.getElementById("menu-toggle-zh");

        var mobileMenu = document.getElementById("mobile-menu");
        if (toggleMenu.display != "none") {
            if (toggleMenu.classList.contains("active")) {
                toggleMenu.classList.remove("active")
                mobileMenu.classList.remove("active")
            } else {
                toggleMenu.classList.add("active")
                mobileMenu.classList.add("active")
            }
        } else if (toggleMenu_zh.display != "none") {
            if (toggleMenu_zh.classList.contains("active")) {
                toggleMenu_zh.classList.remove("active")
                mobileMenu.classList.remove("active")
            } else {
                toggleMenu_zh.classList.add("active")
                mobileMenu.classList.add("active")
            }
        }

    }
</script>
            <div class="main">
                <div class="container">
                    <article class="post-wrap">
                        <header class="post-header">
                            <h1 class="post-title">
                                树形DP入门专题题解
                            </h1>
                            <!--en-->
                            <div class="post-meta en">
                                Author:
                                <a itemprop="author" rel="author" href="/">
                                    拭微
                                </a>
                                <span class="post-time">
                                Date: <a href="#">2017-08-07</a>
                            </span>
                                <span class="post-readtime">Reading Time:<a href="#">27.0 mins</a></span>
                                <span class="post-words">words:<a href="#">5166</a></span>
                                
                                    <span class="post-category">
                                Category:
                                
                                <a href="https://wzhzzmzzy.github.io/tag/G3FWMuzW0">ACM-ICPC</a>
                                
                            </span>
                                    
                            </div>
                            <!--zh-->
                            <div class="post-meta zh">
                                &#x4F5C;&#x8005;:
                                <a itemprop="author" rel="author" href="/">
                                    拭微
                                </a>
                                <span class="post-time">&#x65E5;&#x671F;: <a href="#">2017-08-07</a></span>
                                <span class="post-readtime">&#x9605;&#x8BFB;&#x65F6;&#x95F4;:<a href="#">27.0 &#x5206;&#x949F;</a></span>
                                <span class="post-words">&#x5B57;&#x6570;:<a href="#">5166</a></span>
                                
                                    <span class="post-category">&#x5206;&#x7C7B;:
                                
                                <a href="https://wzhzzmzzy.github.io/tag/G3FWMuzW0">ACM-ICPC</a>
                                
                            </span>
                                    
                            </div>
                        </header>
                        <div class="post-content">
                            <blockquote>
<p><a href="https://vjudge.net/contest/176749">Vjudge 树形DP入门专题</a></p>
</blockquote>
<p>专题中题目名称取自Android OS版本名。</p>
<h3 id="所谓树形dp">所谓树形DP</h3>
<p>一般的树形DP题，都是给出一张树形图，然后用DFS去深搜，获取每个节点多个状态的值。最简单的入门题如<a href="http://poj.org/problem?id=2342">POJ-2342</a>，只需要一遍DFS，用子节点回溯更新父节点即可。一道经典题是<a href="http://acm.hdu.edu.cn/showproblem.php?pid=2196">HDU-2196</a>，这道题用了分别深搜求每个节点的父节点状态值和子节点状态值，最后求和的方法，复杂度 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 。这是树形DP的经典方法，大多数树形DP题都是通过这种方法求解。</p>
<h3 id="入门部分">入门部分</h3>
<h4 id="poj-2342-anniversary-party">POJ - 2342 - Anniversary party</h4>
<h5 id="题意">题意</h5>
<p>给出每个节点的权值，以及一棵有向边组成的树，有向边 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>u</mi><mo separator="true">,</mo><mi>v</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(u, v)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">)</span></span></span></span> 表示 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span></span></span></span> 是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">u</span></span></span></span> 的直属上级，直属上下级不能同时被选中，要求如何选择节点可以使节点总和最大。</p>
<h5 id="思路">思路</h5>
<p>用<code>dp[i][0/1]</code>表示<code>i</code>节点没有被选中或被选中时，以其为根的子树总和。POJ这道题可以直接用<code>fa</code>数组存边，<code>DFS</code>回溯时用子节点<code>v</code>权值更新父节点<code>u</code>。</p>
<p>转移方程：</p>
<pre><code class="language-c">dp[u][1] += dp[v][0],
dp[u][0] += max(dp[v][1], dp[v][0])
</code></pre>
<h5 id="代码">代码</h5>
<pre><code class="language-c++">/**
 * Author: wzhzzmzzy
 * Question: POJ - 2342
 * Algorithm: 树形 DP 入门
**/

#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
using namespace std;
//#define LOCAL

const int maxn = 6000+7;

int n, fa[maxn], dp[maxn][2];
bool vis[maxn];

int init() {
    int root, u, v;
    memset(fa, 0, sizeof fa);
    memset(vis, 0, sizeof vis);
    for (int i = 1; i &lt;= n; ++i)
        scanf(&quot;%d&quot;, dp[i]+1);
    root = 1;
    while (scanf(&quot;%d%d&quot;, &amp;u, &amp;v), u)
        fa[u]  = v;
    while (fa[root]) root = fa[root];
    return root;
}

void solve(int u) {
    vis[u] = 1;
    for (int v = 1; v &lt;= n; ++v)
    if (!vis[v] &amp;&amp; fa[v] == u) {
        solve(v);
        dp[u][1] += dp[v][0];
        dp[u][0] += max(dp[v][1], dp[v][0]);
    }
}

int main(){
#ifdef LOCAL
    freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);
#endif
    while (~scanf(&quot;%d&quot;, &amp;n)) {
        int root = init();
        solve(root);
        int ans = max(dp[root][0], dp[root][1]);
        printf(&quot;%d\n&quot;, ans);
    }
    return 0;
}
</code></pre>
<h4 id="hdu-1520-anniversary-party">HDU - 1520 - Anniversary party</h4>
<h5 id="题意-2">题意</h5>
<p>题意同上一题。</p>
<h5 id="思路-2">思路</h5>
<p>虽然题面完全一样，但是这道题有不少坑。所以用了一种更好的方法来写。链式前向星存边。注意一个文件只有一个样例。</p>
<h5 id="代码-2">代码</h5>
<pre><code class="language-c++">/**
 * Author: wzhzzmzzy
 * Question: HDU - 1520
 * Algorithm: 树形 DP 入门
**/

#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
using namespace std;

const int maxn = 6000+7;

struct node {
    int son, fa, bro, now, temp;
    int max() { return now &gt; temp ? now : temp; }
    void init() { son = fa = bro = temp = 0; }
} tree[maxn];

void dfs(int root) {
    int son = tree[root].son;
    while (son) {
        dfs(son);
        tree[root].now += tree[son].temp;
        tree[root].temp += tree[son].max();
        son = tree[son].bro;
    }
}

int main() {
    int n, k, l;
    while (~scanf(&quot;%d&quot;, &amp;n) &amp;&amp; n) {
        for (int i = 1; i &lt;= n; ++i) {
            scanf(&quot;%d&quot;, &amp;tree[i].now);
            tree[i].init();
        }
        while (scanf(&quot;%d%d&quot;, &amp;l, &amp;k) &amp;&amp; l+k) {
            tree[l].fa = k;
            tree[l].bro = tree[k].son;
            tree[k].son = l;
        }
        for (int i = 1; i &lt;= n; ++i) if (!tree[i].fa) {
            dfs(i);
            printf(&quot;%d\n&quot;, tree[i].max());
            break;
        }
    }
    return 0;
}
</code></pre>
<h4 id="hdu-2196-computer">HDU - 2196 - Computer</h4>
<h5 id="题意-3">题意</h5>
<p>有一棵计算机网络树，每条边有权值，求每个结点到树上最远结点的距离。</p>
<h5 id="思路-3">思路</h5>
<p>用<code>dp[i][0/1/2]</code>分别记录<code>i</code>结点子树最大/子树次大/父节点最大距离。第一遍<code>dfs_son</code>用子节点回溯更新父节点的子树最大、次大距离，第二遍<code>dfs_fa</code>用父节点更新子节点向上走的最大距离，此时需要判断该子树是否是父节点的最大距离子树。</p>
<h5 id="代码-3">代码</h5>
<pre><code class="language-c++">/**
 * Author: wzhzzmzzy
 * Question: HDU - 2196
 * Algorithm: 树形 DP 入门
**/

#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
using namespace std;

const int maxn = 10000+7;

struct Edge {
    int v, w, next;
} edge[maxn&lt;&lt;1];

int head[maxn], tot;
int dp[maxn][3], lson[maxn];
// 0 子节点最大 1 子节点次大 2 父节点最大

void init() {
    memset(dp, 0, sizeof dp);
    memset(head, -1, sizeof head);
    memset(lson, 0, sizeof lson);
    tot = 0;
}

void add_edge(int u, int v, int w) {
    edge[tot] = (Edge) { v, w, head[u] };
    head[u] = tot++;
}


void dfs_son(int u, int fa) {
    for (int i = head[u]; ~i; i = edge[i].next) {
        int v = edge[i].v, w = edge[i].w;
        if (v == fa) continue;
        dfs_son(v, u);
        if (dp[v][0]+w &gt; dp[u][0]) {
            lson[u] = v;
            dp[u][1] = dp[u][0];
            dp[u][0] = dp[v][0] + w;
        }
        else dp[u][1] = max(dp[v][0] + w, dp[u][1]);
    }
}

void dfs_fa(int u, int fa) {
    for (int i = head[u]; ~i; i = edge[i].next) {
        int v = edge[i].v, w = edge[i].w;
        if (v == fa) continue;
        v == lson[u]?
            dp[v][2] = max(dp[u][1], dp[u][2]) + w:
            dp[v][2] = max(dp[u][0], dp[u][2]) + w;
        dfs_fa(v, u);
    }
}

int main() {
    int n;
    while (~scanf(&quot;%d&quot;, &amp;n) &amp;&amp; n) {
        init();
        for (int v = 2; v &lt;= n; ++v) {
            int u, w; scanf(&quot;%d%d&quot;, &amp;u, &amp;w);
            add_edge(u, v, w);
            add_edge(v, u, w);
        }
        dfs_son(1, -1);
        dfs_fa(1, -1);
        for (int i = 1; i &lt;= n; ++i)
            printf(&quot;%d\n&quot;, max(dp[i][0], dp[i][2]));
    }
    return 0;
}
</code></pre>
<h3 id="简单题套路题">简单题（套路题）</h3>
<p>下面这些题基本都可以用 HDU-2196 的套路来轻松解决。</p>
<h4 id="codeforces-219d-choosing-capital-for-treeland">CodeForces - 219D - Choosing Capital for Treeland</h4>
<h5 id="题意-4">题意</h5>
<p>有一棵有向边树，找出一个点，让其可以到达所有其他点。这需要翻转某几条有向边。要求找出最小的翻转数目，和满足这个翻转数目的点。</p>
<h5 id="思路-4">思路</h5>
<p>存边时将正向赋值为0，反向赋值为1。对于子树，回溯更新到达子树上每个点需要翻转的边数。对于父节点，直接取父节点的值减去当前子树即可。注意这里有一个小问题，减去当前子树时，是要把最终结果赋值给子树根节点的，也就是说要将父节点到子节点的边减去，然后加上子节点到父节点的边。</p>
<h5 id="代码-4">代码</h5>
<pre><code class="language-c++">/**
 * Author: wzhzzmzzy
 * Question: CodeForces - 219D
 * Algorithm: 树形 DP
**/

#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
using namespace std;
//#define LOCAL

const int maxn = 2e5+7;

struct Edge {
    int v, w, next;
} edge[maxn&lt;&lt;1];

int head[maxn], tot;
int dp[maxn][2];

void init() {
    tot = 0;
    memset(head, -1, sizeof head);
    memset(dp, 0, sizeof dp);
}

void add_edge(int u, int v, int w) {
    edge[tot] = (Edge) { v, w, head[u] };
    head[u] =tot++;
}

void dfs_son(int u, int fa) {
    for (int i = head[u]; ~i; i = edge[i].next) {
        int v = edge[i].v, w = edge[i].w;
        if (v == fa) continue;
        dfs_son(v, u);
        dp[u][0] += dp[v][0] + w;
    }
}

void dfs_fa(int u, int fa) {
    for (int i = head[u]; ~i; i = edge[i].next) {
        int v = edge[i].v, w = edge[i].w, wo = edge[i^1].w;
        if (v == fa) continue;
        dp[v][1] += dp[u][0]-dp[v][0]+dp[u][1]-w+wo;
        dfs_fa(v, u);
    }
}

int main() {
#ifdef LOCAL
    freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);
#endif
    int n; scanf(&quot;%d&quot;, &amp;n);
    init();
    for (int i = 2; i &lt;= n; ++i) {
        int u, v;
        scanf(&quot;%d%d&quot;, &amp;u, &amp;v);
        add_edge(u, v, 0);
        add_edge(v, u, 1);
    }
    dfs_son(1, -1);
    dfs_fa(1, -1);
    int mi = 0x3f3f3f3f;
    for (int i = 1; i &lt;= n; ++i)
        mi = min(mi, dp[i][0]+dp[i][1]);
    vector&lt;int&gt; ans;
    for (int i = 1; i &lt;= n; ++i) if (dp[i][1]+dp[i][0] == mi)
        ans.push_back(i);
    printf(&quot;%d\n&quot;, mi);
    for (int i = 0; i &lt; (int)ans.size()-1; ++i)
        printf(&quot;%d &quot;, ans[i]);
    printf(&quot;%d&quot;, ans.back());
    return 0;
}
</code></pre>
<h4 id="poj-3107-godfather">POJ - 3107 - Godfather</h4>
<h5 id="题意-5">题意</h5>
<p>要求去掉树上的一个节点，使得树的剩余最大部分最小。</p>
<h5 id="思路-5">思路</h5>
<p>在对于子树<code>DFS</code>的过程中，需要回溯更新所有子树的结点数，和最大子树结点数。对于父节点，只需要 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span> 更新即可。</p>
<h5 id="代码-5">代码</h5>
<pre><code class="language-c++">/**
 * Author: wzhzzmzzy
 * Question: POJ - 3107
 * Algorithm: 树形 DP
**/

#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
using namespace std;
//#define LOCAL

const int maxn = 50000+7;

struct Edge {
    int v, w, next;
} edge[maxn &lt;&lt; 1];

int head[maxn], tot;
int dp[maxn][3];

void init() {
    memset(head, -1, sizeof head);
    memset(dp, 0, sizeof dp);
    tot = 0;
}

void add_edge(int u, int v, int w) {
    edge[tot] = (Edge) { v, w, head[u] };
    head[u] = tot++;
}

void dfs_son(int u, int fa) {
    for (int i = head[u]; ~i; i = edge[i].next) {
        int v = edge[i].v;
        if (v == fa) continue;
        dfs_son(v, u);
        dp[u][0] += dp[v][0] + 1; // sum of son tree
        dp[u][1] = max(dp[v][0] + 1, dp[u][1]); // max of son tree
    }
}

int main() {
#ifdef LOCAL
    freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);
#endif
    int n;
    while (~scanf(&quot;%d&quot;, &amp;n) &amp;&amp; n) {
        // input
        init();
        for (int i = 1; i &lt; n; ++i) {
            int u, v; scanf(&quot;%d%d&quot;, &amp;u, &amp;v);
            add_edge(u, v, 1);
            add_edge(v, u, 1);
        }
        dfs_son(1, -1);
        for (int u = 1; u &lt;= n; ++u) {
            dp[u][0] = n - dp[u][0] - 1;
            dp[u][2] = max(dp[u][1], dp[u][0]);
        }
        int mi = 0x3f3f3f3f, i;
        vector&lt;int&gt; ans;
        for (int u = 1; u &lt;= n; ++u)
            mi = min(mi, dp[u][2]);
        for (int u = 1; u &lt;= n; ++u) if (dp[u][2] == mi)
            ans.push_back(u);
        for (i = 0; i &lt; (int)ans.size()-1; ++i)
            printf(&quot;%d &quot;, ans[i]);
        printf(&quot;%d\n&quot;, ans[i]);
    }
    return 0;
}
</code></pre>
<h4 id="poj-2378-tree-cutting">POJ - 2378 - Tree Cutting</h4>
<h5 id="题意-6">题意</h5>
<p>题意和上一题类似。也是去掉一个树上的节点，使得树的最大分块节点数不到总结点数的一半。</p>
<h5 id="思路-6">思路</h5>
<p>和上一题相似。</p>
<h5 id="代码-6">代码</h5>
<pre><code class="language-c++">/**
 * Author: wzhzzmzzy
 * Question: POJ - 2378
 * Algorithm: 树形 DP
**/

#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
using namespace std;
//#define LOCAL

const int maxn = 10000+7;

struct Edge {
    int v, w, next;
} edge[maxn&lt;&lt;1];

int head[maxn], tot;
int dp[maxn][3];

void init() {
    memset(head, -1, sizeof head);
    memset(dp, 0, sizeof dp);
    tot = 0;
}

void add_edge(int u, int v, int w) {
    edge[tot] = (Edge) { v, w, head[u] };
    head[u] = tot++;
}

void dfs(int u, int fa) {
    for (int i = head[u]; ~i; i = edge[i].next) {
        int v = edge[i].v;
        if (v == fa) continue;
        dfs(v, u);
        dp[u][0] += dp[v][0] + 1;
        dp[u][1] = max(dp[u][1], dp[v][0]+1);
    }
}

int main() {
#ifdef LOCAL
    freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);
#endif
    int n;
    while (~scanf(&quot;%d&quot;, &amp;n) &amp;&amp; n) {
        int mid = n &gt;&gt; 1;
        init();
        for (int i = 1; i &lt; n; ++i) {
            int u, v; scanf(&quot;%d%d&quot;, &amp;u, &amp;v);
            add_edge(u, v, 1);
            add_edge(v, u, 1);
        }
        dfs(1, -1);
        for (int i = 1; i &lt;= n; ++i)
            dp[i][0] = n - dp[i][0] - 1;
        for (int i = 1; i &lt;= n; ++i)
            dp[i][2] = max(dp[i][0], dp[i][1]);
        vector&lt;int&gt; ans;
        for (int i = 1; i &lt;= n; ++i)
            if (dp[i][2] &lt;= mid) ans.push_back(i);
        if (!ans.size()) puts(&quot;NONE&quot;);
        else
            for (int i = 0; i &lt; (int)ans.size(); ++i)
                printf(&quot;%d\n&quot;, ans[i]);
    }
    return 0;
}
</code></pre>
<h4 id="poj-3140-contestants-division">POJ - 3140 - Contestants Division</h4>
<h5 id="题意-7">题意</h5>
<p>在树上去掉一条边，使树两边的节点权值总和差最小。</p>
<h5 id="思路-7">思路</h5>
<p>一开始没读懂题意。DFS统计所有子树的权值，然后只需要 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span> 遍历，比较一遍即可。注意会爆<code>int</code>，需要把更大的<code>INF</code>。</p>
<h5 id="代码-7">代码</h5>
<pre><code class="language-c++">/**
 * Author: wzhzzmzzy
 * Question: POJ - 3140
 * Algorithm: 树形 DP
**/

#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
using namespace std;
//#define LOCAL
#define LL long long
const int maxn = 100000+7;

struct Edge {
    int v, w, next;
} edge[maxn&lt;&lt;1];

int head[maxn], tot;
LL dp[maxn][3], sum;

void init() {
    memset(head, -1, sizeof head);
    memset(dp, 0, sizeof dp);
    tot = sum = 0;
}

void add_edge(int u, int v, int w) {
    edge[tot] = (Edge) { v, w, head[u] };
    head[u] = tot++;
}

void dfs(int u, int fa) {
    for (int i = head[u]; ~i; i = edge[i].next) {
        int v = edge[i].v;
        if (v == fa) continue;
        dfs(v, u);
        dp[u][0] += dp[v][0];
    }
}

LL _abs(LL x) {
    return x &gt;= 0 ? x : -x;
}

int main() {
#ifdef LOCAL
    freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);
#endif
    int n, m, cas = 1;
    while (~scanf(&quot;%d%d&quot;, &amp;n, &amp;m) &amp;&amp; n+m) {
        init();
        for (int i = 1; i &lt;= n; ++i) {
            scanf(&quot;%lld&quot;, dp[i]);
            sum += dp[i][0];
        }
        for (int i = 1; i &lt; n; ++i) {
            int u, v; scanf(&quot;%d%d&quot;, &amp;u, &amp;v);
            add_edge(u, v, 0);
            add_edge(v, u, 0);
        }
        dfs(1, -1);
        LL mi = 21474836470000000;
        for (int i = 1; i &lt;= n; ++i) {
            dp[i][1] = sum - dp[i][0];
            dp[i][2] = _abs(dp[i][1] - dp[i][0]);
            mi = min(dp[i][2], mi);
        }
        printf(&quot;Case %d: %lld\n&quot;, cas++, mi);
    }
    return 0;
}
</code></pre>
<h3 id="难题">难题</h3>
<h4 id="hdu-5834-magic-boy-bi-luo-with-his-excited-tree">HDU - 5834 - Magic boy Bi Luo with his excited tree</h4>
<h5 id="题意-8">题意</h5>
<p>有一棵树，点和边都有权值。到达一个点加上点权，经过一条边减去边权。多次经过边多次计算，但是点权只能加一次。求能获得的最大权值。</p>
<h5 id="思路-8">思路</h5>
<p>可以算是比较复杂的树形DP了，主要是数据处理相当麻烦。首先对于<code>i</code>点有四种情况，<code>f[i][0]</code>表示从<code>i</code>出发，经过子树后又回到<code>i</code>点的最大权值，<code>f[i][1]</code>就表示停留在子树当中的最大权值。<code>g[i][0]</code>表示向父节点走回到<code>i</code>点能获得的最大权值，<code>g[i][1]</code>表示不回到<code>i</code>点的最大权值。</p>
<p>最终答案就是<code>max(f[i][1]+g[i][0], f[i][0]+g[i][1])</code>。</p>
<p>具体解法看代码注释。</p>
<h5 id="代码-8">代码</h5>
<pre><code class="language-c++">/**
 * Author: wzhzzmzzy
 * Question: HDU - 5834
 * Algorithm: 树形 DP
**/

#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
using namespace std;
//#define LOCAL

const int maxn = 1e5+7;

struct Edge {
    int v, w, next;
} edge[maxn&lt;&lt;1];

int head[maxn], tot;
int f[maxn][2], g[maxn][2], val[maxn];
// f i 1/0 -&gt; i 子树不回/回
// g i 1/0 -&gt; i 祖先不回/回
void init() {
    memset(head, -1, sizeof head);
    tot = 0;
}

void add_edge(int u, int v, int w) {
    edge[tot] = (Edge) { v, w, head[u] };
    head[u] = tot++;
}

void dfs_son(int u, int fa) {
    f[u][1] = f[u][0] = val[u];
    for (int i = head[u]; ~i; i = edge[i].next) {
        int v = edge[i].v, w = edge[i].w;
        if (v == fa) continue;
        dfs_son(v, u);
        f[u][0] += max(0, f[v][0]-w*2);
    }

    int mx = 0;
    for (int i = head[u]; ~i; i = edge[i].next) {
        int v = edge[i].v, w = edge[i].w;
        if (v == fa) continue;
        mx = max(mx, f[v][1]-w-max(0, f[v][0]-w*2));
    }
    f[u][1] = f[u][0] + mx;
}

void dfs_fa(int u, int fa) {
    int mx = 0, nmx = 0, temp; // 最大 次大
    for (int i = head[u]; ~i; i = edge[i].next) {
        // 求出一个可以最大化收益的不回头子节点，以及其次的节点
        int v = edge[i].v, w = edge[i].w;
        if (v == fa) continue;
        temp = f[v][1] - w - max(0, f[v][0]-w*2);
        if (temp &gt; mx) nmx = mx, mx = temp;
        else nmx = max(nmx, temp);
    }

    for (int i = head[u]; ~i; i = edge[i].next) {
        int v = edge[i].v, w = edge[i].w;
        if (v == fa) continue;
        temp = f[u][0] - max(0, f[v][0]-w*2);
        int mmx = max(temp, g[u][0]) - w*2;
        // 只走子节点和只走父节点哪个更大一点？
        mmx = max(mmx, g[u][0]+temp-w*2-val[u]);
        // 上述最大的和父子节点都走哪个更大？
        g[v][0] = val[v] + max(0, mmx); // 更新子节点

        int t = 0; // 求消去v影响后的u子树不回头值
        if (f[v][0] - w*2 &gt; 0) {
            // 这个子节点回头可以走的话
            if (mx == f[v][1] - w - f[v][0] + w*2)
                // 这个子节点是收益最大化点吗？
                t = f[u][1] - f[v][1] + w + nmx; // 是的话消去影响（取次大）
            else t = f[u][1] - f[v][0] + w*2; // 否则直接取
        } else if (f[v][1] - w &gt; 0) {
            // 子节点可以作为最后终点的话同上
            if (mx == f[v][1] - w)
                t = f[u][1] - f[v][1] + w + nmx;
            else t = f[u][1];
        } else t = f[u][1]; // 不能走直接取
        mmx = max(g[u][1], t) - w;
        // 只走父节点和子树中取最大
        mmx = max(mmx, max(g[u][0]+t, g[u][1]+temp) - w - val[u]);
        // 上述最大和父子节点都走取最大
        g[v][1] = val[v] + max(0, mmx);
        dfs_fa(v, u);
    }
}

int main() {
#ifdef LOCAL
    freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);
#endif
    int t, cas = 1;
    scanf(&quot;%d&quot;, &amp;t);
    while (t--) {
        init();
        int n; scanf(&quot;%d&quot;, &amp;n);
        for (int i = 1; i &lt;= n; ++i)
            scanf(&quot;%d&quot;, val+i);
        for (int i = 2; i &lt;= n; ++i) {
            int u, v, w; scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w);
            add_edge(u, v, w);
            add_edge(v, u, w);
        }
        dfs_son(1, -1);
        g[1][0] = g[1][1] = val[1];
        dfs_fa(1, -1);
        printf(&quot;Case #%d:\n&quot;, cas++);
        for (int i = 1; i &lt;= n; ++i)
            printf(&quot;%d\n&quot;, max(g[i][0]+f[i][1], g[i][1]+f[i][0])-val[i]);
    }
}
</code></pre>
<h4 id="poj-2152-fire">POJ - 2152 - Fire</h4>
<h5 id="题意-9">题意</h5>
<p>一棵城市树上，选择一些节点修建消防站。在<code>i</code>点修消防站需要花费<code>w[i]</code>，并且最终图上的每个点，在<code>d[i]</code>范围内必须要有一座消防站。</p>
<h5 id="思路-9">思路</h5>
<p>国家集训队06年陈启峰论文上的一道题。很难做。</p>
<p>首先对于每个点，我们都需要遍历过它的所有子节点才能更新它的值。我们用<code>dp[i][j]</code>表示<code>j</code>节点修建消防站，作为<code>i</code>节点的负责站时，<code>i</code>为根的子树都拥有负责站的最小权值，用<code>ans[i]</code>表示这些点中的最优情况。</p>
<p>那么只需要一遍DFS，回溯遍历所有的节点，对于所有在<code>d[i]</code>范围内的点<code>j</code>都更新一下<code>dp[i][j]</code>，更新时需要遍历<code>i</code>的所有子节点<code>v</code>，判断是否可以直接将<code>j</code>作为负责站，如果不可以，就需要加上<code>ans[v]</code>。</p>
<h5 id="代码-9">代码</h5>
<pre><code class="language-c++">/**
 * Author: wzhzzmzzy
 * Question: POJ - 2152
 * Algorithm: 树形 DP
**/

#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
using namespace std;
//#define LOCAL

const int maxn = 1000+7;
const int INF = 0x3f3f3f3f;

struct Edge {
    int v, w, next;
} edge[maxn&lt;&lt;1];

int head[maxn], tot;
int w[maxn], d[maxn], dis[maxn];
// 建站价格 最大距离 某点到所有点的距离
int dp[maxn][maxn], ans[maxn], n;
// dp[i][j] -&gt; j 点建站向 i 点负责，且 i 子树所有点已经保全的最小价格
// ans[i] -&gt; i 点及其子树保全的最小价格

void init() {
    memset(head, -1, sizeof head);
    tot = 0;
}

void add_edge(int u, int v, int w) {
    edge[tot] = (Edge) { v, w, head[u] };
    head[u] = tot++;
}

void dfs_dis(int u) {
    // 求 u 到所有点的距离
    for (int i = head[u]; ~i; i = edge[i].next) {
        int v = edge[i].v, w = edge[i].w;
        if (~dis[v]) continue;
        dis[v] = dis[u] + w;
        dfs_dis(v);
    }
}

void dfs_ans(int u, int fa) {
    for (int i = head[u]; ~i; i = edge[i].next) {
        int v = edge[i].v;
        if (v == fa) continue;
        dfs_ans(v, u);
        // 搜索过所有子节点之后才更新父节点
    }
    // init
    memset(dis, -1, sizeof dis);
    dis[u] = 0;
    dfs_dis(u);
    ans[u] = INF;
    for (int i = 1; i &lt;= n; ++i) dp[u][i] = INF;
    // 遍历所有可能的点
    for (int i = 1; i &lt;= n; ++i) if (dis[i] &lt;= d[u]) {
        dp[u][i] = w[i];
        // 遍历子树
        for (int j = head[u]; ~j; j = edge[j].next) {
            int v = edge[j].v;
            if (v == fa) continue;
            dp[u][i] += min(ans[v], dp[v][i]-w[i]);
        }
        ans[u] = min(ans[u], dp[u][i]);
    }
}

int main() {
#ifdef LOCAL
    freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);
#endif
    int t; scanf(&quot;%d&quot;, &amp;t);
    while (t--) {
        init();
        scanf(&quot;%d&quot;, &amp;n);
        for (int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, w+i);
        for (int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, d+i);
        for (int i = 1; i &lt; n; ++i) {
            int u, v, w;
            scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w);
            add_edge(u, v, w);
            add_edge(v, u, w);
        }
        dfs_ans(1, -1);
        printf(&quot;%d\n&quot;, ans[1]);
    }
    return 0;
}
</code></pre>
<h3 id="其他好题">其他好题</h3>
<p>这些题不一定难，但是都是在对于树形DP的扩展，值得一做。</p>
<h4 id="hdu-3586-information-disturbing">HDU - 3586 - Information Disturbing</h4>
<h5 id="题意-10">题意</h5>
<p>一棵关系树，你有一个工具可以切断其中的边。每切断一条边需要消耗等同于边权的生命值，并且边权不能超过你工具的攻击力。需要求出一个最小的攻击力。</p>
<h5 id="思路-10">思路</h5>
<p>仔细想一想，这是一个判定性问题，最小的攻击力上限以上的攻击力都是满足条件的，所以我们可以通过二分来解决。这样的复杂度就是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mi>l</mi><mi>o</mi><mi>g</mi><mi>w</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^2logw)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mclose">)</span></span></span></span>，<code>w</code>为最大边权。</p>
<p>对于每一个攻击力，我们只需要回溯更新求在当前攻击力限制下所需要的生命值，如果超出上限，就向右二分，否则向左。</p>
<h5 id="代码-10">代码</h5>
<pre><code class="language-c++">/**
 * Author: wzhzzmzzy
 * Question: HDU - 3586
 * Algorithm: 树形 DP + 二分
**/

#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;string&gt;
#include &lt;algorithm&gt;
using namespace std;
//#define LOCAL

const int maxn = 1000+7;
const int INF = 1000000+7;

struct Edge {
    int v, w, next;
} edge[maxn];

int head[maxn], tot;
int dp[maxn], mx;

void init() {
    memset(head, -1, sizeof head);
    memset(dp, 0, sizeof dp);
    tot = mx = 0;
}

void add_edge(int u, int v, int w) {
    edge[tot] = (Edge) { v, w, head[u] };
    head[u] = tot++;
}

void dfs(int u, int fa, int lim) {
    int isLeaf = 1; // 标记叶子节点
    for (int i = head[u]; ~i; i = edge[i].next) {
        int v = edge[i].v, w = edge[i].w;
        if (v == fa) continue;
        isLeaf = 0;
        dfs(v, u, lim);
        lim &gt;= w ?
            dp[u] += min(dp[v], w):
            dp[u] += dp[v];
    }
    if (isLeaf) dp[u] = INF;
}

int main() {
#ifdef LOCAL
    freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);
#endif
    int n, m;
    while (~scanf(&quot;%d%d&quot;, &amp;n, &amp;m) &amp;&amp; n+m) {
        init();
        for (int i = 1; i &lt; n; ++i) {
            int u, v, w; scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w);
            add_edge(u, v, w);
            add_edge(v, u, w);
            mx = max(mx, w);
        }
        int l = 1, r = mx, ans = -1;
        while (l &lt;= r) {
            int mid = (l+r) &gt;&gt; 1;
            memset(dp, 0, sizeof dp);
            dfs(1, -1, mid);
            if (dp[1] &lt;=  m)
                ans = mid, r = mid-1;
            else l = mid+1;
        }
        printf(&quot;%d\n&quot;, ans);
    }
}
</code></pre>
<h4 id="zoj-3201-tree-of-tree">ZOJ - 3201 - Tree of Tree</h4>
<h5 id="题意-11">题意</h5>
<p>在树上选出一棵大小为<code>k</code>的子树，要求子树的权值和最大。</p>
<h5 id="思路-11">思路</h5>
<p>树上的01背包，很简单。</p>
<h5 id="代码-11">代码</h5>
<pre><code class="language-c++">/******************************
 *File name: zoj3201.cpp
 *Author: wzhzzmzzy
 *Created Time: 一  8/ 7 16:07:58 2017
 *TODO: 树形DP+01背包
******************************/

#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
using namespace std;

const int maxn = 500+7;

struct Edge {
    int v, next;
} edge[maxn&lt;&lt;1];

int head[maxn], tot;
int dp[maxn][maxn], n, m;

void init() {
    memset(head, -1, sizeof head);
    memset(dp, 0, sizeof dp);
    tot = 0;
}

void add_edge(int u, int v) {
    edge[tot] = (Edge) { v, head[u] };
    head[u] = tot++;
}


void dfs(int u, int fa) {
    for (int i = head[u]; ~i; i = edge[i].next) {
        int v = edge[i].v;
        if (v == fa) continue;
        dfs(v, u);
        for (int j = m; j &gt; 1; --j)
            for (int k = 1; k &lt; j; ++k)
                dp[u][j] = max(dp[u][j], dp[u][j-k]+dp[v][k]);
    }
}

int main() {
#ifdef LOCAL
    freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);
#endif
    while (~scanf(&quot;%d%d&quot;, &amp;n, &amp;m)) {
        init();
        for (int i = 0; i &lt; n; ++i) scanf(&quot;%d&quot;, &amp;dp[i][1]);
        for (int i = 1; i &lt; n; ++i) {
            int u, v; scanf(&quot;%d%d&quot;, &amp;u, &amp;v);
            add_edge(u, v);
            add_edge(v, u);
        }
        dfs(0, -1);
        int ans = 0;
        for (int i = 0; i &lt; n; ++i) ans = max(ans, dp[i][m]);
        printf(&quot;%d\n&quot;, ans);
    }
}
</code></pre>

                        </div>
                        <div class="post-toc">
                            <ul class="markdownIt-TOC">
<li>
<ul>
<li>
<ul>
<li><a href="#%E6%89%80%E8%B0%93%E6%A0%91%E5%BD%A2dp">所谓树形DP</a></li>
<li><a href="#%E5%85%A5%E9%97%A8%E9%83%A8%E5%88%86">入门部分</a>
<ul>
<li><a href="#poj-2342-anniversary-party">POJ - 2342 - Anniversary party</a>
<ul>
<li><a href="#%E9%A2%98%E6%84%8F">题意</a></li>
<li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li>
<li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li>
</ul>
</li>
<li><a href="#hdu-1520-anniversary-party">HDU - 1520 - Anniversary party</a>
<ul>
<li><a href="#%E9%A2%98%E6%84%8F-2">题意</a></li>
<li><a href="#%E6%80%9D%E8%B7%AF-2">思路</a></li>
<li><a href="#%E4%BB%A3%E7%A0%81-2">代码</a></li>
</ul>
</li>
<li><a href="#hdu-2196-computer">HDU - 2196 - Computer</a>
<ul>
<li><a href="#%E9%A2%98%E6%84%8F-3">题意</a></li>
<li><a href="#%E6%80%9D%E8%B7%AF-3">思路</a></li>
<li><a href="#%E4%BB%A3%E7%A0%81-3">代码</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E7%AE%80%E5%8D%95%E9%A2%98%E5%A5%97%E8%B7%AF%E9%A2%98">简单题（套路题）</a>
<ul>
<li><a href="#codeforces-219d-choosing-capital-for-treeland">CodeForces - 219D - Choosing Capital for Treeland</a>
<ul>
<li><a href="#%E9%A2%98%E6%84%8F-4">题意</a></li>
<li><a href="#%E6%80%9D%E8%B7%AF-4">思路</a></li>
<li><a href="#%E4%BB%A3%E7%A0%81-4">代码</a></li>
</ul>
</li>
<li><a href="#poj-3107-godfather">POJ - 3107 - Godfather</a>
<ul>
<li><a href="#%E9%A2%98%E6%84%8F-5">题意</a></li>
<li><a href="#%E6%80%9D%E8%B7%AF-5">思路</a></li>
<li><a href="#%E4%BB%A3%E7%A0%81-5">代码</a></li>
</ul>
</li>
<li><a href="#poj-2378-tree-cutting">POJ - 2378 - Tree Cutting</a>
<ul>
<li><a href="#%E9%A2%98%E6%84%8F-6">题意</a></li>
<li><a href="#%E6%80%9D%E8%B7%AF-6">思路</a></li>
<li><a href="#%E4%BB%A3%E7%A0%81-6">代码</a></li>
</ul>
</li>
<li><a href="#poj-3140-contestants-division">POJ - 3140 - Contestants Division</a>
<ul>
<li><a href="#%E9%A2%98%E6%84%8F-7">题意</a></li>
<li><a href="#%E6%80%9D%E8%B7%AF-7">思路</a></li>
<li><a href="#%E4%BB%A3%E7%A0%81-7">代码</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E9%9A%BE%E9%A2%98">难题</a>
<ul>
<li><a href="#hdu-5834-magic-boy-bi-luo-with-his-excited-tree">HDU - 5834 - Magic boy Bi Luo with his excited tree</a>
<ul>
<li><a href="#%E9%A2%98%E6%84%8F-8">题意</a></li>
<li><a href="#%E6%80%9D%E8%B7%AF-8">思路</a></li>
<li><a href="#%E4%BB%A3%E7%A0%81-8">代码</a></li>
</ul>
</li>
<li><a href="#poj-2152-fire">POJ - 2152 - Fire</a>
<ul>
<li><a href="#%E9%A2%98%E6%84%8F-9">题意</a></li>
<li><a href="#%E6%80%9D%E8%B7%AF-9">思路</a></li>
<li><a href="#%E4%BB%A3%E7%A0%81-9">代码</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E5%85%B6%E4%BB%96%E5%A5%BD%E9%A2%98">其他好题</a>
<ul>
<li><a href="#hdu-3586-information-disturbing">HDU - 3586 - Information Disturbing</a>
<ul>
<li><a href="#%E9%A2%98%E6%84%8F-10">题意</a></li>
<li><a href="#%E6%80%9D%E8%B7%AF-10">思路</a></li>
<li><a href="#%E4%BB%A3%E7%A0%81-10">代码</a></li>
</ul>
</li>
<li><a href="#zoj-3201-tree-of-tree">ZOJ - 3201 - Tree of Tree</a>
<ul>
<li><a href="#%E9%A2%98%E6%84%8F-11">题意</a></li>
<li><a href="#%E6%80%9D%E8%B7%AF-11">思路</a></li>
<li><a href="#%E4%BB%A3%E7%A0%81-11">代码</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

                        </div>
                        <section class="post-copyright en">
                            <!--en-->
                            <p class="copyright-item">
                                <span>Author:</span>
                                <span>拭微</span>
                            </p>

                            <p class="copyright-item">
                                <span>Permalink:</span>
                                <span><a href="https://wzhzzmzzy.github.io/post/2017-08-07-树形DP入门">https://wzhzzmzzy.github.io/post/2017-08-07-树形DP入门</a></span>
                            </p>

                            <p class="copyright-item">
                                <span>License:</span>
                                <span>MIT License</span>
                            </p>
                        </section>
                        <section class="post-copyright zh">
                            <!--zh-->
                            <p class="copyright-item ">
                                <span>&#x4F5C;&#x8005;:</span>
                                <span>拭微</span>
                            </p>

                            <p class="copyright-item">
                                <span>&#x6C38;&#x4E45;&#x94FE;&#x63A5;:</span>
                                <span><a href="https://wzhzzmzzy.github.io/post/2017-08-07-树形DP入门">https://wzhzzmzzy.github.io/post/2017-08-07-树形DP入门</a></span>
                            </p>

                            <p class="copyright-item">
                                <span>&#x534F;&#x8BAE;:</span>
                                <span>MIT License</span>
                            </p>
                        </section>
                        <!--en-->
                        <section class="post-tags en">
                            <div>
                                <span>Tag(s):</span>
                                <span class="tag">
                                
                                
                                <a href="https://wzhzzmzzy.github.io/tag/G3FWMuzW0"># ACM-ICPC</a>
                                
                                
                            </span>
                            </div>
                            <div>
                                <a href="javascript:window.history.back();">back</a>
                                <span>&dot;</span>
                                <a href="#">home</a>
                            </div>
                        </section>
                        <!--zh-->
                        <section class="post-tags zh">
                            <div>
                                <span>&#x6807;&#x7B7E;:</span>
                                <span class="tag">
                                
                                
                                <a href="https://wzhzzmzzy.github.io/tag/G3FWMuzW0"># ACM-ICPC</a>
                                
                                
                            </span>
                            </div>
                            <div>
                                <a href="javascript:window.history.back();">
                                &#x8FD4;&#x56DE;</a>
                                <span>&dot;</span>
                                <a href="#">&#x4E3B;&#x9875;</a>
                            </div>
                        </section>
                        <section class="post-nav">
                            
                                <a class="prev" rel="prev" href="https://wzhzzmzzy.github.io/post/2017-08-11-2017多校第六场补题记录">
                                    2017多校第六场补题记录
                                </a>
                                
                                    
                                        <a class="next" rel="next" href="https://wzhzzmzzy.github.io/post/2017-08-04-Let-s-Do-It">
                                            Let&#39;s Do It
                                        </a>
                                        
                        </section>
                    </article>
                </div>
                
            </div>
    </div>
    </div>
    </div>
    
    <div id="player"></div>
    
        <footer id="footer" class="footer">

            <div class="copyright">
                <!-- <div class="Like">
                    <div class="tip" data-tooltip="Do you like it?">
                        <a href="https://github.com/ITJoker233/Gridea-theme-Chic" target="_blank" title=""><svg class="icon"
                        aria-hidden="true">
                        <use xlink:href="#like"></use>
                    </svg><b class="like_text" id="star"></b></a>
                    </div>
                </div> -->
                
                    <b id="hitokoto"></b><br>
                    <!-- <svg viewBox="0 0 1024 1024" style="margin-left: 5px;margin-right: 5px;" version="1.0" width="8" height="8" class="my-face">
            <path
                d="M863.597631 513.574282l-271.33965-140.213484L729.783667 81.926656c3.583731-7.87141 7.167462-15.742819 7.167462-25.214109C736.887134 25.226908 708.345275 0.012799 672.635953 0.012799a63.611229 63.611229 0 0 0-39.293053 12.607055c-1.791866 1.59988-3.519736 3.19976-5.311602 3.19976L147.87531 418.925381a55.547834 55.547834 0 0 0-19.646527 47.356448c1.791866 17.278704 14.27093 33.021523 32.125591 42.492813l271.33965 141.749369L292.504463 945.221908c-12.479064 25.214109-1.791866 53.563983 23.166262 69.306802 10.751194 6.335525 23.230258 9.47129 35.709322 9.47129 16.062795 0 32.125591-4.735645 44.604655-15.742819l480.091993-403.297753a55.547834 55.547834 0 0 0 19.646526-47.228458 61.243407 61.243407 0 0 0-32.12559-44.156688z"
                fill="#93b5cf"></path>
        </svg> -->
                    拭微 &copy;Copyright
                        <script>
                            var date = new Date();
                            document.write("" + date.getFullYear());
                        </script>
                        <!-- | Powered by <a href="https://coding.net" target="_blank">Coding.net</a> -->
            </div>
            <div id="update" style="display:none;">
                on
            </div>
            
                <div id="version" style="display:none;">
                    1.6.2
                </div>
                
                    <script>
                        var pat = '';
                        
                        document.write('<div id="home_path" style="display:none;">' + document.location.protocol + '//' + window.document.location.hostname + pat + '</div>')
                    </script>

        </footer>
        
            <script src='https://cdn.jsdelivr.net/npm/live2d-widget@3.x/lib/L2Dwidget.min.js'></script>
            
                <script>
                    

                    function LoadPlayer() {
                        var audio_name = 'きっとまたいつか';
                        var audio_artist = 'DEPAPEPE';
                        var audio_url = 'http://music.163.com/song/media/outer/url?id=22688472.mp3';
                        var audio_cover = 'https://p3fx.kgimg.com/stdmusic/20150718/20150718063022611128.jpg';
                        const ap = new APlayer({
                            container: document.getElementById('player'),
                            fixed: true,
                            audio: [{
                                name: audio_name,
                                artist: audio_artist,
                                url: audio_url,
                                cover: audio_cover,
                            }]
                        });
                    }
                    LoadPlayer();
                    
                    
                    loadlive2d();
                    
                    // hitokoto();
                    getStar();
                    hljs.initHighlighting();
                    console.clear();
                    
                    CheckVersion();
                    
                    console.log("\n %c \u26a1Theme:Chic Author's Blog:https://blog.itjoker.cn  Write By ITJoker  \n\n", "color: #ffffff; background: rgba(49, 49, 49, 0.85); padding:5px 0;border-radius:5px;");
                </script>
        </div>
</body>
<script>
    scroll();
</script>

</html>