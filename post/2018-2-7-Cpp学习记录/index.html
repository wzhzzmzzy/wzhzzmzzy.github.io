<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8" />
<title>
    拭微
</title>
<meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport" />
<meta http-equiv="x-dns-prefetch-control" content="on">
<link rel="dns-prefetch" href="https://wzhzzmzzy.github.io">
<link rel="dns-prefetch" href="https://cdn.bootcss.com">
<link rel="dns-prefetch" href="https://cdn.jsdelivr.net">
<meta name="author" content="Amber">
<meta name="description" content="一直尝试变得更有趣的阿宅">
<meta name="keywords" content="">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/itjoker233/Gridea-theme-Chic@latest/assets/media/css/style.min.css" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/itjoker233/Gridea-theme-Chic@latest/cdn/main.css" />
<!--<link rel="stylesheet" href="https://wzhzzmzzy.github.io/media/css/style.min.css" />
<link rel="stylesheet" href="https://wzhzzmzzy.github.io/styles/main.css" />-->
<link href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.css" rel="stylesheet">

    <script src="https://cdn.jsdelivr.net/npm/aplayer@1.10.0/dist/APlayer.min.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10.0/dist/APlayer.min.css">
    
        <script type="text/javascript" src="https://apps.bdimg.com/libs/jquery/1.7.1/jquery.min.js"></script>
        <script src="https://cdn.jsdelivr.net/gh/itjoker233/Gridea-theme-Chic@latest/assets/media/script/tocbot.min.js"></script>
        <script src="https://cdn.jsdelivr.net/gh/itjoker233/Gridea-theme-Chic@latest/assets/media/script/script.min.js"></script>
        <script src="https://cdn.jsdelivr.net/gh/itjoker233/Gridea-theme-Chic@latest/assets/media/script/icon.min.js"></script>
        <!--<script src="https://wzhzzmzzy.github.io/media/script/tocbot.min.js"></script>
        <script src="https://wzhzzmzzy.github.io/media/script/script.min.js"></script>
        <script src="https://wzhzzmzzy.github.io/media/script/icon.min.js"></script>-->
        <script src="https://cdn.bootcss.com/highlight.js/9.13.1/highlight.min.js"></script>
        <link href="https://cdn.bootcss.com/highlight.js/9.13.1/styles/atelier-estuary-dark.min.css" rel="stylesheet">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.1/dist/katex.min.css">
        <script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.1/dist/katex.min.js"></script>
        
            <script>
                (function() {
                    var bp = document.createElement('script');
                    var curProtocol = window.location.protocol.split(':')[0];
                    if (curProtocol === 'https') {
                        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
                    } else {
                        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
                    }
                    var s = document.getElementsByTagName("script")[0];
                    s.parentNode.insertBefore(bp, s);
                })();
            </script>
            
                
</head>

<body>
    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo">
                <a href="https://wzhzzmzzy.github.io">
                    拭微
                </a>
            </div>

            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/">
                        首页
                    </a>
                    
                    <a class="menu-item" href="/archives">
                        归档
                    </a>
                    
                    <a class="menu-item" href="/tags">
                        标签
                    </a>
                    
                    <a class="menu-item" href="/post/about">
                        关于
                    </a>
                    
                        <input id="switch_default" type="checkbox" class="switch_default">
                        <label for="switch_default" class="toggleBtn"></label>
            </div>
            <form id="gridea-search-form" data-update="1579927857513" action="/search/index.html">
                <input class="search-input" autocomplete="off" spellcheck="false" name="q" autofocus="true" placeholder="Search...">
            </form>
        </div>
    </nav>

    
        <nav class="navbar-mobile" id="nav-mobile">
            <div class="container">
                <div class="navbar-header">
                    <div>
                        <a href="https://wzhzzmzzy.github.io">
                            拭微
                        </a>
                        <!--en-->
                        <a id="mobile-toggle-theme-en" class="a en">&nbsp;Dark</a>
                        <!--zh-->
                        <a id="mobile-toggle-theme-zh" class="a zh">&nbsp;\u6697\u9ED1</a>
                    </div>
                    <form id="gridea-search-form" data-update="1579927857513" action="/search/index.html">
                        <input class="search-input" autocomplete="off" spellcheck="false" name="q" autofocus="true" placeholder="Search...">
                    </form>
                    <!--en-->
                    <div class="menu-toggle" id="menu-toggle-en" onclick="mobileBtn()">&#9776; Menu</div>
                    <!--zh-->
                    <div class="menu-toggle" id="menu-toggle-zh" onclick="mobileBtn()">&#9776; &#x83DC;&#x5355;</div>

                </div>
                <div class="menu" id="mobile-menu">
                    
                        <a class="menu-item" href="/">
                            首页
                        </a>
                        
                        <a class="menu-item" href="/archives">
                            归档
                        </a>
                        
                        <a class="menu-item" href="/tags">
                            标签
                        </a>
                        
                        <a class="menu-item" href="/post/about">
                            关于
                        </a>
                        
                </div>
            </div>
        </nav>
</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementById("menu-toggle-en");
        var toggleMenu_zh = document.getElementById("menu-toggle-zh");

        var mobileMenu = document.getElementById("mobile-menu");
        if (toggleMenu.display != "none") {
            if (toggleMenu.classList.contains("active")) {
                toggleMenu.classList.remove("active")
                mobileMenu.classList.remove("active")
            } else {
                toggleMenu.classList.add("active")
                mobileMenu.classList.add("active")
            }
        } else if (toggleMenu_zh.display != "none") {
            if (toggleMenu_zh.classList.contains("active")) {
                toggleMenu_zh.classList.remove("active")
                mobileMenu.classList.remove("active")
            } else {
                toggleMenu_zh.classList.add("active")
                mobileMenu.classList.add("active")
            }
        }

    }
</script>
            <div class="main">
                <div class="container">
                    <article class="post-wrap">
                        <header class="post-header">
                            <h1 class="post-title">
                                C++ 学习记录（二）—— 泛型编程入门及智能指针
                            </h1>
                            <!--en-->
                            <div class="post-meta en">
                                Author:
                                <a itemprop="author" rel="author" href="/">
                                    拭微
                                </a>
                                <span class="post-time">
                                Date: <a href="#">2018-02-07</a>
                            </span>
                                <span class="post-readtime">Reading Time:<a href="#">28.1 mins</a></span>
                                <span class="post-words">words:<a href="#">7475</a></span>
                                
                                    <span class="post-category">
                                Category:
                                
                                <a href="https://wzhzzmzzy.github.io/tag/cDUFQDRC3M">C++</a>
                                
                            </span>
                                    
                            </div>
                            <!--zh-->
                            <div class="post-meta zh">
                                &#x4F5C;&#x8005;:
                                <a itemprop="author" rel="author" href="/">
                                    拭微
                                </a>
                                <span class="post-time">&#x65E5;&#x671F;: <a href="#">2018-02-07</a></span>
                                <span class="post-readtime">&#x9605;&#x8BFB;&#x65F6;&#x95F4;:<a href="#">28.1 &#x5206;&#x949F;</a></span>
                                <span class="post-words">&#x5B57;&#x6570;:<a href="#">7475</a></span>
                                
                                    <span class="post-category">&#x5206;&#x7C7B;:
                                
                                <a href="https://wzhzzmzzy.github.io/tag/cDUFQDRC3M">C++</a>
                                
                            </span>
                                    
                            </div>
                        </header>
                        <div class="post-content">
                            <h3 id="泛型算法">泛型算法</h3>
<p>大多数泛型算法保存在<code>&lt;algorithm&gt;</code></p>
<h4 id="accumulate"><code>accumulate</code></h4>
<pre><code class="language-cpp">accumulate(vec.cbegin(), vec.cend(), 0);
// 迭代求和，初始值为0
// 通过 + 运算符求和
</code></pre>
<h4 id="equal"><code>equal</code></h4>
<pre><code class="language-cpp">equal(v1.cbegin(), v1.cend(), v2.cbegin());
// 比较输入的迭代器之间的内容是否全部对应相等
// 通过 == 运算符计算
</code></pre>
<h4 id="fill"><code>fill</code></h4>
<pre><code class="language-cpp">fill(vec.begin(), vec.end(), 0);
// 在迭代器范围内填充
</code></pre>
<h4 id="file_n"><code>file_n</code></h4>
<pre><code class="language-cpp">file_n(vec.begin(), vec.size(), 0)
// 在迭代器之后填充固定数量
</code></pre>
<h4 id="back_inserter"><code>back_inserter</code></h4>
<pre><code class="language-cpp">vector&lt;int&gt; vec;
auto it = back_inserter(vec);
*it = 42;
// 每次调用 it 相当于调用 push_back
</code></pre>
<h4 id="copy"><code>copy</code></h4>
<pre><code class="language-cpp">int a1[] = {0, 1, 2, 3};
int a2[sizeof(a1)/sizeof(*a1)];
auto ret = copy(begin(a1), end(a1), a2);
// copy 返回拷贝之后的位置
</code></pre>
<h4 id="unique"><code>unique</code></h4>
<pre><code class="language-cpp">auto end_unique = unique(words.begin(), words.end());
// unique 返回去重后的尾端
// 需要保证重复位置是连续的
</code></pre>
<h4 id="erase"><code>erase</code></h4>
<pre><code class="language-cpp">words.erase(end_unique, words.end());
// 删除容器迭代器之间的位置
</code></pre>
<h4 id="sort"><code>sort</code></h4>
<pre><code class="language-cpp">sort(words.begin(), words.end());
sort(words.begin(), words.end(), cmp);
stable_sort(words.begin(), words.end());
// sort 为不稳定排序
// stable_sort 为稳定排序
</code></pre>
<h4 id="transform"><code>transform</code></h4>
<pre><code class="language-cpp">transform(v.begin(), v.end(), v.begin(), f);
// 对前两个迭代器之间的所有元素调用 f
// 结果填充到第三个迭代器的位置
</code></pre>
<h4 id="find_if"><code>find_if</code></h4>
<pre><code class="language-cpp">auto wc = find_if(words.begin(), words.end(), cmp);
// 返回迭代器，指向第一个满足 cmp 的元素
</code></pre>
<h4 id="for_each"><code>for_each</code></h4>
<pre><code class="language-cpp">for_each(wc, words_end(), f);
// 对迭代器之间的所有元素，调用 f
</code></pre>
<h4 id="lambda表达式"><code>lambda</code>表达式</h4>
<pre><code class="language-cpp">auto cmp = [](const string &amp;a, const string &amp;b)
    { return a.size() &lt; b.size(); }
bool isShort(const string &amp;a, const string &amp;b) {
    return a.size() &lt; b.size();
}
// 这两个函数等价
</code></pre>
<p><code>lambda</code>表达式包含<code>[捕获列表]</code>，<code>(参数列表)</code>以及<code>{函数体}</code>。</p>
<p>捕获列表意为<code>lambda</code>表达式内部需要使用的外部函数局部变量。如果未捕获，那么表达式内部就无法使用。</p>
<p>一般的捕获为值捕获，即<code>lambda</code>表达式会获取一个变量的值拷贝。同样可以通过引用来获取捕获。当使用流时，会需要使用到引用捕获。</p>
<p>可以直接在<code>lambda</code>表达式中使用变量而不需要在捕获列表中声明。此时需要在捕获列表中说明是值捕获（<code>=</code>）还是引用捕获（<code>&amp;</code>）。隐式捕获和显式捕获可以共存。</p>
<pre><code class="language-cpp">[&amp;, c] (const string &amp;s) { os &lt;&lt; s &lt;&lt; c; }
[=, &amp;os] (const string &amp;s) { os &lt;&lt; s &lt;&lt; c; }
</code></pre>
<p>当混合使用显式捕获和隐式捕获时，捕获列表第一个参数必须是<code>&amp;</code>或者<code>=</code>，它指定了默认捕获方式。</p>
<p>如果要改变捕获的参数值，那么就需要声明<code>mutable</code>。</p>
<pre><code class="language-cpp">[v1] () mutable { return ++v1; }
</code></pre>
<p>如果一个<code>lambda</code>体包含<code>return</code>之外的语句，那么编译器就假定其返回<code>void</code>。</p>
<pre><code class="language-cpp">[] (int i) { return i &lt; 0 ? -i : i; } // 无错误
[] (int i) {
    if (i &lt; 0) return -i;
    else return i;
} // 报错
[] (int i) -&gt; int {
    if (i &lt; 0) return -i;
    else return i;
} // 正确
</code></pre>
<h4 id="bind"><code>bind</code></h4>
<p><code>bind</code>声明于<code>&lt;placeholders&gt;</code>。</p>
<p><code>bind</code>接受一个可调用对象和一个参数列表，生成一个新的可调用对象。使用<code>bind</code>函数，可以将函数柯里化。</p>
<pre><code class="language-cpp">auto nf = bind(f, _2, _1, arg);
</code></pre>
<p>其中的<code>_1</code>，<code>_2</code>是占位符，表示<code>f</code>所需要的第一个、第二个参数。绑定之后，调用<code>nf</code>时会需要两个参数，按照<code>bind</code>的顺序填入占位符当中。也就是说<code>nf(_1, _2)</code>等价于<code>f(_2, _1, arg)</code>。</p>
<p>但是要注意一下，<code>bind</code>直接接受的参数为值传递，如果要传递引用的话需要使用到<code>ref</code>函数。</p>
<pre><code class="language-cpp">bind(print, ref(os), _1, ' ');
</code></pre>
<h4 id="迭代器">迭代器</h4>
<p>除了每个容器自己的迭代器之外，还定义了额外几种迭代器。</p>
<ul>
<li><strong>插入迭代器</strong>：绑定到容器上，用于插入元素。</li>
<li><strong>流迭代器</strong>：绑定到流上，用来遍历所关联的IO流。</li>
<li><strong>反向迭代器</strong>：向后而不是向前移动的迭代器，除了<code>forward_list</code>之外的容器都有。</li>
<li><strong>移动迭代器</strong>：不用于拷贝元素，而是移动它们。</li>
</ul>
<h5 id="插入迭代器">插入迭代器</h5>
<p>插入器是一种迭代器适配器，接受一个容器，生成一个迭代器，能给容器添加元素。当对一个插入迭代器赋值时，这个迭代器调用容器操作来给指定容器的指定位置插入一个元素。</p>
<ul>
<li><code>back_inserter</code>，创建一个使用<code>push_back</code>的迭代器。</li>
<li><code>front_inserter</code>，创建一个使用<code>push_front</code>的迭代器。</li>
<li><code>inserter</code>，创建一个使用<code>insert</code>的迭代器。这个函数接受第二个参数，插入到给定迭代器所表示的元素之前。</li>
</ul>
<p><code>inserter</code>的行为如下。</p>
<pre><code class="language-cpp">auto it = inserter(c, iter);
*it = val; // 这一行等同于下面两行
it = c.insert(it, val);
++it;
</code></pre>
<p><code>front_inserter</code>与<code>inserter</code>完全不同。</p>
<pre><code class="language-cpp">list&lt;int&gt; lst = {1, 2, 3, 4};
list&lt;int&gt; lst2, lst3; // 空
copy(lst.cbegin(), lst.cend(), front_inserter(lst2));
copy(lst.cbegin(), lst.cend(), inserter(lst3, lst3.begin()));
// lst2 4 3 2 1
// lst3 1 2 3 4
</code></pre>
<h5 id="iostream迭代器"><code>iostream</code>迭代器</h5>
<pre><code class="language-cpp">istream_iterator&lt;int&gt; int_it(cin); // 从 cin 读取 int
istream_iterator&lt;int&gt; int_eof; // 尾后迭代器
ifstream in(&quot;afile&quot;);
istream_iterator&lt;string&gt; str_it(in); // 从 afile 读取字符串
while (int_it != int_eof)
    vec.push_back(*in_iter++);
</code></pre>
<p>空的<code>istream_iterator</code>可以作为尾后迭代器来使用。一个绑定到流的迭代器，当遇到<code>EOF</code>或者 IO 错误时，值就与尾后迭代器相等。</p>
<p>使用流迭代器可以构造容器。</p>
<pre><code class="language-cpp">istream_iterator&lt;int&gt; in_iter(cin), eof;
vector&lt;int&gt; vec(in_iter, eof);
</code></pre>
<p><strong><code>istream_iterator</code>允许惰性求值</strong>。</p>
<p>我们可以对任何具有输出运算符的类型定义<code>ostream_iterator</code>。当创建时，必须要绑定一个流，不允许空的<code>ostream_iterator</code>。创建时，可以提供可选的第二参数，它是一个 C 风格字符串，每次输出一个元素后都会打印这个字符串。</p>
<pre><code class="language-cpp">ostream_iterator&lt;int&gt; out_iter(cout, &quot; &quot;);
for (auto e: vec)
    *out_iter++ = e;
cout &lt;&lt; endl;
</code></pre>
<p>事实上，<code>*out_iter++</code>完全可以被替换为<code>out_iter</code>，但是保持解引用和自增运算符可以与其他的迭代器使用保持一致，可以更加方便地替换为其他迭代器类型。</p>
<h5 id="反向迭代器">反向迭代器</h5>
<p>对于反向迭代器，递增（<code>++</code>）会移动到前一个元素，递减（<code>--</code>）会移动到下一个元素。</p>
<p>调用<code>base()</code>可以转换为普通迭代器。</p>
<h4 id="泛型算法结构">泛型算法结构</h4>
<p>任何算法的最基本特征是它要求其迭代器提供那些操作。某些算法，如<code>find</code>，只要求通过迭代器访问元素、递增迭代器以及比较两个迭代器是否相等这些能力。其他算法还要求读、写和随机访问。迭代器按照这些分为五类。</p>
<ul>
<li>输入迭代器；</li>
<li>输出迭代器；</li>
<li>前向迭代器；</li>
<li>双向迭代器；</li>
<li>随机访问迭代器。</li>
</ul>
<h3 id="关联容器">关联容器</h3>
<p>关联容器中的元素是按照关键字来保存和访问的。与之相对的，顺序容器中的元素是按照它们在容器中的位置来顺序保存和访问的。</p>
<p>关联容器支持高校的关键字查找和访问。两个主要的关联容器的<code>map</code>和<code>set</code>。<code>map</code>中的元素是一些<code>key-value</code>对，<br>
<code>set</code>只包含一个关键字，支持高效的查询操作。</p>
<p>共有八个关联容器，有三个条件。</p>
<ul>
<li><code>set</code>或<code>map</code>；</li>
<li>关键字可重复或不可重复，<code>multi</code>；</li>
<li>保存元素按顺序或无序，<code>unordered_</code>。</li>
</ul>
<p>无序集合是由哈希表构成，有序集合由红黑树构成。</p>
<p>有序集合所使用的类型必须存在比较函数，或者<code>&lt;</code>运算符。如果需要使用比较函数来定义，那么就需要一个函数指针参数。</p>
<pre><code class="language-cpp">multiset&lt;className, decltype(cmp)*&gt; mp(cmp);
</code></pre>
<h4 id="pair"><code>pair</code></h4>
<p><code>pair</code>类型在<code>&lt;utility&gt;</code>中。一个<code>pair</code>保存两个数据成员，类似于容器，<code>pair</code>是一个用来生成特定类型的模板，当创建一个<code>pair</code>时，我们必须提供两个类型名，<code>pair</code>的数据成员将具有对应的类型。</p>
<pre><code class="language-cpp">pair&lt;string, int&gt; author{&quot;Amber&quot;, 12};
</code></pre>
<p>与其他标准库类型不同，<code>pair</code>的数据成员是<code>public</code>的，两个成员分别命名为<code>first</code>和<code>second</code>。</p>
<p>对于一个需要返回<code>pair</code>对象的函数，可以对返回值进行列表初始化。</p>
<pre><code class="language-cpp">pair&lt;string, int&gt; process(vector&lt;string&gt; &amp;v) {
    if (!v.empty())
        return {v.back(), v.back().size()};
    else
        return pair&lt;string, int&gt;();
}
</code></pre>
<p>也可以用<code>make_pair</code>函数来构造<code>pair</code>对象，类型自动判定。</p>
<pre><code class="language-cpp">make_pair(v.back(), v.back().size());
</code></pre>
<h4 id="关联容器操作">关联容器操作</h4>
<p>关联容器定义了几种类型。</p>
<ul>
<li><code>key_type</code>，关键字的类型。</li>
<li><code>mapped_type</code>，值的类型，<code>set</code>中等同于关键字类型。</li>
<li><code>value_type</code>，在<code>map</code>中为<code>pair&lt;const key_type, mapped_type&gt;</code>，在<code>set</code>中也等同于关键字类型。</li>
</ul>
<h5 id="迭代器-2">迭代器</h5>
<pre><code class="language-cpp">map&lt;string, int&gt; mp;
auto map_it = mp.begin();
// map_it 的类型为 pair&lt;string, int&gt;
set&lt;int&gt; iset = {1, 2, 3, 4};
set&lt;int&gt;::iterator set_it = iset.begin();
// set 的迭代器是 const 的
</code></pre>
<p>可以使用通常的手段遍历迭代器（<code>begin()</code>，<code>end()</code>）。</p>
<h5 id="插入-删除-查询">插入、删除、查询</h5>
<p>对于不可重复容器，插入已存在的元素不会有影响。</p>
<p>插入可以直接使用花括号列表，也可以构造<code>pair</code>对象。</p>
<p><code>insert</code>或者<code>emplace</code>的返回值是一个<code>pair</code>，<code>first</code>是一个迭代器，指向刚才插入的元素，<code>second</code>是一个<code>bool</code>值，返回是否插入成功。</p>
<p>有三个版本的<code>erase</code>，可以传入迭代器、迭代器对，这两个版本返回<code>void</code>。另一个版本接受一个<code>key_type</code>，返回删除的元素数量。</p>
<p><code>map</code>和<code>unordered_map</code>提供了下标运算符和一个对应的<code>at</code>函数。<code>set</code>不支持下标，<code>multimap</code>和<code>unordered_multimap</code>也不可以。</p>
<p><code>map</code>中，下标运算符接受一个关键字，获取与这个关键字相关联的值，与下标运算符不同的是，如果关键字不在<code>map</code>中，会创建一个元素并插入<code>map</code>。但是<code>at</code>运算符只能查询，不能插入。</p>
<p>如果想单纯查询，那么应该使用<code>find</code>方法。</p>
<p>当使用<code>multimap</code>和<code>multiset</code>时，<code>find</code>会返回第一个满足关键字的元素，向后递增就可以获得其他的元素。</p>
<p>查找可以使用<code>lower_bound</code>和<code>upper_bound</code>，这两个方法接受一个关键字，返回一个迭代器。如果关键字存在，那么返回找到的第一个位置和最后一个之后的位置，如果不存在，那么返回插入且不影响排序的位置。</p>
<p>注意<code>lower_bound</code>和<code>upper_bound</code>可能返回尾后迭代器，且只能在有序容器中使用。</p>
<p><code>equal_range</code>等同于同时调用上面两个函数，它返回<code>pair</code>，<code>first</code>指向第一个与关键字匹配的元素，<code>second</code>指向最后一个元素之后的位置。</p>
<h4 id="无序容器">无序容器</h4>
<p>无序容器不使用比较运算符来组织元素，而是使用哈希函数和关键字类型的<code>==</code>运算符。</p>
<p>无序容器在存储上组织为一组桶，每个桶保存零个或者多个元素。容器使用哈希函数将元素映射到桶，为了访问一个元素，首先计算元素的哈希值，指出应该搜索哪个桶。</p>
<p>因此，无序容器的性能依赖于哈希函数的质量和桶的数量和大小。</p>
<p>对于相同的参数，哈希函数必须总是产生相同的结果。</p>
<p>无序容器提供了一系列的哈希管理操作。</p>
<ul>
<li><code>bucket_count()</code>，正在使用的桶数目；</li>
<li><code>max_bucket_count()</code>，容器最多能容纳的桶数目；</li>
<li><code>bucket_size(n)</code>，第<code>n</code>个桶有多少元素；</li>
<li><code>bucket(k)</code>，关键字为<code>k</code>的元素在哪个桶中；</li>
<li><code>local_iterator</code>，桶中元素的迭代器；</li>
<li><code>const_local_iterator</code>；</li>
<li><code>begin(n), end(n)</code>，桶<code>n</code>的迭代器；</li>
<li><code>cbegin(n), cend(n)</code>；</li>
<li><code>load_factor()</code>，桶内元素的平均数量，<code>float</code>类型；</li>
<li><code>max_load_factor()</code>，试图维护的平均桶大小；</li>
<li><code>rehash(n)</code>，暴力重组；</li>
<li><code>reserve(n)</code>，不必<code>rehash</code>地重组。</li>
</ul>
<p>由于使用哈希，所以会使用<code>hash&lt;key_type&gt;</code>来生成哈希值。当使用自定义类型时，就需要提供<code>hash</code>模板，也可以提交重载函数。</p>
<pre><code class="language-cpp">size_t hasher(const Sales_data &amp;sd) {
    return hash&lt;string&gt;() (sd.isbn());
}

bool eqOp(const Salse_data &amp;l, const Salse_data &amp;r) {
    return l.isbn() == r.isbn();
}

unordered_multiset&lt;Sales_data, decltype(hasher)*, decltype(eqOp)*&gt; bookSt(42, hasher, eqOp)&gt;;
</code></pre>
<h3 id="动态内存">动态内存</h3>
<p>全局对象在程序启动时分配内存，在程序结束时销毁，局部自动对象在进入代码块时创建，离开时销毁。局部<code>static</code>对象在第一次使用前分配，在程序结束时销毁。</p>
<p>除了自动对象和<code>static</code>对象之外，还支持动态分配对象。</p>
<p>静态内存用于保存局部<code>static</code>对象，类<code>static</code>数据成员，以及定义在任何函数之外的变量。栈内存用来保存定义在函数内的<code>static</code>对象。这两块内存中的对象由编译器自动创建和销毁。</p>
<p>程序还存在一个内存池，称为堆。用于存储动态分配的对象。</p>
<h4 id="动态内存与智能指针">动态内存与智能指针</h4>
<p><code>new</code>用于分配空间，返回一个指向这个对象的指针，<code>delete</code>接受一个动态对象的指针，销毁该对象，释放内存。</p>
<p>为了更容易也更安全地使用动态内存，C++11提供了两种智能指针，它们负责自动释放所指向的对象。</p>
<p><code>shared_ptr</code>允许多个指针指向同一个对象，<code>unique_ptr</code>独占指向的对象。标准库中还有一个<code>weak_ptr</code>，这是一种弱引用，指向<code>shared_ptr</code>所管理的对象。</p>
<h5 id="智能指针的一般操作">智能指针的一般操作</h5>
<ul>
<li><code>shared_ptr&lt;T&gt; sp</code>，空指针；</li>
<li><code>unique_ptr&lt;T&gt; up</code>；</li>
<li><code>*p</code>，解引用<code>p</code>，获取指向的对象；</li>
<li><code>p</code>，用作条件判断；</li>
<li><code>p.get()</code>，获取指针；</li>
<li><code>swap(p, q), p.swap(q)</code>，交换指针。</li>
</ul>
<h4 id="shared_ptr"><code>shared_ptr</code></h4>
<p>智能指针也是模板，所以需要提供类型。</p>
<pre><code class="language-cpp">shared_ptr&lt;string&gt; p;
</code></pre>
<p>默认初始化的智能指针为<code>nullptr</code>。</p>
<p>使用方式和普通指针相似，解引用时返回指向的对象。</p>
<p>独有操作有以下一些：</p>
<ul>
<li><code>make_shared&lt;T&gt;(args)</code>，返回一个<code>shared_ptr</code>，指向一个动态分配的类型为<code>T</code>的对象；</li>
<li><code>shared_ptr&lt;T&gt; p(q)</code>，制作一个<code>q</code>的拷贝为<code>p</code>；</li>
<li><code>shared_ptr&lt;T&gt; p(u)</code>，从一个<code>unique_ptr</code>处接管指针；</li>
<li><code>shared_ptr&lt;T&gt; p(q, d)</code>，使用可调用对象<code>d</code>来释放指针；</li>
<li><code>p = q</code>；</li>
<li><code>p.unique()</code>，查看是否<code>p</code>的引用计数为 1；</li>
<li><code>p.use_count()</code>，返回<code>p</code>的引用计数，可能很慢；</li>
</ul>
<h5 id="make_shared"><code>make_shared</code></h5>
<p>最安全的分配和使用动态内存的方法是使用<code>make_shared</code>函数，这个函数在动态内存中分配一个对象并初始化它，然后返回指向这个对象的<code>shared_ptr</code>。</p>
<p>类似于<code>emplace</code>，<code>make_shared</code>也使用参数来构造给定的对象。如果不传递任何参数，那么就会进行值初始化。</p>
<h5 id="拷贝-赋值-析构">拷贝、赋值、析构</h5>
<p>拷贝之后，引用计数会增加，重新赋值或者销毁之后，计数器就会递减。一旦引用计数归零，指针会自动释放所管理的对象。</p>
<p>销毁时会使用到析构函数。类似于构造函数，每个类也会有一个析构函数。析构函数用于释放对象所分配的资源。</p>
<h4 id="动态内存的使用">动态内存的使用</h4>
<p>程序使用动态内存出于以下三种原因之一：</p>
<ol>
<li>程序不知道自己需要多少对象；</li>
<li>程序不知道所需对象的准确类型；</li>
<li>程序需要在多个对象之间共享数据。</li>
</ol>
<p>比如容器类，就是因为第一种原因使用动态内存。</p>
<p>但是某些类分配的资源与原对象有相独立的生存期。比如，当一个对象获取另一个对象的拷贝时，希望两个对象共享同一份内存空间中的内容。</p>
<h4 id="直接管理内存">直接管理内存</h4>
<p><code>new</code>和<code>delete</code>能够直接管理内存，但是非常容易出错。</p>
<pre><code class="language-cpp">int *p = new int; // 默认，值未定义
int *pi = new int(); // 值初始化为 0
string *ps = new string(5, '0'); // 值初始化为&quot;00000&quot;
// 可以使用 auto 来创建指针，但是指向必须是单一的初始化器
auto p1 = new auto(obj);
// 用 new 分配 const 对象是合法的
const int *pci = new const int(1024);
// 当内存耗尽时，会抛出 bad_alloc 异常。可以使用定位 new 来阻止抛出异常
// 定位 new 表达式允许传递额外的参数。nothrow 就是一个标准库中的对象
int *p = new (nothrow) int; // 如果分配失败，会返回一个空指针
</code></pre>
<p><code>delete</code>将动态内存归还给系统。表达式接受一个指针，表示想要释放的对象。</p>
<pre><code class="language-cpp">delete p;
</code></pre>
<p>当<code>delete</code>之后，指针的值就无效了，但是很多时候指针依然保存着之前的地址，<code>delete</code>之后，指针就变为了空悬指针。所以应该在指针要离开作用域之前释放内存，或者在释放内存之后用<code>nullptr</code>赋予指针。</p>
<h4 id="结合使用shared_ptr和new">结合使用<code>shared_ptr</code>和<code>new</code></h4>
<p>我们可以使用<code>new</code>返回的指针来初始化智能函数。</p>
<pre><code class="language-cpp">shared_ptr&lt;int&gt; p2(new int(42));
</code></pre>
<p>接受指针参数的智能指针构造函数是<code>explicit</code>的，因此必须使用直接初始化形式来初始化一个智能指针，而不能赋值。出于相同的原因，返回语句中不能隐式转换一个普通指针。</p>
<p><code>shared_ptr</code>提供了<code>get</code>方法，这个方法返回一个内置指针，用于向不能使用智能指针的代码传递内置指针。使用<code>get</code>方法生成的指针不能被<code>delete</code>，也不能被用于再初始化一个智能指针。</p>
<p><code>reset</code>可以将<code>shared_ptr</code>指向一个新对象。</p>
<h4 id="unique_ptr"><code>unique_ptr</code></h4>
<p>与<code>shared_ptr</code>不同，同一时刻只能有一个<code>unique_ptr</code>指向一个给定对象。当指针被销毁时，指向的对象也被销毁。<code>unique_ptr</code>没有<code>make_shared</code>这样的方法，当定义时，必须绑定一个<code>new</code>返回的指针。</p>
<p>一般操作：</p>
<ul>
<li><code>unique_ptr&lt;T&gt; u1</code>；</li>
<li><code>unique_ptr&lt;T, D&gt; u2(d)</code>，使用<code>D</code>类型的<code>d</code>来释放指针；</li>
<li><code>u = nullptr</code>；</li>
<li><code>release()</code>，返回指针，放弃指针控制权，置为空；</li>
<li><code>reset()</code>，释放对象；</li>
<li><code>reset(q)</code>，重置指针；</li>
<li><code>reset(nullptr)</code>；</li>
</ul>
<p>可以拷贝或者赋值一个将要销毁的<code>unique_ptr</code>，一般使用在函数返回值时。</p>
<h4 id="weak_ptr"><code>weak_ptr</code></h4>
<p><code>weak_ptr</code>不控制只想对象生存期。它指向一个<code>shared_ptr</code>管理的对象。将一个<code>weak_ptr</code>绑定到一个<code>shared_ptr</code>不会改变引用计数。一旦最后一个指向对象的<code>shared_ptr</code>被销毁，对象就会被释放。</p>
<p>一般操作。</p>
<ul>
<li><code>reset()</code>，重置；</li>
<li><code>use_count()</code>，引用计数；</li>
<li><code>expired()</code>，查看是否引用为 0；</li>
<li><code>lock()</code>，返回引用的<code>shared_ptr</code>。</li>
</ul>
<h3 id="拷贝控制">拷贝控制</h3>
<h4 id="拷贝构造函数">拷贝构造函数</h4>
<p>很多时候编译器会隐式地调用类的拷贝构造函数。</p>
<p>拷贝构造函数的第一个参数必须是引用类型，一般是<code>const</code>的引用。其他的额外参数都有默认值。由于会被隐式调用，所以通常不应该是<code>explicit</code>的。</p>
<p>类类型的成员会使用拷贝构造函数来拷贝，内置类型的成员则直接拷贝。</p>
<p>直接初始化就是直接调用构造函数，拷贝初始化是对一个新定义的对象用赋值符号进行初始化。拷贝初始化一般使用拷贝构造函数，有时也会使用移动构造函数来完成。</p>
<p>除了使用<code>=</code>定义变量时，在以下情况也会发生拷贝初始化。</p>
<ul>
<li>将一个对象作为实参传递给一个非引用类型的实参；</li>
<li>从一个返回类型为非引用类型的函数返回一个对象；</li>
<li>用花括号列表初始化一个数组中的元素，或者一个聚合类的成员。</li>
</ul>
<p>某些类类型还会对它们分配的对象使用拷贝初始化，比如<code>insert</code>和<code>push</code>方法，相对的，<code>emplace</code>使用直接初始化。</p>
<h4 id="拷贝赋值运算符">拷贝赋值运算符</h4>
<p>和拷贝构造函数一样，如果类没有定义自己的拷贝赋值运算符，编译器会为它合成一个。</p>
<pre><code class="language-cpp">Foo&amp; operator=(const Foo&amp;); // 赋值运算符
</code></pre>
<h4 id="析构函数">析构函数</h4>
<p>析构函数的名字由波浪号接类名组成，没有返回值，不接受参数。</p>
<pre><code class="language-cpp">~Foo() { };
</code></pre>
<p>构造函数有一个初始化部分和一个函数体，析构函数也有函数体和析构部分。与构造函数相反，先执行函数体，再进行析构。函数体中执行类的收尾工作。</p>
<p>会执行析构函数的情况有</p>
<ul>
<li>变量离开作用域时被销毁；</li>
<li>对象被销毁时成员也被销毁；</li>
<li>容器被销毁时，其元素被销毁；</li>
<li>对于动态分配的对象，使用<code>delete</code>时被销毁；</li>
<li>临时对象，创建它的完整表达式结束时被销毁；</li>
</ul>
<p>类未定义析构函数时，编译器也会为它定义合成析构函数。对于某些类，合成析构函数被用来阻止该类型对象被销毁，否则，合成析构函数函数体为空。</p>
<h4 id="三五法则">三/五法则</h4>
<p>如果一个类需要析构函数，那么一般也会需要一个拷贝构造函数和一个拷贝赋值运算符。当不需要析构函数时，拷贝和赋值操作也是互相需要的。</p>
<h4 id="使用default">使用<code>=default</code></h4>
<p>使用<code>=default</code>相当于直接要求编译器生成合成的版本。</p>
<pre><code class="language-cpp">class test {
public:
    test() = default;
    test(const test&amp;) = default;
    test&amp; operator=(const test &amp;);
    ~test() = default;
}
</code></pre>
<h4 id="阻止拷贝">阻止拷贝</h4>
<p>有些时候，拷贝没有合理的意义，所以需要阻止。可以定义<strong>删除的函数</strong>来阻止拷贝。删除的函数是指，声明了它们，但是不能使用的函数。在函数的参数列表后面加上<code>=delete</code>来指明为删除的函数。</p>
<p>注意，析构函数不能是删除的成员。如果析构函数是删除的，那么这个类型就不能创建任何形式的对象。</p>
<p>如果一个类有数据成员不能默认构造、拷贝、复制或者销毁，那么对应的成员函数将会被定义为删除的。比如存在<code>const</code>、引用成员或是成员的析构函数是<code>private</code>的。</p>
<h4 id="引用计数的工作方式">引用计数的工作方式</h4>
<ul>
<li>除了初始化对象之外，每一个构造函数（除了拷贝构造函数）还要创建一个引用计数，用来记录有多少对象与正在创建的对象共享状态。当我们创建对象时，只有一个对象共享状态，因此将计数器初始化为 1。</li>
<li>拷贝构造函数不分配行的计数器，而是拷贝给定对象的数据成员，包括计数器。拷贝构造函数递增共享的计数器。</li>
<li>析构函数递减计数器。如果计数器变为 0，则析构函数释放状态。</li>
<li>拷贝赋值运算符递增右侧的计数器，递减左侧的计数器。如果左侧计数器变为 0，那么就必须销毁状态。</li>
</ul>
<p>唯一的难题是确定哪里存放引用计数，因为计数器不能直接作为对象的成员。当创建多个拷贝时，无法对之前的拷贝中的计数器进行修改。</p>
<p>可以使用动态内存创建计数器，这样多个拷贝可以指向同一个计数器。</p>
<h4 id="对象移动">对象移动</h4>
<h5 id="右值引用">右值引用</h5>
<p>右值引用通过<code>&amp;&amp;</code>来获取，它只能绑定到一个将要销毁的对象上。因此，可以将一个右值引用的资源移动到另一个对象中。</p>
<p>右值引用用于绑定<strong>值</strong>，包括要求转换的表达式、字面值常量或者返回右值的表达式。</p>
<p>右值引用只能绑定到临时对象，它所引用的对象将要销毁，而且该对象没有其他用户。使用右值引用的代码可以接管所引用的对象的资源。</p>
<h5 id="stdmove"><code>std::move</code></h5>
<p>这个函数在<code>&lt;utility&gt;</code>中。</p>
<p><code>move</code>告诉编译器，有一个左值，但是希望像右值一样处理它。调用<code>move</code>意味着，除了对这个变量赋值或者销毁它之外，将不再使用它。它返回一个右值引用。</p>
<p>对<code>move</code>不使用<code>using</code>声明，直接使用<code>std::move</code>。</p>
<h4 id="移动构造函数和移动赋值运算符">移动构造函数和移动赋值运算符</h4>
<p>移动构造函数的第一个参数是该类型的一个应用，与拷贝构造函数不同的是，这个引用参数在构造函数中是一个右值引用。其他所有额外参数都需要有默认实参。</p>
<pre><code class="language-cpp">StrVec(StrVec &amp;&amp;s) noexcept // 不应抛出任何异常。
    : ... { };
</code></pre>
<p>与拷贝构造函数不同，移动构造函数不分配新内存：它接管给定的对象中的内存。接管内存之后，将给定对象中的指针都置为<code>nullptr</code>。这样就完成了从给定对象的移动操作。</p>
<p>由于移动操作不分配资源，所以通常不会抛出异常。对于一个不会抛出异常的操作，应该通知标准库，否则它会做一些额外的工作。通知的方法就是在声明和定义中都指定<code>noexcept</code>。</p>
<p>移动赋值运算符执行与析构函数和移动构造函数相同的工作。</p>
<p>从一个对象移动数据并不会销毁这个对象，但是有时候在操作完成之后，源对象会被销毁。因此，当我们编写一个移动操作时，必须确保源对象进入一个可析构状态。</p>
<p>编译器也会合成移动构造函数和赋值运算符，但是和合成拷贝操作大不一样。如果一个类定义了自己的拷贝构造函数、赋值运算符或者析构函数，那么编译器就不会为它合成移动构造函数和赋值运算符。这时候，就会用拷贝操作代替移动操作。</p>
<p>当同时存在移动和拷贝构造函数时，通过匹配来选择。移动右值，拷贝左值。没有移动构造函数时，右值也会被拷贝。</p>
<h3 id="重载运算与类型转换">重载运算与类型转换</h3>
<p>重载的运算符是有特殊名字的函数，<code>operator</code>加上要定义的运算符号。</p>
<pre><code class="language-cpp">// 以下两个表达式等价
data1 + data2;
operator+(data1, data2);
</code></pre>
<p>某些运算符不应该被重载：逗号、取址符、逻辑与、逻辑或。</p>
<p>对于运算符应该作为类成员还是非成员，有几条准则帮助做出选择：</p>
<ul>
<li>赋值、下标、调用、成员访问箭头运算符必须是成员；</li>
<li>复合赋值运算符一般来说必须是成员，但并非必须；</li>
<li>改变对象状态的、与给定类型密切相关的，如递增、递减、解引用，通常来说是成员；</li>
<li>具有对称性的，算数、相等性、关系、位运算符等，一般是非成员函数。</li>
</ul>
<h4 id="输入输出">输入输出</h4>
<p>输出运算符<code>&lt;&lt;</code>的第一个形参是一个非常量<code>ostream</code>的引用，第二个形参一般是一个常量的引用，这个形参是我们想要打印的对象。返回值一般需要是它的<code>ostream</code>形参。</p>
<p>与<code>&lt;iostream&gt;</code>兼容的输入输出运算符必须是普通的非成员函数，而不是类成员函数，否则左侧运算对象将是类的对象。</p>
<pre><code class="language-cpp">X data;
data &lt;&lt; cout; // operator&lt;&lt; 是 X 的成员
</code></pre>
<p>输入运算符<code>&gt;&gt;</code>的第一个形参是要读取的流的引用，第二个形参是要读入到的对象的引用。</p>
<p>输入很可能发生错误，所以需要检查错误。</p>
<pre><code class="language-cpp">istream &amp;operator&gt;&gt;(istream &amp;is, X &amp;item) {
    is &gt;&gt; X.a &gt;&gt; X.b;
    if (!is)
        item = X(); // 如果输入失败，重置对象
    return is;
}
</code></pre>
<h4 id="递增和递减">递增和递减</h4>
<pre><code class="language-cpp">class X {
public:
    X&amp; operator++(); // 前置
    X&amp; operator--();
    X&amp; operator++(int); // 后置
    X&amp; operator--(int);
}
</code></pre>
<p>对于后置运算符，会接受一个额外的<code>int</code>类型的形参，使用时，编译器为这个形参提供一个值为 0 的实参。</p>
<h4 id="成员访问运算符">成员访问运算符</h4>
<p>解引用和箭头运算符经常会被迭代器类和智能指针类使用。</p>
<p>解引用运算符与普通函数没什么差别，能完成任何指定的操作，但箭头运算符只能用于获取成员。即是说<code>ptr-&gt;mem</code>必须等价于<code>(*ptr).mem</code>。</p>
<h4 id="lambda的本质"><code>lambda</code>的本质</h4>
<p>一个<code>lambda</code>表达式相当于产生了一个匿名类的匿名对象。</p>
<pre><code class="language-cpp">[](const string &amp;a, const string &amp;b){ return a.size() &lt; b.size(); };

class emm {
public:
    bool operator()(const string &amp;a, const string &amp;b) const {
        return a.size() &lt; b.size();
    }
};

[sz](const string &amp;s) { return s.size() &lt; sz; };

class emm {
public:
    emm(size_t n): sz(n) { }
    bool operator()(const string &amp;s) const {
        return s.size() &lt; sz;
    }
private:
    size_t sz;
}
</code></pre>
<h4 id="function"><code>function</code></h4>
<p>对于不同类型可调用对象，比如重载了<code>()</code>的类、<code>lambda</code>对象、函数，返回值和接受的形参列表可能是相同的，但是类型不同，所以无法统一管理。使用<code>function</code>类可以管理它们。</p>
<pre><code class="language-cpp">function&lt;int(int,int)&gt; IntFunc1;
function&lt;int(int,int)&gt; IntFunc2(nullptr);
function&lt;int(int,int)&gt; IntFunc3([](int a, int b) { return a+b });
int mod(int a, int b) {
    return a%b;
}
function&lt;int(int,int)&gt; IntFunc4(mod);
</code></pre>
<p><code>function</code>类中定义了一些类型：</p>
<ul>
<li><code>result_type</code>，返回的类型；；</li>
<li><code>argument_type</code>，唯一参数的类型；</li>
<li><code>first_argument_type</code>，第一个参数的类型；</li>
<li><code>second_argument_type</code>，第二个参数的类型。</li>
</ul>
<h4 id="类型转换运算符">类型转换运算符</h4>
<p>用于将类的值转换为其他类型。</p>
<pre><code class="language-cpp">class emm {
public:
    emm(int i = 0): num(i) { }
    operator int() const { return num; } // 转换为 int
private:
    int num;
}
</code></pre>
<p>一般来说，类型转换比较少见，而定义向<code>bool</code>类型的转换倒是比较常见的事。但是这样有一个问题，<code>bool</code>类型是算术类型，如果被转换就会支持很多运算。为了避免这样的异常，可以提供<code>explicit</code>声明，这样就需要强制转换。</p>
<pre><code class="language-cpp">class emm {
public:
    // ...
    explicit  operator int() const { return num; }
    // ...
}

emm i = 3;
static_cast&lt;int&gt;(i); // 3
</code></pre>
<p>这个规定有一个例外：当表达式被用作条件判断时，<code>explicit</code>转换也会被隐式调用。</p>

                        </div>
                        <div class="post-toc">
                            <ul class="markdownIt-TOC">
<li>
<ul>
<li>
<ul>
<li><a href="#%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95">泛型算法</a>
<ul>
<li><a href="#accumulate"><code>accumulate</code></a></li>
<li><a href="#equal"><code>equal</code></a></li>
<li><a href="#fill"><code>fill</code></a></li>
<li><a href="#file_n"><code>file_n</code></a></li>
<li><a href="#back_inserter"><code>back_inserter</code></a></li>
<li><a href="#copy"><code>copy</code></a></li>
<li><a href="#unique"><code>unique</code></a></li>
<li><a href="#erase"><code>erase</code></a></li>
<li><a href="#sort"><code>sort</code></a></li>
<li><a href="#transform"><code>transform</code></a></li>
<li><a href="#find_if"><code>find_if</code></a></li>
<li><a href="#for_each"><code>for_each</code></a></li>
<li><a href="#lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><code>lambda</code>表达式</a></li>
<li><a href="#bind"><code>bind</code></a></li>
<li><a href="#%E8%BF%AD%E4%BB%A3%E5%99%A8">迭代器</a>
<ul>
<li><a href="#%E6%8F%92%E5%85%A5%E8%BF%AD%E4%BB%A3%E5%99%A8">插入迭代器</a></li>
<li><a href="#iostream%E8%BF%AD%E4%BB%A3%E5%99%A8"><code>iostream</code>迭代器</a></li>
<li><a href="#%E5%8F%8D%E5%90%91%E8%BF%AD%E4%BB%A3%E5%99%A8">反向迭代器</a></li>
</ul>
</li>
<li><a href="#%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95%E7%BB%93%E6%9E%84">泛型算法结构</a></li>
</ul>
</li>
<li><a href="#%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8">关联容器</a>
<ul>
<li><a href="#pair"><code>pair</code></a></li>
<li><a href="#%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8%E6%93%8D%E4%BD%9C">关联容器操作</a>
<ul>
<li><a href="#%E8%BF%AD%E4%BB%A3%E5%99%A8-2">迭代器</a></li>
<li><a href="#%E6%8F%92%E5%85%A5-%E5%88%A0%E9%99%A4-%E6%9F%A5%E8%AF%A2">插入、删除、查询</a></li>
</ul>
</li>
<li><a href="#%E6%97%A0%E5%BA%8F%E5%AE%B9%E5%99%A8">无序容器</a></li>
</ul>
</li>
<li><a href="#%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98">动态内存</a>
<ul>
<li><a href="#%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E4%B8%8E%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88">动态内存与智能指针</a>
<ul>
<li><a href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%9A%84%E4%B8%80%E8%88%AC%E6%93%8D%E4%BD%9C">智能指针的一般操作</a></li>
</ul>
</li>
<li><a href="#shared_ptr"><code>shared_ptr</code></a>
<ul>
<li><a href="#make_shared"><code>make_shared</code></a></li>
<li><a href="#%E6%8B%B7%E8%B4%9D-%E8%B5%8B%E5%80%BC-%E6%9E%90%E6%9E%84">拷贝、赋值、析构</a></li>
</ul>
</li>
<li><a href="#%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%9A%84%E4%BD%BF%E7%94%A8">动态内存的使用</a></li>
<li><a href="#%E7%9B%B4%E6%8E%A5%E7%AE%A1%E7%90%86%E5%86%85%E5%AD%98">直接管理内存</a></li>
<li><a href="#%E7%BB%93%E5%90%88%E4%BD%BF%E7%94%A8shared_ptr%E5%92%8Cnew">结合使用<code>shared_ptr</code>和<code>new</code></a></li>
<li><a href="#unique_ptr"><code>unique_ptr</code></a></li>
<li><a href="#weak_ptr"><code>weak_ptr</code></a></li>
</ul>
</li>
<li><a href="#%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6">拷贝控制</a>
<ul>
<li><a href="#%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0">拷贝构造函数</a></li>
<li><a href="#%E6%8B%B7%E8%B4%9D%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6">拷贝赋值运算符</a></li>
<li><a href="#%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0">析构函数</a></li>
<li><a href="#%E4%B8%89%E4%BA%94%E6%B3%95%E5%88%99">三/五法则</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8default">使用<code>=default</code></a></li>
<li><a href="#%E9%98%BB%E6%AD%A2%E6%8B%B7%E8%B4%9D">阻止拷贝</a></li>
<li><a href="#%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%96%B9%E5%BC%8F">引用计数的工作方式</a></li>
<li><a href="#%E5%AF%B9%E8%B1%A1%E7%A7%BB%E5%8A%A8">对象移动</a>
<ul>
<li><a href="#%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8">右值引用</a></li>
<li><a href="#stdmove"><code>std::move</code></a></li>
</ul>
</li>
<li><a href="#%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E7%A7%BB%E5%8A%A8%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6">移动构造函数和移动赋值运算符</a></li>
</ul>
</li>
<li><a href="#%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2">重载运算与类型转换</a>
<ul>
<li><a href="#%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA">输入输出</a></li>
<li><a href="#%E9%80%92%E5%A2%9E%E5%92%8C%E9%80%92%E5%87%8F">递增和递减</a></li>
<li><a href="#%E6%88%90%E5%91%98%E8%AE%BF%E9%97%AE%E8%BF%90%E7%AE%97%E7%AC%A6">成员访问运算符</a></li>
<li><a href="#lambda%E7%9A%84%E6%9C%AC%E8%B4%A8"><code>lambda</code>的本质</a></li>
<li><a href="#function"><code>function</code></a></li>
<li><a href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E8%BF%90%E7%AE%97%E7%AC%A6">类型转换运算符</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

                        </div>
                        <section class="post-copyright en">
                            <!--en-->
                            <p class="copyright-item">
                                <span>Author:</span>
                                <span>拭微</span>
                            </p>

                            <p class="copyright-item">
                                <span>Permalink:</span>
                                <span><a href="https://wzhzzmzzy.github.io/post/2018-2-7-Cpp学习记录">https://wzhzzmzzy.github.io/post/2018-2-7-Cpp学习记录</a></span>
                            </p>

                            <p class="copyright-item">
                                <span>License:</span>
                                <span>MIT License</span>
                            </p>
                        </section>
                        <section class="post-copyright zh">
                            <!--zh-->
                            <p class="copyright-item ">
                                <span>&#x4F5C;&#x8005;:</span>
                                <span>拭微</span>
                            </p>

                            <p class="copyright-item">
                                <span>&#x6C38;&#x4E45;&#x94FE;&#x63A5;:</span>
                                <span><a href="https://wzhzzmzzy.github.io/post/2018-2-7-Cpp学习记录">https://wzhzzmzzy.github.io/post/2018-2-7-Cpp学习记录</a></span>
                            </p>

                            <p class="copyright-item">
                                <span>&#x534F;&#x8BAE;:</span>
                                <span>MIT License</span>
                            </p>
                        </section>
                        <!--en-->
                        <section class="post-tags en">
                            <div>
                                <span>Tag(s):</span>
                                <span class="tag">
                                
                                
                                <a href="https://wzhzzmzzy.github.io/tag/cDUFQDRC3M"># C++</a>
                                
                                
                            </span>
                            </div>
                            <div>
                                <a href="javascript:window.history.back();">back</a>
                                <span>&dot;</span>
                                <a href="#">home</a>
                            </div>
                        </section>
                        <!--zh-->
                        <section class="post-tags zh">
                            <div>
                                <span>&#x6807;&#x7B7E;:</span>
                                <span class="tag">
                                
                                
                                <a href="https://wzhzzmzzy.github.io/tag/cDUFQDRC3M"># C++</a>
                                
                                
                            </span>
                            </div>
                            <div>
                                <a href="javascript:window.history.back();">
                                &#x8FD4;&#x56DE;</a>
                                <span>&dot;</span>
                                <a href="#">&#x4E3B;&#x9875;</a>
                            </div>
                        </section>
                        <section class="post-nav">
                            
                                <a class="prev" rel="prev" href="https://wzhzzmzzy.github.io/post/2018-2-10-Cpp学习记录">
                                    C++ 学习记录（三）—— C++ 中的 OOP
                                </a>
                                
                                    
                                        <a class="next" rel="next" href="https://wzhzzmzzy.github.io/post/2018-2-6-Cpp学习记录">
                                            C++ 学习记录（一）—— 从引用开始
                                        </a>
                                        
                        </section>
                    </article>
                </div>
                
            </div>
    </div>
    </div>
    </div>
    
    <div id="player"></div>
    
        <footer id="footer" class="footer">

            <div class="copyright">
                <!-- <div class="Like">
                    <div class="tip" data-tooltip="Do you like it?">
                        <a href="https://github.com/ITJoker233/Gridea-theme-Chic" target="_blank" title=""><svg class="icon"
                        aria-hidden="true">
                        <use xlink:href="#like"></use>
                    </svg><b class="like_text" id="star"></b></a>
                    </div>
                </div> -->
                
                    <b id="hitokoto"></b><br>
                    <!-- <svg viewBox="0 0 1024 1024" style="margin-left: 5px;margin-right: 5px;" version="1.0" width="8" height="8" class="my-face">
            <path
                d="M863.597631 513.574282l-271.33965-140.213484L729.783667 81.926656c3.583731-7.87141 7.167462-15.742819 7.167462-25.214109C736.887134 25.226908 708.345275 0.012799 672.635953 0.012799a63.611229 63.611229 0 0 0-39.293053 12.607055c-1.791866 1.59988-3.519736 3.19976-5.311602 3.19976L147.87531 418.925381a55.547834 55.547834 0 0 0-19.646527 47.356448c1.791866 17.278704 14.27093 33.021523 32.125591 42.492813l271.33965 141.749369L292.504463 945.221908c-12.479064 25.214109-1.791866 53.563983 23.166262 69.306802 10.751194 6.335525 23.230258 9.47129 35.709322 9.47129 16.062795 0 32.125591-4.735645 44.604655-15.742819l480.091993-403.297753a55.547834 55.547834 0 0 0 19.646526-47.228458 61.243407 61.243407 0 0 0-32.12559-44.156688z"
                fill="#93b5cf"></path>
        </svg> -->
                    拭微 &copy;Copyright
                        <script>
                            var date = new Date();
                            document.write("" + date.getFullYear());
                        </script>
                        <!-- | Powered by <a href="https://coding.net" target="_blank">Coding.net</a> -->
            </div>
            <div id="update" style="display:none;">
                on
            </div>
            
                <div id="version" style="display:none;">
                    1.6.2
                </div>
                
                    <script>
                        var pat = '';
                        
                        document.write('<div id="home_path" style="display:none;">' + document.location.protocol + '//' + window.document.location.hostname + pat + '</div>')
                    </script>

        </footer>
        
            <script src='https://cdn.jsdelivr.net/npm/live2d-widget@3.x/lib/L2Dwidget.min.js'></script>
            
                <script>
                    

                    function LoadPlayer() {
                        var audio_name = 'きっとまたいつか';
                        var audio_artist = 'DEPAPEPE';
                        var audio_url = 'http://music.163.com/song/media/outer/url?id=22688472.mp3';
                        var audio_cover = 'https://p3fx.kgimg.com/stdmusic/20150718/20150718063022611128.jpg';
                        const ap = new APlayer({
                            container: document.getElementById('player'),
                            fixed: true,
                            audio: [{
                                name: audio_name,
                                artist: audio_artist,
                                url: audio_url,
                                cover: audio_cover,
                            }]
                        });
                    }
                    LoadPlayer();
                    
                    
                    loadlive2d();
                    
                    // hitokoto();
                    getStar();
                    hljs.initHighlighting();
                    console.clear();
                    
                    CheckVersion();
                    
                    console.log("\n %c \u26a1Theme:Chic Author's Blog:https://blog.itjoker.cn  Write By ITJoker  \n\n", "color: #ffffff; background: rgba(49, 49, 49, 0.85); padding:5px 0;border-radius:5px;");
                </script>
        </div>
</body>
<script>
    scroll();
</script>

</html>